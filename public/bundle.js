// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

// eslint-disable-next-line no-global-assign
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  return newRequire;
})({347:[function(require,module,exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],354:[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],356:[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],351:[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":356}],75:[function(require,module,exports) {
var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],363:[function(require,module,exports) {
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],362:[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":363}],460:[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_is-object":363,"./_global":347}],459:[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":351,"./_fails":356,"./_dom-create":460}],364:[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":363}],368:[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":362,"./_ie8-dom-define":459,"./_to-primitive":364,"./_descriptors":351}],365:[function(require,module,exports) {
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],373:[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_object-dp":368,"./_property-desc":365,"./_descriptors":351}],355:[function(require,module,exports) {
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],372:[function(require,module,exports) {
module.exports = false;

},{}],359:[function(require,module,exports) {

var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":75,"./_global":347,"./_library":372}],463:[function(require,module,exports) {
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":359}],353:[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_global":347,"./_hide":373,"./_has":354,"./_uid":355,"./_function-to-string":463,"./_core":75}],338:[function(require,module,exports) {
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],402:[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":338}],329:[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":347,"./_core":75,"./_hide":373,"./_redefine":353,"./_ctx":402}],357:[function(require,module,exports) {
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_uid":355,"./_is-object":363,"./_has":354,"./_object-dp":368,"./_fails":356}],346:[function(require,module,exports) {
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_shared":359,"./_uid":355,"./_global":347}],358:[function(require,module,exports) {
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_object-dp":368,"./_has":354,"./_wks":346}],83:[function(require,module,exports) {
exports.f = require('./_wks');

},{"./_wks":346}],345:[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_global":347,"./_core":75,"./_library":372,"./_wks-ext":83,"./_object-dp":368}],389:[function(require,module,exports) {
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],422:[function(require,module,exports) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":389}],452:[function(require,module,exports) {
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],343:[function(require,module,exports) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_iobject":422,"./_defined":452}],391:[function(require,module,exports) {
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],337:[function(require,module,exports) {
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":391}],414:[function(require,module,exports) {
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":391}],333:[function(require,module,exports) {
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-iobject":343,"./_to-length":337,"./_to-absolute-index":414}],461:[function(require,module,exports) {
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":359,"./_uid":355}],464:[function(require,module,exports) {
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_has":354,"./_to-iobject":343,"./_array-includes":333,"./_shared-key":461}],462:[function(require,module,exports) {
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],369:[function(require,module,exports) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_object-keys-internal":464,"./_enum-bug-keys":462}],367:[function(require,module,exports) {
exports.f = Object.getOwnPropertySymbols;

},{}],371:[function(require,module,exports) {
exports.f = {}.propertyIsEnumerable;

},{}],361:[function(require,module,exports) {
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-keys":369,"./_object-gops":367,"./_object-pie":371}],360:[function(require,module,exports) {
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":389}],336:[function(require,module,exports) {
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":452}],350:[function(require,module,exports) {
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_object-dp":368,"./_an-object":362,"./_object-keys":369,"./_descriptors":351}],424:[function(require,module,exports) {
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":347}],352:[function(require,module,exports) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":362,"./_object-dps":350,"./_enum-bug-keys":462,"./_shared-key":461,"./_dom-create":460,"./_html":424}],370:[function(require,module,exports) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_object-keys-internal":464,"./_enum-bug-keys":462}],366:[function(require,module,exports) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_to-iobject":343,"./_object-gopn":370}],342:[function(require,module,exports) {
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_object-pie":371,"./_property-desc":365,"./_to-iobject":343,"./_to-primitive":364,"./_has":354,"./_ie8-dom-define":459,"./_descriptors":351}],92:[function(require,module,exports) {

'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_global":347,"./_has":354,"./_descriptors":351,"./_export":329,"./_redefine":353,"./_meta":357,"./_fails":356,"./_shared":359,"./_set-to-string-tag":358,"./_uid":355,"./_wks":346,"./_wks-ext":83,"./_wks-define":345,"./_enum-keys":361,"./_is-array":360,"./_an-object":362,"./_is-object":363,"./_to-object":336,"./_to-iobject":343,"./_to-primitive":364,"./_property-desc":365,"./_object-create":352,"./_object-gopn-ext":366,"./_object-gopd":342,"./_object-gops":367,"./_object-dp":368,"./_object-keys":369,"./_object-gopn":370,"./_object-pie":371,"./_library":372,"./_hide":373}],91:[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":329,"./_object-create":352}],95:[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_export":329,"./_descriptors":351,"./_object-dp":368}],94:[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_export":329,"./_descriptors":351,"./_object-dps":350}],380:[function(require,module,exports) {
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_export":329,"./_core":75,"./_fails":356}],96:[function(require,module,exports) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_to-iobject":343,"./_object-gopd":342,"./_object-sap":380}],379:[function(require,module,exports) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":354,"./_to-object":336,"./_shared-key":461}],93:[function(require,module,exports) {
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_to-object":336,"./_object-gpo":379,"./_object-sap":380}],97:[function(require,module,exports) {
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_to-object":336,"./_object-keys":369,"./_object-sap":380}],98:[function(require,module,exports) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-sap":380,"./_object-gopn-ext":366}],99:[function(require,module,exports) {
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":363,"./_meta":357,"./_object-sap":380}],100:[function(require,module,exports) {
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":363,"./_meta":357,"./_object-sap":380}],101:[function(require,module,exports) {
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":363,"./_meta":357,"./_object-sap":380}],102:[function(require,module,exports) {
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":363,"./_object-sap":380}],103:[function(require,module,exports) {
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":363,"./_object-sap":380}],104:[function(require,module,exports) {
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":363,"./_object-sap":380}],398:[function(require,module,exports) {
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":351,"./_object-keys":369,"./_object-gops":367,"./_object-pie":371,"./_to-object":336,"./_iobject":422,"./_fails":356}],105:[function(require,module,exports) {
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":329,"./_object-assign":398}],401:[function(require,module,exports) {
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],106:[function(require,module,exports) {
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":329,"./_same-value":401}],385:[function(require,module,exports) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_is-object":363,"./_an-object":362,"./_ctx":402,"./_object-gopd":342}],107:[function(require,module,exports) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":329,"./_set-proto":385}],386:[function(require,module,exports) {
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":389,"./_wks":346}],108:[function(require,module,exports) {
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":386,"./_wks":346,"./_redefine":353}],483:[function(require,module,exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],400:[function(require,module,exports) {
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":338,"./_is-object":363,"./_invoke":483}],109:[function(require,module,exports) {
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_export":329,"./_bind":400}],110:[function(require,module,exports) {
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_object-dp":368,"./_descriptors":351}],111:[function(require,module,exports) {
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":363,"./_object-gpo":379,"./_wks":346,"./_object-dp":368}],457:[function(require,module,exports) {
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],332:[function(require,module,exports) {
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_export":329,"./_defined":452,"./_fails":356,"./_string-ws":457}],387:[function(require,module,exports) {
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":347,"./_string-trim":332,"./_string-ws":457}],112:[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":329,"./_parse-int":387}],399:[function(require,module,exports) {
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":347,"./_string-trim":332,"./_string-ws":457}],113:[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":329,"./_parse-float":399}],390:[function(require,module,exports) {
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":363,"./_set-proto":385}],114:[function(require,module,exports) {

'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_global":347,"./_has":354,"./_cof":389,"./_inherit-if-required":390,"./_to-primitive":364,"./_fails":356,"./_object-gopn":370,"./_object-gopd":342,"./_object-dp":368,"./_string-trim":332,"./_object-create":352,"./_descriptors":351,"./_redefine":353}],393:[function(require,module,exports) {
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":389}],392:[function(require,module,exports) {
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_to-integer":391,"./_defined":452}],115:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_export":329,"./_to-integer":391,"./_a-number-value":393,"./_string-repeat":392,"./_fails":356}],116:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_export":329,"./_fails":356,"./_a-number-value":393}],117:[function(require,module,exports) {
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":329}],118:[function(require,module,exports) {
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":329,"./_global":347}],394:[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":363}],119:[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":329,"./_is-integer":394}],120:[function(require,module,exports) {
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":329}],121:[function(require,module,exports) {
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":329,"./_is-integer":394}],128:[function(require,module,exports) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":329}],122:[function(require,module,exports) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":329}],123:[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":329,"./_parse-float":399}],165:[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":329,"./_parse-int":387}],395:[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],124:[function(require,module,exports) {
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":329,"./_math-log1p":395}],125:[function(require,module,exports) {
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":329}],127:[function(require,module,exports) {
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":329}],411:[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],126:[function(require,module,exports) {
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":329,"./_math-sign":411}],130:[function(require,module,exports) {
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":329}],129:[function(require,module,exports) {
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":329}],413:[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],166:[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":329,"./_math-expm1":413}],412:[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":411}],131:[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":329,"./_math-fround":412}],132:[function(require,module,exports) {
// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":329}],133:[function(require,module,exports) {
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":329,"./_fails":356}],134:[function(require,module,exports) {
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":329}],135:[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":329,"./_math-log1p":395}],136:[function(require,module,exports) {
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":329}],137:[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":329,"./_math-sign":411}],138:[function(require,module,exports) {
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":329,"./_math-expm1":413,"./_fails":356}],139:[function(require,module,exports) {
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":329,"./_math-expm1":413}],140:[function(require,module,exports) {
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":329}],143:[function(require,module,exports) {
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":329,"./_to-absolute-index":414}],141:[function(require,module,exports) {
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":329,"./_to-iobject":343,"./_to-length":337}],142:[function(require,module,exports) {
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":332}],415:[function(require,module,exports) {
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_to-integer":391,"./_defined":452}],396:[function(require,module,exports) {
module.exports = {};

},{}],446:[function(require,module,exports) {
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_object-create":352,"./_property-desc":365,"./_set-to-string-tag":358,"./_hide":373,"./_wks":346}],416:[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_library":372,"./_export":329,"./_redefine":353,"./_hide":373,"./_iterators":396,"./_iter-create":446,"./_set-to-string-tag":358,"./_object-gpo":379,"./_wks":346}],144:[function(require,module,exports) {
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_string-at":415,"./_iter-define":416}],145:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":329,"./_string-at":415}],433:[function(require,module,exports) {
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_is-object":363,"./_cof":389,"./_wks":346}],417:[function(require,module,exports) {
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_is-regexp":433,"./_defined":452}],418:[function(require,module,exports) {
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":346}],146:[function(require,module,exports) {
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":329,"./_to-length":337,"./_string-context":417,"./_fails-is-regexp":418}],147:[function(require,module,exports) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":329,"./_string-context":417,"./_fails-is-regexp":418}],148:[function(require,module,exports) {
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":329,"./_string-repeat":392}],149:[function(require,module,exports) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":329,"./_to-length":337,"./_string-context":417,"./_fails-is-regexp":418}],419:[function(require,module,exports) {
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_export":329,"./_fails":356,"./_defined":452}],150:[function(require,module,exports) {
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":419}],151:[function(require,module,exports) {
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":419}],152:[function(require,module,exports) {
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":419}],153:[function(require,module,exports) {
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":419}],154:[function(require,module,exports) {
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":419}],155:[function(require,module,exports) {
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":419}],156:[function(require,module,exports) {
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":419}],158:[function(require,module,exports) {
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":419}],157:[function(require,module,exports) {
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":419}],159:[function(require,module,exports) {
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":419}],160:[function(require,module,exports) {
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":419}],161:[function(require,module,exports) {
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":419}],162:[function(require,module,exports) {
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":419}],163:[function(require,module,exports) {
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":329}],164:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":329,"./_to-object":336,"./_to-primitive":364,"./_fails":356}],420:[function(require,module,exports) {
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":356}],167:[function(require,module,exports) {
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_export":329,"./_date-to-iso-string":420}],168:[function(require,module,exports) {
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":353}],421:[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":362,"./_to-primitive":364}],169:[function(require,module,exports) {
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_wks":346,"./_hide":373,"./_date-to-primitive":421}],170:[function(require,module,exports) {
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":329,"./_is-array":360}],426:[function(require,module,exports) {
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":362}],428:[function(require,module,exports) {
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":396,"./_wks":346}],344:[function(require,module,exports) {
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":368,"./_property-desc":365}],427:[function(require,module,exports) {
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":386,"./_wks":346,"./_iterators":396,"./_core":75}],409:[function(require,module,exports) {
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":346}],175:[function(require,module,exports) {
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_ctx":402,"./_export":329,"./_to-object":336,"./_iter-call":426,"./_is-array-iter":428,"./_to-length":337,"./_create-property":344,"./core.get-iterator-method":427,"./_iter-detect":409}],171:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_export":329,"./_create-property":344,"./_fails":356}],423:[function(require,module,exports) {
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":356}],172:[function(require,module,exports) {
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":329,"./_to-iobject":343,"./_iobject":422,"./_strict-method":423}],174:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_export":329,"./_html":424,"./_cof":389,"./_to-absolute-index":414,"./_to-length":337,"./_fails":356}],173:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_export":329,"./_a-function":338,"./_to-object":336,"./_fails":356,"./_strict-method":423}],458:[function(require,module,exports) {
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-object":363,"./_is-array":360,"./_wks":346}],339:[function(require,module,exports) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":458}],425:[function(require,module,exports) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_ctx":402,"./_iobject":422,"./_to-object":336,"./_to-length":337,"./_array-species-create":339}],176:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_export":329,"./_array-methods":425,"./_strict-method":423}],177:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_export":329,"./_array-methods":425,"./_strict-method":423}],178:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_export":329,"./_array-methods":425,"./_strict-method":423}],180:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_export":329,"./_array-methods":425,"./_strict-method":423}],181:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_export":329,"./_array-methods":425,"./_strict-method":423}],429:[function(require,module,exports) {
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":338,"./_to-object":336,"./_iobject":422,"./_to-length":337}],179:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_export":329,"./_array-reduce":429,"./_strict-method":423}],182:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_export":329,"./_array-reduce":429,"./_strict-method":423}],183:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_export":329,"./_array-includes":333,"./_strict-method":423}],184:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":329,"./_to-iobject":343,"./_to-integer":391,"./_to-length":337,"./_strict-method":423}],430:[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-object":336,"./_to-absolute-index":414,"./_to-length":337}],334:[function(require,module,exports) {
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_wks":346,"./_hide":373}],185:[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_export":329,"./_array-copy-within":430,"./_add-to-unscopables":334}],431:[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-object":336,"./_to-absolute-index":414,"./_to-length":337}],187:[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_export":329,"./_array-fill":431,"./_add-to-unscopables":334}],186:[function(require,module,exports) {
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":329,"./_array-methods":425,"./_add-to-unscopables":334}],188:[function(require,module,exports) {
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":329,"./_array-methods":425,"./_add-to-unscopables":334}],410:[function(require,module,exports) {

'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_global":347,"./_object-dp":368,"./_descriptors":351,"./_wks":346}],189:[function(require,module,exports) {
require('./_set-species')('Array');

},{"./_set-species":410}],432:[function(require,module,exports) {
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],190:[function(require,module,exports) {
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":334,"./_iter-step":432,"./_iterators":396,"./_to-iobject":343,"./_iter-define":416}],434:[function(require,module,exports) {
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":362}],191:[function(require,module,exports) {

var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_global":347,"./_inherit-if-required":390,"./_object-dp":368,"./_object-gopn":370,"./_is-regexp":433,"./_flags":434,"./_descriptors":351,"./_fails":356,"./_wks":346,"./_redefine":353,"./_set-species":410}],435:[function(require,module,exports) {
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":434}],193:[function(require,module,exports) {
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_regexp-exec":435,"./_export":329}],192:[function(require,module,exports) {
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":351,"./_object-dp":368,"./_flags":434}],194:[function(require,module,exports) {

'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./es6.regexp.flags":192,"./_an-object":362,"./_flags":434,"./_descriptors":351,"./_redefine":353,"./_fails":356}],436:[function(require,module,exports) {
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":415}],437:[function(require,module,exports) {
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":386}],438:[function(require,module,exports) {
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./es6.regexp.exec":193,"./_redefine":353,"./_hide":373,"./_fails":356,"./_defined":452,"./_wks":346,"./_regexp-exec":435}],195:[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_an-object":362,"./_to-length":337,"./_advance-string-index":436,"./_regexp-exec-abstract":437,"./_fix-re-wks":438}],196:[function(require,module,exports) {
var global = arguments[3];
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_an-object":362,"./_to-object":336,"./_to-length":337,"./_to-integer":391,"./_advance-string-index":436,"./_regexp-exec-abstract":437,"./_fix-re-wks":438}],198:[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');

// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"./_an-object":362,"./_same-value":401,"./_regexp-exec-abstract":437,"./_fix-re-wks":438}],348:[function(require,module,exports) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_an-object":362,"./_a-function":338,"./_wks":346}],197:[function(require,module,exports) {
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_is-regexp":433,"./_an-object":362,"./_species-constructor":348,"./_advance-string-index":436,"./_to-length":337,"./_regexp-exec-abstract":437,"./_regexp-exec":435,"./_fails":356,"./_fix-re-wks":438}],403:[function(require,module,exports) {
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],404:[function(require,module,exports) {
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_ctx":402,"./_iter-call":426,"./_is-array-iter":428,"./_an-object":362,"./_to-length":337,"./core.get-iterator-method":427}],397:[function(require,module,exports) {


var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_ctx":402,"./_invoke":483,"./_html":424,"./_dom-create":460,"./_global":347,"./_cof":389}],405:[function(require,module,exports) {


var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_global":347,"./_task":397,"./_cof":389}],407:[function(require,module,exports) {
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":338}],406:[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],331:[function(require,module,exports) {

var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":347}],349:[function(require,module,exports) {
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":362,"./_is-object":363,"./_new-promise-capability":407}],408:[function(require,module,exports) {
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":353}],86:[function(require,module,exports) {


'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_library":372,"./_global":347,"./_ctx":402,"./_classof":386,"./_export":329,"./_is-object":363,"./_a-function":338,"./_an-instance":403,"./_for-of":404,"./_species-constructor":348,"./_task":397,"./_microtask":405,"./_new-promise-capability":407,"./_perform":406,"./_user-agent":331,"./_promise-resolve":349,"./_wks":346,"./_redefine-all":408,"./_set-to-string-tag":358,"./_set-species":410,"./_core":75,"./_iter-detect":409}],440:[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":363}],442:[function(require,module,exports) {
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_object-dp":368,"./_object-create":352,"./_redefine-all":408,"./_ctx":402,"./_an-instance":403,"./_for-of":404,"./_iter-define":416,"./_iter-step":432,"./_set-species":410,"./_descriptors":351,"./_meta":357,"./_validate-collection":440}],441:[function(require,module,exports) {

'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_global":347,"./_export":329,"./_redefine":353,"./_redefine-all":408,"./_meta":357,"./_for-of":404,"./_an-instance":403,"./_is-object":363,"./_fails":356,"./_iter-detect":409,"./_set-to-string-tag":358,"./_inherit-if-required":390}],199:[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection-strong":442,"./_validate-collection":440,"./_collection":441}],200:[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection-strong":442,"./_validate-collection":440,"./_collection":441}],439:[function(require,module,exports) {
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_redefine-all":408,"./_meta":357,"./_an-object":362,"./_is-object":363,"./_an-instance":403,"./_for-of":404,"./_array-methods":425,"./_has":354,"./_validate-collection":440}],201:[function(require,module,exports) {

'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_global":347,"./_array-methods":425,"./_redefine":353,"./_meta":357,"./_object-assign":398,"./_collection-weak":439,"./_is-object":363,"./_validate-collection":440,"./_collection":441}],202:[function(require,module,exports) {
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection-weak":439,"./_validate-collection":440,"./_collection":441}],443:[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":347,"./_hide":373,"./_uid":355}],484:[function(require,module,exports) {
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":391,"./_to-length":337}],444:[function(require,module,exports) {

'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_global":347,"./_descriptors":351,"./_library":372,"./_typed":443,"./_hide":373,"./_redefine-all":408,"./_fails":356,"./_an-instance":403,"./_to-integer":391,"./_to-length":337,"./_to-index":484,"./_object-gopn":370,"./_object-dp":368,"./_array-fill":431,"./_set-to-string-tag":358}],203:[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_export":329,"./_typed":443,"./_typed-buffer":444,"./_an-object":362,"./_to-absolute-index":414,"./_to-length":337,"./_is-object":363,"./_global":347,"./_species-constructor":348,"./_fails":356,"./_set-species":410}],204:[function(require,module,exports) {
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":329,"./_typed":443,"./_typed-buffer":444}],445:[function(require,module,exports) {
var global = arguments[3];
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_descriptors":351,"./_library":372,"./_global":347,"./_fails":356,"./_export":329,"./_typed":443,"./_typed-buffer":444,"./_ctx":402,"./_an-instance":403,"./_property-desc":365,"./_hide":373,"./_redefine-all":408,"./_to-integer":391,"./_to-length":337,"./_to-index":484,"./_to-absolute-index":414,"./_to-primitive":364,"./_has":354,"./_classof":386,"./_is-object":363,"./_to-object":336,"./_is-array-iter":428,"./_object-create":352,"./_object-gpo":379,"./_object-gopn":370,"./core.get-iterator-method":427,"./_uid":355,"./_wks":346,"./_array-methods":425,"./_array-includes":333,"./_species-constructor":348,"./es6.array.iterator":190,"./_iterators":396,"./_iter-detect":409,"./_set-species":410,"./_array-fill":431,"./_array-copy-within":430,"./_object-dp":368,"./_object-gopd":342}],207:[function(require,module,exports) {
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],208:[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],210:[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":445}],205:[function(require,module,exports) {
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],206:[function(require,module,exports) {
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],209:[function(require,module,exports) {
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],211:[function(require,module,exports) {
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],212:[function(require,module,exports) {
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],213:[function(require,module,exports) {
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":445}],214:[function(require,module,exports) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_export":329,"./_a-function":338,"./_an-object":362,"./_global":347,"./_fails":356}],215:[function(require,module,exports) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_export":329,"./_object-create":352,"./_a-function":338,"./_an-object":362,"./_is-object":363,"./_fails":356,"./_bind":400,"./_global":347}],216:[function(require,module,exports) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_object-dp":368,"./_export":329,"./_an-object":362,"./_to-primitive":364,"./_fails":356}],217:[function(require,module,exports) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_export":329,"./_object-gopd":342,"./_an-object":362}],218:[function(require,module,exports) {
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_export":329,"./_an-object":362,"./_iter-create":446}],219:[function(require,module,exports) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_object-gopd":342,"./_object-gpo":379,"./_has":354,"./_export":329,"./_is-object":363,"./_an-object":362}],220:[function(require,module,exports) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_object-gopd":342,"./_export":329,"./_an-object":362}],221:[function(require,module,exports) {
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_export":329,"./_object-gpo":379,"./_an-object":362}],222:[function(require,module,exports) {
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":329}],223:[function(require,module,exports) {
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_export":329,"./_an-object":362}],341:[function(require,module,exports) {
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_object-gopn":370,"./_object-gops":367,"./_an-object":362,"./_global":347}],224:[function(require,module,exports) {
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":329,"./_own-keys":341}],225:[function(require,module,exports) {
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":329,"./_an-object":362}],226:[function(require,module,exports) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_object-dp":368,"./_object-gopd":342,"./_object-gpo":379,"./_has":354,"./_export":329,"./_property-desc":365,"./_an-object":362,"./_is-object":363}],227:[function(require,module,exports) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":329,"./_set-proto":385}],54:[function(require,module,exports) {
require('../modules/es6.symbol');
require('../modules/es6.object.create');
require('../modules/es6.object.define-property');
require('../modules/es6.object.define-properties');
require('../modules/es6.object.get-own-property-descriptor');
require('../modules/es6.object.get-prototype-of');
require('../modules/es6.object.keys');
require('../modules/es6.object.get-own-property-names');
require('../modules/es6.object.freeze');
require('../modules/es6.object.seal');
require('../modules/es6.object.prevent-extensions');
require('../modules/es6.object.is-frozen');
require('../modules/es6.object.is-sealed');
require('../modules/es6.object.is-extensible');
require('../modules/es6.object.assign');
require('../modules/es6.object.is');
require('../modules/es6.object.set-prototype-of');
require('../modules/es6.object.to-string');
require('../modules/es6.function.bind');
require('../modules/es6.function.name');
require('../modules/es6.function.has-instance');
require('../modules/es6.parse-int');
require('../modules/es6.parse-float');
require('../modules/es6.number.constructor');
require('../modules/es6.number.to-fixed');
require('../modules/es6.number.to-precision');
require('../modules/es6.number.epsilon');
require('../modules/es6.number.is-finite');
require('../modules/es6.number.is-integer');
require('../modules/es6.number.is-nan');
require('../modules/es6.number.is-safe-integer');
require('../modules/es6.number.max-safe-integer');
require('../modules/es6.number.min-safe-integer');
require('../modules/es6.number.parse-float');
require('../modules/es6.number.parse-int');
require('../modules/es6.math.acosh');
require('../modules/es6.math.asinh');
require('../modules/es6.math.atanh');
require('../modules/es6.math.cbrt');
require('../modules/es6.math.clz32');
require('../modules/es6.math.cosh');
require('../modules/es6.math.expm1');
require('../modules/es6.math.fround');
require('../modules/es6.math.hypot');
require('../modules/es6.math.imul');
require('../modules/es6.math.log10');
require('../modules/es6.math.log1p');
require('../modules/es6.math.log2');
require('../modules/es6.math.sign');
require('../modules/es6.math.sinh');
require('../modules/es6.math.tanh');
require('../modules/es6.math.trunc');
require('../modules/es6.string.from-code-point');
require('../modules/es6.string.raw');
require('../modules/es6.string.trim');
require('../modules/es6.string.iterator');
require('../modules/es6.string.code-point-at');
require('../modules/es6.string.ends-with');
require('../modules/es6.string.includes');
require('../modules/es6.string.repeat');
require('../modules/es6.string.starts-with');
require('../modules/es6.string.anchor');
require('../modules/es6.string.big');
require('../modules/es6.string.blink');
require('../modules/es6.string.bold');
require('../modules/es6.string.fixed');
require('../modules/es6.string.fontcolor');
require('../modules/es6.string.fontsize');
require('../modules/es6.string.italics');
require('../modules/es6.string.link');
require('../modules/es6.string.small');
require('../modules/es6.string.strike');
require('../modules/es6.string.sub');
require('../modules/es6.string.sup');
require('../modules/es6.date.now');
require('../modules/es6.date.to-json');
require('../modules/es6.date.to-iso-string');
require('../modules/es6.date.to-string');
require('../modules/es6.date.to-primitive');
require('../modules/es6.array.is-array');
require('../modules/es6.array.from');
require('../modules/es6.array.of');
require('../modules/es6.array.join');
require('../modules/es6.array.slice');
require('../modules/es6.array.sort');
require('../modules/es6.array.for-each');
require('../modules/es6.array.map');
require('../modules/es6.array.filter');
require('../modules/es6.array.some');
require('../modules/es6.array.every');
require('../modules/es6.array.reduce');
require('../modules/es6.array.reduce-right');
require('../modules/es6.array.index-of');
require('../modules/es6.array.last-index-of');
require('../modules/es6.array.copy-within');
require('../modules/es6.array.fill');
require('../modules/es6.array.find');
require('../modules/es6.array.find-index');
require('../modules/es6.array.species');
require('../modules/es6.array.iterator');
require('../modules/es6.regexp.constructor');
require('../modules/es6.regexp.exec');
require('../modules/es6.regexp.to-string');
require('../modules/es6.regexp.flags');
require('../modules/es6.regexp.match');
require('../modules/es6.regexp.replace');
require('../modules/es6.regexp.search');
require('../modules/es6.regexp.split');
require('../modules/es6.promise');
require('../modules/es6.map');
require('../modules/es6.set');
require('../modules/es6.weak-map');
require('../modules/es6.weak-set');
require('../modules/es6.typed.array-buffer');
require('../modules/es6.typed.data-view');
require('../modules/es6.typed.int8-array');
require('../modules/es6.typed.uint8-array');
require('../modules/es6.typed.uint8-clamped-array');
require('../modules/es6.typed.int16-array');
require('../modules/es6.typed.uint16-array');
require('../modules/es6.typed.int32-array');
require('../modules/es6.typed.uint32-array');
require('../modules/es6.typed.float32-array');
require('../modules/es6.typed.float64-array');
require('../modules/es6.reflect.apply');
require('../modules/es6.reflect.construct');
require('../modules/es6.reflect.define-property');
require('../modules/es6.reflect.delete-property');
require('../modules/es6.reflect.enumerate');
require('../modules/es6.reflect.get');
require('../modules/es6.reflect.get-own-property-descriptor');
require('../modules/es6.reflect.get-prototype-of');
require('../modules/es6.reflect.has');
require('../modules/es6.reflect.is-extensible');
require('../modules/es6.reflect.own-keys');
require('../modules/es6.reflect.prevent-extensions');
require('../modules/es6.reflect.set');
require('../modules/es6.reflect.set-prototype-of');
module.exports = require('../modules/_core');

},{"../modules/es6.symbol":92,"../modules/es6.object.create":91,"../modules/es6.object.define-property":95,"../modules/es6.object.define-properties":94,"../modules/es6.object.get-own-property-descriptor":96,"../modules/es6.object.get-prototype-of":93,"../modules/es6.object.keys":97,"../modules/es6.object.get-own-property-names":98,"../modules/es6.object.freeze":99,"../modules/es6.object.seal":100,"../modules/es6.object.prevent-extensions":101,"../modules/es6.object.is-frozen":102,"../modules/es6.object.is-sealed":103,"../modules/es6.object.is-extensible":104,"../modules/es6.object.assign":105,"../modules/es6.object.is":106,"../modules/es6.object.set-prototype-of":107,"../modules/es6.object.to-string":108,"../modules/es6.function.bind":109,"../modules/es6.function.name":110,"../modules/es6.function.has-instance":111,"../modules/es6.parse-int":112,"../modules/es6.parse-float":113,"../modules/es6.number.constructor":114,"../modules/es6.number.to-fixed":115,"../modules/es6.number.to-precision":116,"../modules/es6.number.epsilon":117,"../modules/es6.number.is-finite":118,"../modules/es6.number.is-integer":119,"../modules/es6.number.is-nan":120,"../modules/es6.number.is-safe-integer":121,"../modules/es6.number.max-safe-integer":128,"../modules/es6.number.min-safe-integer":122,"../modules/es6.number.parse-float":123,"../modules/es6.number.parse-int":165,"../modules/es6.math.acosh":124,"../modules/es6.math.asinh":125,"../modules/es6.math.atanh":127,"../modules/es6.math.cbrt":126,"../modules/es6.math.clz32":130,"../modules/es6.math.cosh":129,"../modules/es6.math.expm1":166,"../modules/es6.math.fround":131,"../modules/es6.math.hypot":132,"../modules/es6.math.imul":133,"../modules/es6.math.log10":134,"../modules/es6.math.log1p":135,"../modules/es6.math.log2":136,"../modules/es6.math.sign":137,"../modules/es6.math.sinh":138,"../modules/es6.math.tanh":139,"../modules/es6.math.trunc":140,"../modules/es6.string.from-code-point":143,"../modules/es6.string.raw":141,"../modules/es6.string.trim":142,"../modules/es6.string.iterator":144,"../modules/es6.string.code-point-at":145,"../modules/es6.string.ends-with":146,"../modules/es6.string.includes":147,"../modules/es6.string.repeat":148,"../modules/es6.string.starts-with":149,"../modules/es6.string.anchor":150,"../modules/es6.string.big":151,"../modules/es6.string.blink":152,"../modules/es6.string.bold":153,"../modules/es6.string.fixed":154,"../modules/es6.string.fontcolor":155,"../modules/es6.string.fontsize":156,"../modules/es6.string.italics":158,"../modules/es6.string.link":157,"../modules/es6.string.small":159,"../modules/es6.string.strike":160,"../modules/es6.string.sub":161,"../modules/es6.string.sup":162,"../modules/es6.date.now":163,"../modules/es6.date.to-json":164,"../modules/es6.date.to-iso-string":167,"../modules/es6.date.to-string":168,"../modules/es6.date.to-primitive":169,"../modules/es6.array.is-array":170,"../modules/es6.array.from":175,"../modules/es6.array.of":171,"../modules/es6.array.join":172,"../modules/es6.array.slice":174,"../modules/es6.array.sort":173,"../modules/es6.array.for-each":176,"../modules/es6.array.map":177,"../modules/es6.array.filter":178,"../modules/es6.array.some":180,"../modules/es6.array.every":181,"../modules/es6.array.reduce":179,"../modules/es6.array.reduce-right":182,"../modules/es6.array.index-of":183,"../modules/es6.array.last-index-of":184,"../modules/es6.array.copy-within":185,"../modules/es6.array.fill":187,"../modules/es6.array.find":186,"../modules/es6.array.find-index":188,"../modules/es6.array.species":189,"../modules/es6.array.iterator":190,"../modules/es6.regexp.constructor":191,"../modules/es6.regexp.exec":193,"../modules/es6.regexp.to-string":194,"../modules/es6.regexp.flags":192,"../modules/es6.regexp.match":195,"../modules/es6.regexp.replace":196,"../modules/es6.regexp.search":198,"../modules/es6.regexp.split":197,"../modules/es6.promise":86,"../modules/es6.map":199,"../modules/es6.set":200,"../modules/es6.weak-map":201,"../modules/es6.weak-set":202,"../modules/es6.typed.array-buffer":203,"../modules/es6.typed.data-view":204,"../modules/es6.typed.int8-array":207,"../modules/es6.typed.uint8-array":208,"../modules/es6.typed.uint8-clamped-array":210,"../modules/es6.typed.int16-array":205,"../modules/es6.typed.uint16-array":206,"../modules/es6.typed.int32-array":209,"../modules/es6.typed.uint32-array":211,"../modules/es6.typed.float32-array":212,"../modules/es6.typed.float64-array":213,"../modules/es6.reflect.apply":214,"../modules/es6.reflect.construct":215,"../modules/es6.reflect.define-property":216,"../modules/es6.reflect.delete-property":217,"../modules/es6.reflect.enumerate":218,"../modules/es6.reflect.get":219,"../modules/es6.reflect.get-own-property-descriptor":220,"../modules/es6.reflect.get-prototype-of":221,"../modules/es6.reflect.has":222,"../modules/es6.reflect.is-extensible":223,"../modules/es6.reflect.own-keys":224,"../modules/es6.reflect.prevent-extensions":225,"../modules/es6.reflect.set":226,"../modules/es6.reflect.set-prototype-of":227,"../modules/_core":75}],78:[function(require,module,exports) {
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_export":329,"./_array-includes":333,"./_add-to-unscopables":334}],44:[function(require,module,exports) {
require('../../modules/es7.array.includes');
module.exports = require('../../modules/_core').Array.includes;

},{"../../modules/es7.array.includes":78,"../../modules/_core":75}],335:[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_is-array":360,"./_is-object":363,"./_to-length":337,"./_ctx":402,"./_wks":346}],79:[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_export":329,"./_flatten-into-array":335,"./_to-object":336,"./_to-length":337,"./_a-function":338,"./_array-species-create":339,"./_add-to-unscopables":334}],45:[function(require,module,exports) {
require('../../modules/es7.array.flat-map');
module.exports = require('../../modules/_core').Array.flatMap;

},{"../../modules/es7.array.flat-map":79,"../../modules/_core":75}],330:[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_to-length":337,"./_string-repeat":392,"./_defined":452}],76:[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":329,"./_string-pad":330,"./_user-agent":331}],43:[function(require,module,exports) {
require('../../modules/es7.string.pad-start');
module.exports = require('../../modules/_core').String.padStart;

},{"../../modules/es7.string.pad-start":76,"../../modules/_core":75}],384:[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":329,"./_string-pad":330,"./_user-agent":331}],42:[function(require,module,exports) {
require('../../modules/es7.string.pad-end');
module.exports = require('../../modules/_core').String.padEnd;

},{"../../modules/es7.string.pad-end":384,"../../modules/_core":75}],77:[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":332}],46:[function(require,module,exports) {
require('../../modules/es7.string.trim-left');
module.exports = require('../../modules/_core').String.trimLeft;

},{"../../modules/es7.string.trim-left":77,"../../modules/_core":75}],80:[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":332}],49:[function(require,module,exports) {
require('../../modules/es7.string.trim-right');
module.exports = require('../../modules/_core').String.trimRight;

},{"../../modules/es7.string.trim-right":80,"../../modules/_core":75}],82:[function(require,module,exports) {
require('./_wks-define')('asyncIterator');

},{"./_wks-define":345}],48:[function(require,module,exports) {
require('../../modules/es7.symbol.async-iterator');
module.exports = require('../../modules/_wks-ext').f('asyncIterator');

},{"../../modules/es7.symbol.async-iterator":82,"../../modules/_wks-ext":83}],84:[function(require,module,exports) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_export":329,"./_own-keys":341,"./_to-iobject":343,"./_object-gopd":342,"./_create-property":344}],47:[function(require,module,exports) {
require('../../modules/es7.object.get-own-property-descriptors');
module.exports = require('../../modules/_core').Object.getOwnPropertyDescriptors;

},{"../../modules/es7.object.get-own-property-descriptors":84,"../../modules/_core":75}],340:[function(require,module,exports) {
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"./_descriptors":351,"./_object-keys":369,"./_to-iobject":343,"./_object-pie":371}],81:[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":329,"./_object-to-array":340}],50:[function(require,module,exports) {
require('../../modules/es7.object.values');
module.exports = require('../../modules/_core').Object.values;

},{"../../modules/es7.object.values":81,"../../modules/_core":75}],85:[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":329,"./_object-to-array":340}],52:[function(require,module,exports) {
require('../../modules/es7.object.entries');
module.exports = require('../../modules/_core').Object.entries;

},{"../../modules/es7.object.entries":85,"../../modules/_core":75}],87:[function(require,module,exports) {

// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_export":329,"./_core":75,"./_global":347,"./_species-constructor":348,"./_promise-resolve":349}],51:[function(require,module,exports) {
'use strict';
require('../../modules/es6.promise');
require('../../modules/es7.promise.finally');
module.exports = require('../../modules/_core').Promise['finally'];

},{"../../modules/es6.promise":86,"../../modules/es7.promise.finally":87,"../../modules/_core":75}],88:[function(require,module,exports) {

// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_global":347,"./_export":329,"./_user-agent":331}],89:[function(require,module,exports) {
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":329,"./_task":397}],90:[function(require,module,exports) {

var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./es6.array.iterator":190,"./_object-keys":369,"./_redefine":353,"./_global":347,"./_hide":373,"./_iterators":396,"./_wks":346}],55:[function(require,module,exports) {
require('../modules/web.timers');
require('../modules/web.immediate');
require('../modules/web.dom.iterable');
module.exports = require('../modules/_core');

},{"../modules/web.timers":88,"../modules/web.immediate":89,"../modules/web.dom.iterable":90,"../modules/_core":75}],53:[function(require,module,exports) {
var define;
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) });

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
  defineProperty(
    GeneratorFunctionPrototype,
    "constructor",
    { value: GeneratorFunction, configurable: true }
  );
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    defineProperty(this, "_invoke", { value: enqueue });
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method;
    var method = delegate.iterator[methodName];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method, or a missing .next mehtod, always terminate the
      // yield* loop.
      context.delegate = null;

      // Note: ["return"] must be used for ES3 parsing compatibility.
      if (methodName === "throw" && delegate.iterator["return"]) {
        // If the delegate iterator has a return method, give it a
        // chance to clean up.
        context.method = "return";
        context.arg = undefined;
        maybeInvokeDelegate(delegate, context);

        if (context.method === "throw") {
          // If maybeInvokeDelegate(context) changed context.method from
          // "return" to "throw", let that override the TypeError below.
          return ContinueSentinel;
        }
      }
      if (methodName !== "return") {
        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a '" + methodName + "' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(val) {
    var object = Object(val);
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}],19:[function(require,module,exports) {
"use strict";

require("core-js/es6");

require("core-js/fn/array/includes");

require("core-js/fn/array/flat-map");

require("core-js/fn/string/pad-start");

require("core-js/fn/string/pad-end");

require("core-js/fn/string/trim-start");

require("core-js/fn/string/trim-end");

require("core-js/fn/symbol/async-iterator");

require("core-js/fn/object/get-own-property-descriptors");

require("core-js/fn/object/values");

require("core-js/fn/object/entries");

require("core-js/fn/promise/finally");

require("core-js/web");

require("regenerator-runtime/runtime");
},{"core-js/es6":54,"core-js/fn/array/includes":44,"core-js/fn/array/flat-map":45,"core-js/fn/string/pad-start":43,"core-js/fn/string/pad-end":42,"core-js/fn/string/trim-start":46,"core-js/fn/string/trim-end":49,"core-js/fn/symbol/async-iterator":48,"core-js/fn/object/get-own-property-descriptors":47,"core-js/fn/object/values":50,"core-js/fn/object/entries":52,"core-js/fn/promise/finally":51,"core-js/web":55,"regenerator-runtime/runtime":53}],382:[function(require,module,exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],41:[function(require,module,exports) {
var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],521:[function(require,module,exports) {
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],476:[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":521}],630:[function(require,module,exports) {
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],581:[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":630}],590:[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],529:[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":590}],629:[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_is-object":630,"./_global":382}],580:[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":529,"./_fails":590,"./_dom-create":629}],582:[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":630}],528:[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":581,"./_ie8-dom-define":580,"./_to-primitive":582,"./_descriptors":529}],527:[function(require,module,exports) {
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],475:[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_object-dp":528,"./_property-desc":527,"./_descriptors":529}],479:[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],381:[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":382,"./_core":41,"./_ctx":476,"./_hide":475,"./_has":479}],40:[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":381,"./_global":382}],20:[function(require,module,exports) {
require('../modules/es7.global');
module.exports = require('../modules/_core').global;

},{"../modules/es7.global":40,"../modules/_core":41}],12:[function(require,module,exports) {
"use strict";

require("./noConflict");

var _global = _interopRequireDefault(require("core-js/library/fn/global"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

if (_global["default"]._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

_global["default"]._babelPolyfill = true;
},{"./noConflict":19,"core-js/library/fn/global":20}],24:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bind;
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
},{}],22:[function(require,module,exports) {
var global = arguments[3];
var define;
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bind = require('./helpers/bind.js');

var _bind2 = _interopRequireDefault(_bind);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// utils is a library of generic helper functions non-specific to axios

const { toString } = Object.prototype;
const { getPrototypeOf } = Object;

const kindOf = (cache => thing => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = type => {
  type = type.toLowerCase();
  return thing => kindOf(thing) === type;
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const { isArray } = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = thing => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = val => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = val => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = thing => {
  const pattern = '[object FormData]';
  return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
})();

const isContextDefined = context => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = (0, _bind2.default)(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = content => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};

/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = thing => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({ hasOwnProperty }) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = obj => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = arr => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = obj => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if (!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

exports.default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};
},{"./helpers/bind.js":24}],33:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

_utils2.default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _utils2.default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const prototype = AxiosError.prototype;
const descriptors = {};

['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = { value: code };
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', { value: true });

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);

  _utils2.default.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

exports.default = AxiosError;
},{"../utils.js":22}],73:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// eslint-disable-next-line strict
exports.default = null;
},{}],326:[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],327:[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],328:[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],74:[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":326,"ieee754":327,"isarray":328,"buffer":74}],32:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _AxiosError = require('../core/AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

var _FormData = require('../platform/node/classes/FormData.js');

var _FormData2 = _interopRequireDefault(_FormData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return _utils2.default.isPlainObject(thing) || _utils2.default.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */

// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
function removeBrackets(key) {
  return _utils2.default.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return _utils2.default.isArray(arr) && !arr.some(isVisitable);
}

const predicates = _utils2.default.toFlatObject(_utils2.default, {}, null, function filter(prop) {
  return (/^is[A-Z]/.test(prop)
  );
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!_utils2.default.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (_FormData2.default || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = _utils2.default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !_utils2.default.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && _utils2.default.isSpecCompliantForm(formData);

  if (!_utils2.default.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (_utils2.default.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && _utils2.default.isBlob(value)) {
      throw new _AxiosError2.default('Blob is not supported. Use a Buffer instead.');
    }

    if (_utils2.default.isArrayBuffer(value) || _utils2.default.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (_utils2.default.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (_utils2.default.isArray(value) && isFlatArray(value) || (_utils2.default.isFileList(value) || _utils2.default.endsWith(key, '[]')) && (arr = _utils2.default.toArray(value))) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(_utils2.default.isUndefined(el) || el === null) && formData.append(
          // eslint-disable-next-line no-nested-ternary
          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (_utils2.default.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    _utils2.default.forEach(value, function each(el, key) {
      const result = !(_utils2.default.isUndefined(el) || el === null) && visitor.call(formData, el, _utils2.default.isString(key) ? key.trim() : key, path, exposedHelpers);

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!_utils2.default.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

exports.default = toFormData;
},{"../utils.js":22,"../core/AxiosError.js":33,"../platform/node/classes/FormData.js":73,"buffer":74}],322:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toFormData = require('./toFormData.js');

var _toFormData2 = _interopRequireDefault(_toFormData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && (0, _toFormData2.default)(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function (value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

exports.default = AxiosURLSearchParams;
},{"./toFormData.js":32}],69:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildURL;

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _AxiosURLSearchParams = require('../helpers/AxiosURLSearchParams.js');

var _AxiosURLSearchParams2 = _interopRequireDefault(_AxiosURLSearchParams);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = _utils2.default.isURLSearchParams(params) ? params.toString() : new _AxiosURLSearchParams2.default(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}
},{"../utils.js":22,"../helpers/AxiosURLSearchParams.js":322}],65:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    _utils2.default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

exports.default = InterceptorManager;
},{"./../utils.js":22}],70:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
},{}],455:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AxiosURLSearchParams = require('../../../helpers/AxiosURLSearchParams.js');

var _AxiosURLSearchParams2 = _interopRequireDefault(_AxiosURLSearchParams);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof URLSearchParams !== 'undefined' ? URLSearchParams : _AxiosURLSearchParams2.default;
},{"../../../helpers/AxiosURLSearchParams.js":322}],453:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = typeof FormData !== 'undefined' ? FormData : null;
},{}],454:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = typeof Blob !== 'undefined' ? Blob : null;
},{}],325:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _URLSearchParams = require('./classes/URLSearchParams.js');

var _URLSearchParams2 = _interopRequireDefault(_URLSearchParams);

var _FormData = require('./classes/FormData.js');

var _FormData2 = _interopRequireDefault(_FormData);

var _Blob = require('./classes/Blob.js');

var _Blob2 = _interopRequireDefault(_Blob);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && ((product = navigator.product) === 'ReactNative' || product === 'NativeScript' || product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== 'undefined' &&
  // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
})();

exports.default = {
  isBrowser: true,
  classes: {
    URLSearchParams: _URLSearchParams2.default,
    FormData: _FormData2.default,
    Blob: _Blob2.default
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};
},{"./classes/URLSearchParams.js":455,"./classes/FormData.js":453,"./classes/Blob.js":454}],72:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _index = require('./node/index.js');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _index2.default;
},{"./node/index.js":325}],71:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toURLEncodedForm;

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _toFormData = require('./toFormData.js');

var _toFormData2 = _interopRequireDefault(_toFormData);

var _index = require('../platform/index.js');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toURLEncodedForm(data, options) {
  return (0, _toFormData2.default)(data, new _index2.default.classes.URLSearchParams(), Object.assign({
    visitor: function (value, key, path, helpers) {
      if (_index2.default.isNode && _utils2.default.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
},{"../utils.js":22,"./toFormData.js":32,"../platform/index.js":72}],34:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return _utils2.default.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && _utils2.default.isArray(target) ? target.length : name;

    if (isLast) {
      if (_utils2.default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !_utils2.default.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && _utils2.default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (_utils2.default.isFormData(formData) && _utils2.default.isFunction(formData.entries)) {
    const obj = {};

    _utils2.default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

exports.default = formDataToJSON;
},{"../utils.js":22}],27:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _AxiosError = require('../core/AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

var _transitional = require('./transitional.js');

var _transitional2 = _interopRequireDefault(_transitional);

var _toFormData = require('../helpers/toFormData.js');

var _toFormData2 = _interopRequireDefault(_toFormData);

var _toURLEncodedForm = require('../helpers/toURLEncodedForm.js');

var _toURLEncodedForm2 = _interopRequireDefault(_toURLEncodedForm);

var _index = require('../platform/index.js');

var _index2 = _interopRequireDefault(_index);

var _formDataToJSON = require('../helpers/formDataToJSON.js');

var _formDataToJSON2 = _interopRequireDefault(_formDataToJSON);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (_utils2.default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return _utils2.default.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: _transitional2.default,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = _utils2.default.isObject(data);

    if (isObjectPayload && _utils2.default.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = _utils2.default.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify((0, _formDataToJSON2.default)(data)) : data;
    }

    if (_utils2.default.isArrayBuffer(data) || _utils2.default.isBuffer(data) || _utils2.default.isStream(data) || _utils2.default.isFile(data) || _utils2.default.isBlob(data)) {
      return data;
    }
    if (_utils2.default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (_utils2.default.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return (0, _toURLEncodedForm2.default)(data, this.formSerializer).toString();
      }

      if ((isFileList = _utils2.default.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return (0, _toFormData2.default)(isFileList ? { 'files[]': data } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }

    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && _utils2.default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw _AxiosError2.default.from(e, _AxiosError2.default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: _index2.default.classes.FormData,
    Blob: _index2.default.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

_utils2.default.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

_utils2.default.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = _utils2.default.merge(DEFAULT_CONTENT_TYPE);
});

exports.default = defaults;
},{"../utils.js":22,"../core/AxiosError.js":33,"./transitional.js":70,"../helpers/toFormData.js":32,"../helpers/toURLEncodedForm.js":71,"../platform/index.js":72,"../helpers/formDataToJSON.js":34}],388:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = _utils2.default.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */

exports.default = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};
},{"./../utils.js":22}],37:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _parseHeaders = require('../helpers/parseHeaders.js');

var _parseHeaders2 = _interopRequireDefault(_parseHeaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return _utils2.default.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

function isValidHeaderName(str) {
  return (/^[-_a-zA-Z]+$/.test(str.trim())
  );
}

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (_utils2.default.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!_utils2.default.isString(value)) return;

  if (_utils2.default.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (_utils2.default.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}

function buildAccessors(obj, header) {
  const accessorName = _utils2.default.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = _utils2.default.findKey(self, lHeader);

      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) => _utils2.default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (_utils2.default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (_utils2.default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders((0, _parseHeaders2.default)(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils2.default.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (_utils2.default.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (_utils2.default.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils2.default.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = _utils2.default.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (_utils2.default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    _utils2.default.forEach(this, (value, header) => {
      const key = _utils2.default.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    _utils2.default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && _utils2.default.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach(target => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    _utils2.default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

_utils2.default.freezeMethods(AxiosHeaders.prototype);
_utils2.default.freezeMethods(AxiosHeaders);

exports.default = AxiosHeaders;
},{"../utils.js":22,"../helpers/parseHeaders.js":388}],323:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transformData;

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _index = require('../defaults/index.js');

var _index2 = _interopRequireDefault(_index);

var _AxiosHeaders = require('../core/AxiosHeaders.js');

var _AxiosHeaders2 = _interopRequireDefault(_AxiosHeaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || _index2.default;
  const context = response || config;
  const headers = _AxiosHeaders2.default.from(context.headers);
  let data = context.data;

  _utils2.default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}
},{"./../utils.js":22,"../defaults/index.js":27,"../core/AxiosHeaders.js":37}],30:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCancel;
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
},{}],28:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AxiosError = require('../core/AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  _AxiosError2.default.call(this, message == null ? 'canceled' : message, _AxiosError2.default.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

_utils2.default.inherits(CanceledError, _AxiosError2.default, {
  __CANCEL__: true
});

exports.default = CanceledError;
},{"../core/AxiosError.js":33,"../utils.js":22}],490:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = settle;

var _AxiosError = require('./AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new _AxiosError2.default('Request failed with status code ' + response.status, [_AxiosError2.default.ERR_BAD_REQUEST, _AxiosError2.default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
},{"./AxiosError.js":33}],491:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _index = require('../platform/index.js');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _index2.default.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      const cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (_utils2.default.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (_utils2.default.isString(path)) {
        cookie.push('path=' + path);
      }

      if (_utils2.default.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();
},{"./../utils.js":22,"../platform/index.js":72}],321:[function(require,module,exports) {
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isAbsoluteURL;
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d+\-.]*:)?\/\//i.test(url)
  );
}
},{}],320:[function(require,module,exports) {
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = combineURLs;
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}
},{}],66:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildFullPath;

var _isAbsoluteURL = require('../helpers/isAbsoluteURL.js');

var _isAbsoluteURL2 = _interopRequireDefault(_isAbsoluteURL);

var _combineURLs = require('../helpers/combineURLs.js');

var _combineURLs2 = _interopRequireDefault(_combineURLs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !(0, _isAbsoluteURL2.default)(requestedURL)) {
    return (0, _combineURLs2.default)(baseURL, requestedURL);
  }
  return requestedURL;
}
},{"../helpers/isAbsoluteURL.js":321,"../helpers/combineURLs.js":320}],492:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _index = require('../platform/index.js');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _index2.default.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement('a');
  let originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    let href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    const parsed = _utils2.default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();
},{"./../utils.js":22,"../platform/index.js":72}],493:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseProtocol;
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}
},{}],494:[function(require,module,exports) {
'use strict';

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

exports.default = speedometer;
},{}],456:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _settle = require('./../core/settle.js');

var _settle2 = _interopRequireDefault(_settle);

var _cookies = require('./../helpers/cookies.js');

var _cookies2 = _interopRequireDefault(_cookies);

var _buildURL = require('./../helpers/buildURL.js');

var _buildURL2 = _interopRequireDefault(_buildURL);

var _buildFullPath = require('../core/buildFullPath.js');

var _buildFullPath2 = _interopRequireDefault(_buildFullPath);

var _isURLSameOrigin = require('./../helpers/isURLSameOrigin.js');

var _isURLSameOrigin2 = _interopRequireDefault(_isURLSameOrigin);

var _transitional = require('../defaults/transitional.js');

var _transitional2 = _interopRequireDefault(_transitional);

var _AxiosError = require('../core/AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

var _CanceledError = require('../cancel/CanceledError.js');

var _CanceledError2 = _interopRequireDefault(_CanceledError);

var _parseProtocol = require('../helpers/parseProtocol.js');

var _parseProtocol2 = _interopRequireDefault(_parseProtocol);

var _index = require('../platform/index.js');

var _index2 = _interopRequireDefault(_index);

var _AxiosHeaders = require('../core/AxiosHeaders.js');

var _AxiosHeaders2 = _interopRequireDefault(_AxiosHeaders);

var _speedometer2 = require('../helpers/speedometer.js');

var _speedometer3 = _interopRequireDefault(_speedometer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = (0, _speedometer3.default)(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

exports.default = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = _AxiosHeaders2.default.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (_utils2.default.isFormData(requestData) && (_index2.default.isStandardBrowserEnv || _index2.default.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false); // Let the browser set it
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = (0, _buildFullPath2.default)(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), (0, _buildURL2.default)(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = _AxiosHeaders2.default.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      (0, _settle2.default)(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new _AxiosError2.default('Request aborted', _AxiosError2.default.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _AxiosError2.default('Network Error', _AxiosError2.default.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || _transitional2.default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new _AxiosError2.default(timeoutErrorMessage, transitional.clarifyTimeoutError ? _AxiosError2.default.ETIMEDOUT : _AxiosError2.default.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (_index2.default.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || (0, _isURLSameOrigin2.default)(fullPath)) && config.xsrfCookieName && _cookies2.default.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      _utils2.default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!_utils2.default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _CanceledError2.default(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = (0, _parseProtocol2.default)(fullPath);

    if (protocol && _index2.default.protocols.indexOf(protocol) === -1) {
      reject(new _AxiosError2.default('Unsupported protocol ' + protocol + ':', _AxiosError2.default.ERR_BAD_REQUEST, config));
      return;
    }

    // Send the request
    request.send(requestData || null);
  });
};
},{"./../utils.js":22,"./../core/settle.js":490,"./../helpers/cookies.js":491,"./../helpers/buildURL.js":69,"../core/buildFullPath.js":66,"./../helpers/isURLSameOrigin.js":492,"../defaults/transitional.js":70,"../core/AxiosError.js":33,"../cancel/CanceledError.js":28,"../helpers/parseProtocol.js":493,"../platform/index.js":72,"../core/AxiosHeaders.js":37,"../helpers/speedometer.js":494}],324:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _http = require('./http.js');

var _http2 = _interopRequireDefault(_http);

var _xhr = require('./xhr.js');

var _xhr2 = _interopRequireDefault(_xhr);

var _AxiosError = require('../core/AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const knownAdapters = {
  http: _http2.default,
  xhr: _xhr2.default
};

_utils2.default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', { value });
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', { value });
  }
});

exports.default = {
  getAdapter: adapters => {
    adapters = _utils2.default.isArray(adapters) ? adapters : [adapters];

    const { length } = adapters;
    let nameOrAdapter;
    let adapter;

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if (adapter = _utils2.default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }

    if (!adapter) {
      if (adapter === false) {
        throw new _AxiosError2.default(`Adapter ${nameOrAdapter} is not supported by the environment`, 'ERR_NOT_SUPPORT');
      }

      throw new Error(_utils2.default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
    }

    if (!_utils2.default.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }

    return adapter;
  },
  adapters: knownAdapters
};
},{"../utils.js":22,"./http.js":73,"./xhr.js":456,"../core/AxiosError.js":33}],68:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dispatchRequest;

var _transformData = require('./transformData.js');

var _transformData2 = _interopRequireDefault(_transformData);

var _isCancel = require('../cancel/isCancel.js');

var _isCancel2 = _interopRequireDefault(_isCancel);

var _index = require('../defaults/index.js');

var _index2 = _interopRequireDefault(_index);

var _CanceledError = require('../cancel/CanceledError.js');

var _CanceledError2 = _interopRequireDefault(_CanceledError);

var _AxiosHeaders = require('../core/AxiosHeaders.js');

var _AxiosHeaders2 = _interopRequireDefault(_AxiosHeaders);

var _adapters = require('../adapters/adapters.js');

var _adapters2 = _interopRequireDefault(_adapters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new _CanceledError2.default(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = _AxiosHeaders2.default.from(config.headers);

  // Transform request data
  config.data = _transformData2.default.call(config, config.transformRequest);

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = _adapters2.default.getAdapter(config.adapter || _index2.default.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = _transformData2.default.call(config, config.transformResponse, response);

    response.headers = _AxiosHeaders2.default.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!(0, _isCancel2.default)(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = _transformData2.default.call(config, config.transformResponse, reason.response);
        reason.response.headers = _AxiosHeaders2.default.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}
},{"./transformData.js":323,"../cancel/isCancel.js":30,"../defaults/index.js":27,"../cancel/CanceledError.js":28,"../core/AxiosHeaders.js":37,"../adapters/adapters.js":324}],26:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeConfig;

var _utils = require('../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _AxiosHeaders = require('./AxiosHeaders.js');

var _AxiosHeaders2 = _interopRequireDefault(_AxiosHeaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const headersToObject = thing => thing instanceof _AxiosHeaders2.default ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (_utils2.default.isPlainObject(target) && _utils2.default.isPlainObject(source)) {
      return _utils2.default.merge.call({ caseless }, target, source);
    } else if (_utils2.default.isPlainObject(source)) {
      return _utils2.default.merge({}, source);
    } else if (_utils2.default.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!_utils2.default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!_utils2.default.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utils2.default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utils2.default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utils2.default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  _utils2.default.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    _utils2.default.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });

  return config;
}
},{"../utils.js":22,"./AxiosHeaders.js":37}],31:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const VERSION = exports.VERSION = "1.3.4";
},{}],67:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _data = require('../env/data.js');

var _AxiosError = require('../core/AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _data.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new _AxiosError2.default(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), _AxiosError2.default.ERR_DEPRECATED);
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new _AxiosError2.default('options must be an object', _AxiosError2.default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _AxiosError2.default('option ' + opt + ' must be ' + result, _AxiosError2.default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _AxiosError2.default('Unknown option ' + opt, _AxiosError2.default.ERR_BAD_OPTION);
    }
  }
}

exports.default = {
  assertOptions,
  validators
};
},{"../env/data.js":31,"../core/AxiosError.js":33}],25:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _buildURL = require('../helpers/buildURL.js');

var _buildURL2 = _interopRequireDefault(_buildURL);

var _InterceptorManager = require('./InterceptorManager.js');

var _InterceptorManager2 = _interopRequireDefault(_InterceptorManager);

var _dispatchRequest = require('./dispatchRequest.js');

var _dispatchRequest2 = _interopRequireDefault(_dispatchRequest);

var _mergeConfig = require('./mergeConfig.js');

var _mergeConfig2 = _interopRequireDefault(_mergeConfig);

var _buildFullPath = require('./buildFullPath.js');

var _buildFullPath2 = _interopRequireDefault(_buildFullPath);

var _validator = require('../helpers/validator.js');

var _validator2 = _interopRequireDefault(_validator);

var _AxiosHeaders = require('./AxiosHeaders.js');

var _AxiosHeaders2 = _interopRequireDefault(_AxiosHeaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const validators = _validator2.default.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new _InterceptorManager2.default(),
      response: new _InterceptorManager2.default()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = (0, _mergeConfig2.default)(this.defaults, config);

    const { transitional, paramsSerializer, headers } = config;

    if (transitional !== undefined) {
      _validator2.default.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer !== undefined) {
      _validator2.default.assertOptions(paramsSerializer, {
        encode: validators.function,
        serialize: validators.function
      }, true);
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && _utils2.default.merge(headers.common, headers[config.method]);

    contextHeaders && _utils2.default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
      delete headers[method];
    });

    config.headers = _AxiosHeaders2.default.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [_dispatchRequest2.default.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = _dispatchRequest2.default.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = (0, _mergeConfig2.default)(this.defaults, config);
    const fullPath = (0, _buildFullPath2.default)(config.baseURL, config.url);
    return (0, _buildURL2.default)(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
_utils2.default.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request((0, _mergeConfig2.default)(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

_utils2.default.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request((0, _mergeConfig2.default)(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

exports.default = Axios;
},{"./../utils.js":22,"../helpers/buildURL.js":69,"./InterceptorManager.js":65,"./dispatchRequest.js":68,"./mergeConfig.js":26,"./buildFullPath.js":66,"../helpers/validator.js":67,"./AxiosHeaders.js":37}],29:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CanceledError = require('./CanceledError.js');

var _CanceledError2 = _interopRequireDefault(_CanceledError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new _CanceledError2.default(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

exports.default = CancelToken;
},{"./CanceledError.js":28}],36:[function(require,module,exports) {
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = spread;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
},{}],35:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isAxiosError;

var _utils = require('./../utils.js');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return _utils2.default.isObject(payload) && payload.isAxiosError === true;
}
},{"./../utils.js":22}],38:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

exports.default = HttpStatusCode;
},{}],21:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./utils.js');

var _utils2 = _interopRequireDefault(_utils);

var _bind = require('./helpers/bind.js');

var _bind2 = _interopRequireDefault(_bind);

var _Axios = require('./core/Axios.js');

var _Axios2 = _interopRequireDefault(_Axios);

var _mergeConfig = require('./core/mergeConfig.js');

var _mergeConfig2 = _interopRequireDefault(_mergeConfig);

var _index = require('./defaults/index.js');

var _index2 = _interopRequireDefault(_index);

var _formDataToJSON = require('./helpers/formDataToJSON.js');

var _formDataToJSON2 = _interopRequireDefault(_formDataToJSON);

var _CanceledError = require('./cancel/CanceledError.js');

var _CanceledError2 = _interopRequireDefault(_CanceledError);

var _CancelToken = require('./cancel/CancelToken.js');

var _CancelToken2 = _interopRequireDefault(_CancelToken);

var _isCancel = require('./cancel/isCancel.js');

var _isCancel2 = _interopRequireDefault(_isCancel);

var _data = require('./env/data.js');

var _toFormData = require('./helpers/toFormData.js');

var _toFormData2 = _interopRequireDefault(_toFormData);

var _AxiosError = require('./core/AxiosError.js');

var _AxiosError2 = _interopRequireDefault(_AxiosError);

var _spread = require('./helpers/spread.js');

var _spread2 = _interopRequireDefault(_spread);

var _isAxiosError = require('./helpers/isAxiosError.js');

var _isAxiosError2 = _interopRequireDefault(_isAxiosError);

var _AxiosHeaders = require('./core/AxiosHeaders.js');

var _AxiosHeaders2 = _interopRequireDefault(_AxiosHeaders);

var _HttpStatusCode = require('./helpers/HttpStatusCode.js');

var _HttpStatusCode2 = _interopRequireDefault(_HttpStatusCode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new _Axios2.default(defaultConfig);
  const instance = (0, _bind2.default)(_Axios2.default.prototype.request, context);

  // Copy axios.prototype to instance
  _utils2.default.extend(instance, _Axios2.default.prototype, context, { allOwnKeys: true });

  // Copy context to instance
  _utils2.default.extend(instance, context, null, { allOwnKeys: true });

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance((0, _mergeConfig2.default)(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(_index2.default);

// Expose Axios class to allow class inheritance
axios.Axios = _Axios2.default;

// Expose Cancel & CancelToken
axios.CanceledError = _CanceledError2.default;
axios.CancelToken = _CancelToken2.default;
axios.isCancel = _isCancel2.default;
axios.VERSION = _data.VERSION;
axios.toFormData = _toFormData2.default;

// Expose AxiosError class
axios.AxiosError = _AxiosError2.default;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = _spread2.default;

// Expose isAxiosError
axios.isAxiosError = _isAxiosError2.default;

// Expose mergeConfig
axios.mergeConfig = _mergeConfig2.default;

axios.AxiosHeaders = _AxiosHeaders2.default;

axios.formToJSON = thing => (0, _formDataToJSON2.default)(_utils2.default.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.HttpStatusCode = _HttpStatusCode2.default;

axios.default = axios;

// this module should only have a default export
exports.default = axios;
},{"./utils.js":22,"./helpers/bind.js":24,"./core/Axios.js":25,"./core/mergeConfig.js":26,"./defaults/index.js":27,"./helpers/formDataToJSON.js":34,"./cancel/CanceledError.js":28,"./cancel/CancelToken.js":29,"./cancel/isCancel.js":30,"./env/data.js":31,"./helpers/toFormData.js":32,"./core/AxiosError.js":33,"./helpers/spread.js":36,"./helpers/isAxiosError.js":35,"./core/AxiosHeaders.js":37,"./helpers/HttpStatusCode.js":38}],16:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeConfig = exports.formToJSON = exports.HttpStatusCode = exports.AxiosHeaders = exports.toFormData = exports.spread = exports.isAxiosError = exports.Cancel = exports.all = exports.VERSION = exports.CancelToken = exports.isCancel = exports.CanceledError = exports.AxiosError = exports.Axios = exports.default = undefined;

var _axios = require('./lib/axios.js');

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const {
  Axios,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken,
  VERSION,
  all,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders,
  HttpStatusCode,
  formToJSON,
  mergeConfig
} = _axios2.default;

exports.default = _axios2.default;
exports.Axios = Axios;
exports.AxiosError = AxiosError;
exports.CanceledError = CanceledError;
exports.isCancel = isCancel;
exports.CancelToken = CancelToken;
exports.VERSION = VERSION;
exports.all = all;
exports.Cancel = Cancel;
exports.isAxiosError = isAxiosError;
exports.spread = spread;
exports.toFormData = toFormData;
exports.AxiosHeaders = AxiosHeaders;
exports.HttpStatusCode = HttpStatusCode;
exports.formToJSON = formToJSON;
exports.mergeConfig = mergeConfig;
},{"./lib/axios.js":21}],15:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Alert box design by Igor FerrÃ£o de Souza: https://www.linkedin.com/in/igor-ferr%C3%A3o-de-souza-4122407b/
/*eslint-disable */
var cuteAlert = exports.cuteAlert = function cuteAlert(_ref) {
  var url = _ref.url,
      type = _ref.type,
      title = _ref.title,
      message = _ref.message,
      img = _ref.img,
      _ref$buttonText = _ref.buttonText,
      buttonText = _ref$buttonText === undefined ? 'OK' : _ref$buttonText,
      _ref$confirmText = _ref.confirmText,
      confirmText = _ref$confirmText === undefined ? 'OK' : _ref$confirmText,
      _ref$vibrate = _ref.vibrate,
      vibrate = _ref$vibrate === undefined ? [] : _ref$vibrate,
      _ref$playSound = _ref.playSound,
      playSound = _ref$playSound === undefined ? null : _ref$playSound,
      _ref$cancelText = _ref.cancelText,
      cancelText = _ref$cancelText === undefined ? 'Cancel' : _ref$cancelText,
      closeStyle = _ref.closeStyle;

  return new Promise(function (resolve) {
    var existingAlert = document.querySelector('.alert-wrapper');

    if (existingAlert) {
      existingAlert.remove();
    }

    var body = document.querySelector('body');

    var scripts = document.getElementsByTagName('script');

    var src = '';

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = scripts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var script = _step.value;

        if (script.src.includes('cute-alert.js')) {
          src = script.src.substring(0, script.src.lastIndexOf('/'));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var btnTemplate = '\n    <button class="alert-button ' + type + '-bg ' + type + '-btn">' + buttonText + '</button>\n    ';

    if (type === 'question') {
      btnTemplate = '\n      <div class="question-buttons">\n        <button class="confirm-button ' + type + '-bg ' + type + '-btn">' + confirmText + '</button>\n        <button class="cancel-button error-bg error-btn">' + cancelText + '</button>\n      </div>\n      ';
    }

    if (vibrate.length > 0) {
      navigator.vibrate(vibrate);
    }

    if (playSound !== null) {
      var sound = new Audio(playSound);
      sound.play();
    }

    var template = '\n    <div class="alert-wrapper">\n      <div class="alert-frame">\n        ' + (img === undefined ? '<div class="alert-header ' + type + '-bg">' : '<div class="alert-header-base">') + '\n          <span class="alert-close ' + (closeStyle === 'circle' ? 'alert-close-circle' : 'alert-close-default') + '">X</span>\n          ' + (img === undefined ? '<img class="alert-img" src="' + src + '/img/' + type + '.svg' + '" />' : '<div class="custom-img-wrapper">' + img + '</div>') + '\n        </div>\n        <div class="alert-body">\n          <span class="alert-title">' + title + '</span>\n          <span class="alert-message">' + message + '</span>\n          ' + btnTemplate + '\n        </div>\n      </div>\n    </div>\n    ';

    body.insertAdjacentHTML('afterend', template);

    var alertWrapper = document.querySelector('.alert-wrapper');
    var alertFrame = document.querySelector('.alert-frame');
    var alertClose = document.querySelector('.alert-close');

    if (type === 'question') {
      var confirmButton = document.querySelector('.confirm-button');
      var cancelButton = document.querySelector('.cancel-button');

      confirmButton.addEventListener('click', function () {
        alertWrapper.remove();
        resolve('confirm');
      });

      cancelButton.addEventListener('click', function () {
        alertWrapper.remove();
        resolve();
      });
    } else {
      var alertButton = document.querySelector('.alert-button');

      alertButton.addEventListener('click', function () {
        alertWrapper.remove();
        resolve('ok');
      });
    }

    alertClose.addEventListener('click', function () {
      alertWrapper.remove();
      resolve('close');
    });

    /*     alertWrapper.addEventListener('click', () => {
      alertWrapper.remove();
      resolve();
    }); */

    alertFrame.addEventListener('click', function (e) {
      e.stopPropagation();
    });
  });
};

var cuteToast = exports.cuteToast = function cuteToast(_ref2) {
  var type = _ref2.type,
      title = _ref2.title,
      message = _ref2.message,
      _ref2$timer = _ref2.timer,
      timer = _ref2$timer === undefined ? 5000 : _ref2$timer,
      _ref2$vibrate = _ref2.vibrate,
      vibrate = _ref2$vibrate === undefined ? [] : _ref2$vibrate,
      _ref2$playSound = _ref2.playSound,
      playSound = _ref2$playSound === undefined ? null : _ref2$playSound;

  return new Promise(function (resolve) {
    var body = document.querySelector('body');

    var scripts = document.getElementsByTagName('script');

    var src = '/js/cute';

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = scripts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var script = _step2.value;

        if (script.src.includes('cute-alert.js')) {
          src = script.src.substring(0, script.src.lastIndexOf('/'));
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var templateContainer = document.querySelector('.toast-container');

    if (!templateContainer) {
      body.insertAdjacentHTML('afterend', '<div class="toast-container"></div>');
      templateContainer = document.querySelector('.toast-container');
    }

    var toastId = id();

    var templateContent = '\n    <div class="toast-content ' + type + '-bg" id="' + toastId + '-toast-content">\n      <div>\n        <div class="toast-frame">\n          <div class="toast-body">\n            <img class="toast-body-img" src="' + src + '/img/' + type + '.svg" />\'\n            <div class="toast-body-content">\n              <span class="toast-title">' + title + '</span>\n              <span class="toast-message">' + message + '</span>\n            </div>\n            <div class="toast-close" id="' + toastId + '-toast-close">X</div>\n          </div>\n        </div>\n        <div class="toast-timer ' + type + '-timer"  style="animation: timer' + timer + 'ms linear;>\n      </div>\n    </div>\n    ';

    var toasts = document.querySelectorAll('.toast-content');

    if (toasts.length) {
      toasts[0].insertAdjacentHTML('beforebegin', templateContent);
    } else {
      templateContainer.innerHTML = templateContent;
    }

    var toastContent = document.getElementById(toastId + '-toast-content');

    if (vibrate.length > 0) {
      navigator.vibrate(vibrate);
    }

    if (playSound !== null) {
      var sound = new Audio(playSound);
      sound.play();
    }

    setTimeout(function () {
      toastContent.remove();
      resolve();
    }, timer);

    var toastClose = document.getElementById(toastId + '-toast-close');

    toastClose.addEventListener('click', function () {
      toastContent.remove();
      resolve();
    });
  });
};

var id = function id() {
  return '_' + Math.random().toString(36).substr(2, 9);
};

// if (url) {
//   var toastTypes = ['success', 'error', 'warning', 'info', 'question'];
//   var src = [
//     'https://svgshare.com/i/jVz.svg',
//     'https://svgshare.com/i/jUv.svg',
//     'https://svgshare.com/i/jW0.svg',
//     'https://svgshare.com/i/jWA.svg',
//     'https://svgshare.com/i/jUw.svg',
//   ];
//   for (
//     var i = 0;
//     i < document.getElementsByClassName('alert-img').length;
//     i++
//   ) {
//     for (var j = 0; j < toastTypes.length; j++) {
//       if (
//         document
//           .getElementsByClassName('alert-img')
//           [i].parentElement.classList.contains(toastTypes[j] + '-bg')
//       ) {
//         document.getElementsByClassName('alert-img')[i].src = src[j];
//       }
//     }
//   }
// }
},{}],4:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetPassword = exports.forgotPassword = exports.signup = exports.logout = exports.login = undefined;
var _this = undefined;

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _cuteAlert = require('./cute/cute-alert');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* eslint-disable*/


var login = exports.login = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(body) {
    var res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return (0, _axios2.default)({
              method: 'POST',
              url: '/api/v1/users/login',
              data: body
            });

          case 3:
            res = _context.sent;

            if (res.data.status === 'success') {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'Congratulation yor are logged in',
                timer: 1500
              }).then(function () {
                location.assign('/');
              });
            }
            _context.next = 10;
            break;

          case 7:
            _context.prev = 7;
            _context.t0 = _context['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context.t0.response.data.message,
              timer: 2500
            });

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this, [[0, 7]]);
  }));

  return function login(_x) {
    return _ref.apply(this, arguments);
  };
}();

var logout = exports.logout = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    var res;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return _axios2.default.post('/api/v1/users/logout');

          case 2:
            res = _context2.sent;

            if (res.data.status === 'success') (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Logged out',
              message: 'You are logged out',
              timer: 1500
            }).then(function () {
              return location.assign('/');
            });

          case 4:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, _this);
  }));

  return function logout() {
    return _ref2.apply(this, arguments);
  };
}();

var signup = exports.signup = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(body) {
    var res;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return (0, _axios2.default)({
              method: 'POST',
              url: '/api/v1/users/signup',
              data: body
            });

          case 3:
            res = _context3.sent;

            if (res.data.status === 'success') {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'Congratulation you are one of our users now',
                timer: 1500
              }).then(function () {
                location.assign('/');
              });
            }
            _context3.next = 10;
            break;

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context3.t0.response.data.message,
              timer: 2500
            });

          case 10:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, _this, [[0, 7]]);
  }));

  return function signup(_x2) {
    return _ref3.apply(this, arguments);
  };
}();

var forgotPassword = exports.forgotPassword = function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(body) {
    var res;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return (0, _axios2.default)({
              method: 'POST',
              url: '/api/v1/users/forgotPassword',
              data: body
            });

          case 3:
            res = _context4.sent;

            if (res.data.status === 'success') {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'We send a reset token to your email',
                timer: 1500
              });
            }
            _context4.next = 10;
            break;

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context4.t0.response.data.message,
              timer: 2500
            });

          case 10:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, _this, [[0, 7]]);
  }));

  return function forgotPassword(_x3) {
    return _ref4.apply(this, arguments);
  };
}();

var resetPassword = exports.resetPassword = function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(password, passwordConfirm, resetToken) {
    var res;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return (0, _axios2.default)({
              method: 'PATCH',
              url: '/api/v1/users/resetPassword/' + resetToken,
              data: { password: password, passwordConfirm: passwordConfirm }
            });

          case 3:
            res = _context5.sent;

            if (res.data.status === 'success') {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'Your password has been reset',
                timer: 1500
              }).then(function () {
                location.assign('/');
              });
            }
            _context5.next = 10;
            break;

          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context5.t0.response.data.message,
              timer: 2500
            });

          case 10:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, _this, [[0, 7]]);
  }));

  return function resetPassword(_x4, _x5, _x6) {
    return _ref5.apply(this, arguments);
  };
}();
},{"axios":16,"./cute/cute-alert":15}],17:[function(require,module,exports) {
var define;
var global = arguments[3];
/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());
})(this, function () {
    'use strict';

    /* eslint-disable */

    var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) {
            shared = chunk;
        } else if (!worker) {
            worker = chunk;
        } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";

            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
                mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
            }
        }
    }

    define(["exports"], function (t) {
        "use strict";
        var e = "undefined" != typeof self ? self : {},
            r = "2.13.0";let n;const i = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
                if (null == n) {
                    const t = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;try {
                        n = null != undefined ? new RegExp(undefined) : t;
                    } catch (e) {
                        n = t;
                    }
                }return n;
            }, get API_TILEJSON_REGEX() {
                return (/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i
                );
            }, get API_SPRITE_REGEX() {
                return (/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i
                );
            }, get API_FONTS_REGEX() {
                return (/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i
                );
            }, get API_STYLE_REGEX() {
                return (/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i
                );
            }, get API_CDN_URL_REGEX() {
                return (/^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i
                );
            }, get EVENTS_URL() {
                return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
            }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 },
              s = { supported: !1, testSupport: function (t) {
                !l && o && (u ? c(t) : a = t);
            } };let a,
            o,
            l = !1,
            u = !1;function c(t) {
            const e = t.createTexture();t.bindTexture(t.TEXTURE_2D, e);try {
                if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, o), t.isContextLost()) return;s.supported = !0;
            } catch (t) {}t.deleteTexture(e), l = !0;
        }e.document && (o = e.document.createElement("img"), o.onload = function () {
            a && c(a), a = null, u = !0;
        }, o.onerror = function () {
            l = !0, a = null;
        }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");const h = "01";var p = f;function f(t, e, r, n) {
            this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n;
        }f.prototype = { sampleCurveX: function (t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t;
            }, sampleCurveY: function (t) {
                return ((this.ay * t + this.by) * t + this.cy) * t;
            }, sampleCurveDerivativeX: function (t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
            }, solveCurveX: function (t, e) {
                if (void 0 === e && (e = 1e-6), t < 0) return 0;if (t > 1) return 1;for (var r = t, n = 0; n < 8; n++) {
                    var i = this.sampleCurveX(r) - t;if (Math.abs(i) < e) return r;var s = this.sampleCurveDerivativeX(r);if (Math.abs(s) < 1e-6) break;r -= i / s;
                }var a = 0,
                    o = 1;for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++) t > i ? a = r : o = r, r = .5 * (o - a) + a;return r;
            }, solve: function (t, e) {
                return this.sampleCurveY(this.solveCurveX(t, e));
            } };var d = y;function y(t, e) {
            this.x = t, this.y = e;
        }y.prototype = { clone: function () {
                return new y(this.x, this.y);
            }, add: function (t) {
                return this.clone()._add(t);
            }, sub: function (t) {
                return this.clone()._sub(t);
            }, multByPoint: function (t) {
                return this.clone()._multByPoint(t);
            }, divByPoint: function (t) {
                return this.clone()._divByPoint(t);
            }, mult: function (t) {
                return this.clone()._mult(t);
            }, div: function (t) {
                return this.clone()._div(t);
            }, rotate: function (t) {
                return this.clone()._rotate(t);
            }, rotateAround: function (t, e) {
                return this.clone()._rotateAround(t, e);
            }, matMult: function (t) {
                return this.clone()._matMult(t);
            }, unit: function () {
                return this.clone()._unit();
            }, perp: function () {
                return this.clone()._perp();
            }, round: function () {
                return this.clone()._round();
            }, mag: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }, equals: function (t) {
                return this.x === t.x && this.y === t.y;
            }, dist: function (t) {
                return Math.sqrt(this.distSqr(t));
            }, distSqr: function (t) {
                var e = t.x - this.x,
                    r = t.y - this.y;return e * e + r * r;
            }, angle: function () {
                return Math.atan2(this.y, this.x);
            }, angleTo: function (t) {
                return Math.atan2(this.y - t.y, this.x - t.x);
            }, angleWith: function (t) {
                return this.angleWithSep(t.x, t.y);
            }, angleWithSep: function (t, e) {
                return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
            }, _matMult: function (t) {
                var e = t[2] * this.x + t[3] * this.y;return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;
            }, _add: function (t) {
                return this.x += t.x, this.y += t.y, this;
            }, _sub: function (t) {
                return this.x -= t.x, this.y -= t.y, this;
            }, _mult: function (t) {
                return this.x *= t, this.y *= t, this;
            }, _div: function (t) {
                return this.x /= t, this.y /= t, this;
            }, _multByPoint: function (t) {
                return this.x *= t.x, this.y *= t.y, this;
            }, _divByPoint: function (t) {
                return this.x /= t.x, this.y /= t.y, this;
            }, _unit: function () {
                return this._div(this.mag()), this;
            }, _perp: function () {
                var t = this.y;return this.y = this.x, this.x = -t, this;
            }, _rotate: function (t) {
                var e = Math.cos(t),
                    r = Math.sin(t),
                    n = r * this.x + e * this.y;return this.x = e * this.x - r * this.y, this.y = n, this;
            }, _rotateAround: function (t, e) {
                var r = Math.cos(t),
                    n = Math.sin(t),
                    i = e.y + n * (this.x - e.x) + r * (this.y - e.y);return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;
            }, _round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            } }, y.convert = function (t) {
            return t instanceof y ? t : Array.isArray(t) ? new y(t[0], t[1]) : t;
        };const m = Math.PI / 180,
              g = 180 / Math.PI;function x(t) {
            return t * m;
        }function v(t) {
            return t * g;
        }const b = [[0, 0], [1, 0], [1, 1], [0, 1]];function w(t) {
            if (t <= 0) return 0;if (t >= 1) return 1;const e = t * t,
                  r = e * t;return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);
        }function _(t, e, r, n) {
            const i = new p(t, e, r, n);return function (t) {
                return i.solve(t);
            };
        }const A = _(.25, .1, .25, 1);function S(t, e, r) {
            return Math.min(r, Math.max(e, t));
        }function k(t, e, r) {
            return (r = S((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);
        }function I(t, e, r) {
            const n = r - e,
                  i = ((t - e) % n + n) % n + e;return i === e ? r : i;
        }function M(t, e, r) {
            if (!t.length) return r(null, []);let n = t.length;const i = new Array(t.length);let s = null;t.forEach((t, a) => {
                e(t, (t, e) => {
                    t && (s = t), i[a] = e, 0 == --n && r(s, i);
                });
            });
        }function T(t) {
            const e = [];for (const r in t) e.push(t[r]);return e;
        }function z(t, ...e) {
            for (const r of e) for (const e in r) t[e] = r[e];return t;
        }let B = 1;function E() {
            return B++;
        }function C() {
            return function t(e) {
                return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);
            }();
        }function P(t) {
            return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        }function D(t) {
            return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);
        }function V(t, e) {
            t.forEach(t => {
                e[t] && (e[t] = e[t].bind(e));
            });
        }function L(t, e) {
            return -1 !== t.indexOf(e, t.length - e.length);
        }function F(t, e, r) {
            const n = {};for (const i in t) n[i] = e.call(r || this, t[i], i, t);return n;
        }function R(t, e, r) {
            const n = {};for (const i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);return n;
        }function j(t) {
            return Array.isArray(t) ? t.map(j) : "object" == typeof t && t ? F(t, j) : t;
        }const U = {};function $(t) {
            U[t] || ("undefined" != typeof console && console.warn(t), U[t] = !0);
        }function O(t, e, r) {
            return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);
        }function q(t) {
            let e = 0;for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);return e;
        }function N() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }function G(t) {
            const e = {};if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t, r, n, i) => {
                const s = n || i;return e[r] = !s || s.toLowerCase(), "";
            }), e["max-age"]) {
                const t = parseInt(e["max-age"], 10);isNaN(t) ? delete e["max-age"] : e["max-age"] = t;
            }return e;
        }let X = null;function Z(t) {
            if (null == X) {
                const e = t.navigator ? t.navigator.userAgent : null;X = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
            }return X;
        }function K(t) {
            try {
                const r = e[t];return r.setItem("_mapbox_test_", 1), r.removeItem("_mapbox_test_"), !0;
            } catch (t) {
                return !1;
            }
        }function Y(t, e) {
            return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];
        }const H = "mapbox-tiles";let W,
            J,
            Q = 500,
            tt = 50;function et() {
            try {
                return e.caches;
            } catch (t) {}
        }function rt() {
            et() && !W && (W = e.caches.open(H));
        }function nt(t) {
            const e = t.indexOf("?");if (e < 0) return t;const r = function (t) {
                const e = t.indexOf("?");return e > 0 ? t.slice(e + 1).split("&") : [];
            }(t),
                  n = r.filter(t => {
                const e = t.split("=");return "language" === e[0] || "worldview" === e[0];
            });return n.length ? `${t.slice(0, e)}?${n.join("&")}` : t.slice(0, e);
        }let it = 1 / 0;const st = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };"function" == typeof Object.freeze && Object.freeze(st);class at extends Error {
            constructor(t, e, r) {
                401 === e && gt(r) && (t += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t), this.status = e, this.url = r;
            }toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }const ot = N() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href;const lt = function (t, r) {
            if (!(/^file:/.test(n = t.url) || /^file:/.test(ot()) && !/^\w+:/.test(n))) {
                if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal")) return function (t, r) {
                    const n = new e.AbortController(),
                          i = new e.Request(t.url, { method: t.method || "GET", body: t.body, credentials: t.credentials, headers: t.headers, referrer: ot(), signal: n.signal });let s = !1,
                        a = !1;const o = (l = i.url).indexOf("sku=") > 0 && gt(l);var l;"json" === t.type && i.headers.set("Accept", "application/json");const u = (n, s, l) => {
                        if (a) return;if (n && "SecurityError" !== n.message && $(n), s && l) return c(s);const u = Date.now();e.fetch(i).then(e => {
                            if (e.ok) {
                                const t = o ? e.clone() : null;return c(e, t, u);
                            }return r(new at(e.statusText, e.status, t.url));
                        }).catch(e => {
                            "AbortError" !== e.name && r(new Error(`${e.message} ${t.url}`));
                        });
                    },
                          c = (n, o, l) => {
                        ("arrayBuffer" === t.type ? n.arrayBuffer() : "json" === t.type ? n.json() : n.text()).then(t => {
                            a || (o && l && function (t, r, n) {
                                if (rt(), !W) return;const i = { status: r.status, statusText: r.statusText, headers: new e.Headers() };r.headers.forEach((t, e) => i.headers.set(e, t));const s = G(r.headers.get("Cache-Control") || "");if (s["no-store"]) return;s["max-age"] && i.headers.set("Expires", new Date(n + 1e3 * s["max-age"]).toUTCString());const a = i.headers.get("Expires");a && (new Date(a).getTime() - n < 42e4 || function (t, e) {
                                    if (void 0 === J) try {
                                        new Response(new ReadableStream()), J = !0;
                                    } catch (t) {
                                        J = !1;
                                    }J ? e(t.body) : t.blob().then(e);
                                }(r, r => {
                                    const n = new e.Response(r, i);rt(), W && W.then(e => e.put(nt(t.url), n)).catch(t => $(t.message));
                                }));
                            }(i, o, l), s = !0, r(null, t, n.headers.get("Cache-Control"), n.headers.get("Expires")));
                        }).catch(t => {
                            a || r(new Error(t.message));
                        });
                    };return o ? function (t, e) {
                        if (rt(), !W) return e(null);const r = nt(t.url);W.then(t => {
                            t.match(r).then(n => {
                                const i = function (t) {
                                    if (!t) return !1;const e = new Date(t.headers.get("Expires") || 0),
                                          r = G(t.headers.get("Cache-Control") || "");return e > Date.now() && !r["no-cache"];
                                }(n);t.delete(r), i && t.put(r, n.clone()), e(null, n, i);
                            }).catch(e);
                        }).catch(e);
                    }(i, u) : u(null, null), { cancel: () => {
                            a = !0, s || n.abort();
                        } };
                }(t, r);if (N() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, r, void 0, !0);
            }var n;return function (t, r) {
                const n = new e.XMLHttpRequest();n.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (n.responseType = "arraybuffer");for (const e in t.headers) n.setRequestHeader(e, t.headers[e]);return "json" === t.type && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = "include" === t.credentials, n.onerror = () => {
                    r(new Error(n.statusText));
                }, n.onload = () => {
                    if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {
                        let e = n.response;if ("json" === t.type) try {
                            e = JSON.parse(n.response);
                        } catch (t) {
                            return r(t);
                        }r(null, e, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires"));
                    } else r(new at(n.statusText, n.status, t.url));
                }, n.send(t.body), { cancel: () => n.abort() };
            }(t, r);
        },
              ut = function (t, e) {
            return lt(z(t, { type: "arrayBuffer" }), e);
        };function ct(t) {
            const r = e.document.createElement("a");return r.href = t, r.protocol === e.document.location.protocol && r.host === e.document.location.host;
        }const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";let pt, ft;pt = [], ft = 0;const dt = function (t, r) {
            if (s.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), ft >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
                const e = { requestParameters: t, callback: r, cancelled: !1, cancel() {
                        this.cancelled = !0;
                    } };return pt.push(e), e;
            }ft++;let n = !1;const a = () => {
                if (!n) for (n = !0, ft--; pt.length && ft < i.MAX_PARALLEL_IMAGE_REQUESTS;) {
                    const t = pt.shift(),
                          { requestParameters: e, callback: r, cancelled: n } = t;n || (t.cancel = dt(e, r).cancel);
                }
            },
                  o = ut(t, (t, n, i, s) => {
                a(), t ? r(t) : n && (e.createImageBitmap ? function (t, r) {
                    const n = new e.Blob([new Uint8Array(t)], { type: "image/png" });e.createImageBitmap(n).then(t => {
                        r(null, t);
                    }).catch(t => {
                        r(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                }(n, (t, e) => r(t, e, i, s)) : function (t, r) {
                    const n = new e.Image(),
                          i = e.URL;n.onload = () => {
                        r(null, n), i.revokeObjectURL(n.src), n.onload = null, e.requestAnimationFrame(() => {
                            n.src = ht;
                        });
                    }, n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));const s = new e.Blob([new Uint8Array(t)], { type: "image/png" });n.src = t.byteLength ? i.createObjectURL(s) : ht;
                }(n, (t, e) => r(t, e, i, s)));
            });return { cancel: () => {
                    o.cancel(), a();
                } };
        },
              yt = "NO_ACCESS_TOKEN";function mt(t) {
            return 0 === t.indexOf("mapbox:");
        }function gt(t) {
            return i.API_URL_REGEX.test(t);
        }function xt(t) {
            return i.API_CDN_URL_REGEX.test(t);
        }function vt(t) {
            return i.API_STYLE_REGEX.test(t) && !bt(t);
        }function bt(t) {
            return i.API_SPRITE_REGEX.test(t);
        }const wt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;function _t(t) {
            const e = t.match(wt);if (!e) throw new Error("Unable to parse URL object");return { protocol: e[1], authority: e[2], path: e[3] || "/", params: e[4] ? e[4].split("&") : [] };
        }function At(t) {
            const e = t.params.length ? `?${t.params.join("&")}` : "";return `${t.protocol}://${t.authority}${t.path}${e}`;
        }function St(t) {
            if (!t) return null;const r = t.split(".");if (!r || 3 !== r.length) return null;try {
                return JSON.parse(decodeURIComponent(e.atob(r[1]).split("").map(t => "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2)).join("")));
            } catch (t) {
                return null;
            }
        }class kt {
            constructor(t) {
                this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }getStorageKey(t) {
                const r = St(i.ACCESS_TOKEN);let n = "";return n = r && r.u ? e.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number("0x" + e)))) : i.ACCESS_TOKEN || "", t ? `mapbox.eventData.${t}:${n}` : `mapbox.eventData:${n}`;
            }fetchEventData() {
                const t = K("localStorage"),
                      r = this.getStorageKey(),
                      n = this.getStorageKey("uuid");if (t) try {
                    const t = e.localStorage.getItem(r);t && (this.eventData = JSON.parse(t));const i = e.localStorage.getItem(n);i && (this.anonId = i);
                } catch (t) {
                    $("Unable to read from LocalStorage");
                }
            }saveEventData() {
                const t = K("localStorage"),
                      r = this.getStorageKey(),
                      n = this.getStorageKey("uuid");if (t) try {
                    e.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r, JSON.stringify(this.eventData));
                } catch (t) {
                    $("Unable to write to LocalStorage");
                }
            }processRequests(t) {}postEvent(t, e, r, n) {
                if (!i.EVENTS_URL) return;const s = _t(i.EVENTS_URL);s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);const a = { event: this.type, created: new Date(t).toISOString() },
                      o = e ? z(a, e) : a,
                      l = { url: At(s), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o]) };this.pendingRequest = function (t, e) {
                    return lt(z(t, { method: "POST" }), e);
                }(l, t => {
                    this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);
                });
            }queueRequest(t, e) {
                this.queue.push(t), this.processRequests(e);
            }
        }const It = new class extends kt {
            constructor(t) {
                super("appUserTurnstile"), this._customAccessToken = t;
            }postTurnstileEvent(t, e) {
                i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t) && t.some(t => mt(t) || gt(t)) && this.queueRequest(Date.now(), e);
            }processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();const e = St(i.ACCESS_TOKEN),
                      n = e ? e.u : i.ACCESS_TOKEN;let s = n !== this.eventData.tokenU;D(this.anonId) || (this.anonId = C(), s = !0);const a = this.queue.shift();if (this.eventData.lastSuccess) {
                    const t = new Date(this.eventData.lastSuccess),
                          e = new Date(a),
                          r = (a - this.eventData.lastSuccess) / 864e5;s = s || r >= 1 || r < -1 || t.getDate() !== e.getDate();
                } else s = !0;s ? this.postEvent(a, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h, "enabled.telemetry": !1, userId: this.anonId }, t => {
                    t || (this.eventData.lastSuccess = a, this.eventData.tokenU = n);
                }, t) : this.processRequests();
            }
        }(),
              Mt = It.postTurnstileEvent.bind(It),
              Tt = new class extends kt {
            constructor() {
                super("map.load"), this.success = {}, this.skuToken = "";
            }postMapLoadEvent(t, e, r, n) {
                this.skuToken = e, this.errorCb = n, i.EVENTS_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({ id: t, timestamp: Date.now() }, r) : this.errorCb(new Error(yt)));
            }processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;const { id: e, timestamp: n } = this.queue.shift();e && this.success[e] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h, skuToken: this.skuToken, userId: this.anonId }, t => {
                    t ? this.errorCb(t) : e && (this.success[e] = !0);
                }, t));
            }
        }(),
              zt = Tt.postMapLoadEvent.bind(Tt),
              Bt = new class extends kt {
            constructor() {
                super("gljs.performance");
            }postPerformanceEvent(t, e) {
                i.EVENTS_URL && (t || i.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e }, t);
            }processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;const { timestamp: n, performanceData: i } = this.queue.shift(),
                      s = function (t) {
                    const n = e.performance.getEntriesByType("resource"),
                          i = e.performance.getEntriesByType("mark"),
                          s = function (t) {
                        const e = {};if (t) for (const r in t) if ("other" !== r) for (const n of t[r]) {
                            const t = `${r}ResolveRangeMin`,
                                  i = `${r}ResolveRangeMax`,
                                  s = `${r}RequestCount`,
                                  a = `${r}RequestCachedCount`;e[t] = Math.min(e[t] || 1 / 0, n.startTime), e[i] = Math.max(e[i] || -1 / 0, n.responseEnd);const o = t => {
                                void 0 === e[t] && (e[t] = 0), ++e[t];
                            };void 0 !== n.transferSize && 0 === n.transferSize && o(a), o(s);
                        }return e;
                    }(function (t, e) {
                        const r = {};if (t) for (const n of t) {
                            const t = e(n);void 0 === r[t] && (r[t] = []), r[t].push(n);
                        }return r;
                    }(n, Ft)),
                          a = e.devicePixelRatio,
                          o = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection,
                          l = { counters: [], metadata: [], attributes: [] },
                          u = (t, e, r) => {
                        null != r && t.push({ name: e, value: r.toString() });
                    };for (const t in s) u(l.counters, t, s[t]);if (t.interactionRange[0] !== 1 / 0 && t.interactionRange[1] !== -1 / 0 && (u(l.counters, "interactionRangeMin", t.interactionRange[0]), u(l.counters, "interactionRangeMax", t.interactionRange[1])), i) for (const t of Object.keys(Vt)) {
                        const e = Vt[t],
                              r = i.find(t => t.name === e);r && u(l.counters, e, r.startTime);
                    }return u(l.counters, "visibilityHidden", t.visibilityHidden), u(l.attributes, "style", function (t) {
                        if (t) for (const e of t) {
                            const t = e.name.split("?")[0];if (vt(t)) {
                                const e = t.split("/").slice(-2);if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;
                            }
                        }
                    }(n)), u(l.attributes, "terrainEnabled", t.terrainEnabled ? "true" : "false"), u(l.attributes, "fogEnabled", t.fogEnabled ? "true" : "false"), u(l.attributes, "projection", t.projection), u(l.attributes, "zoom", t.zoom), u(l.metadata, "devicePixelRatio", a), u(l.metadata, "connectionEffectiveType", o ? o.effectiveType : void 0), u(l.metadata, "navigatorUserAgent", e.navigator.userAgent), u(l.metadata, "screenWidth", e.screen.width), u(l.metadata, "screenHeight", e.screen.height), u(l.metadata, "windowWidth", e.innerWidth), u(l.metadata, "windowHeight", e.innerHeight), u(l.metadata, "mapWidth", t.width / a), u(l.metadata, "mapHeight", t.height / a), u(l.metadata, "webglRenderer", t.renderer), u(l.metadata, "webglVendor", t.vendor), u(l.metadata, "sdkVersion", r), u(l.metadata, "sdkIdentifier", "mapbox-gl-js"), l;
                }(i);for (const t of s.metadata);for (const t of s.counters);for (const t of s.attributes);this.postEvent(n, s, () => {}, t);
            }
        }(),
              Et = Bt.postPerformanceEvent.bind(Bt),
              Ct = new class extends kt {
            constructor() {
                super("map.auth"), this.success = {}, this.skuToken = "";
            }getSession(t, e, r, n) {
                if (!i.API_URL || !i.SESSION_PATH) return;const s = _t(i.API_URL + i.SESSION_PATH);s.params.push(`sku=${e || ""}`), s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);const a = { url: At(s), headers: { "Content-Type": "text/plain" } };this.pendingRequest = function (t, e) {
                    return lt(z(t, { method: "GET" }), e);
                }(a, t => {
                    this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);
                });
            }getSessionAPI(t, e, r, n) {
                this.skuToken = e, this.errorCb = n, i.SESSION_PATH && i.API_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({ id: t, timestamp: Date.now() }, r) : this.errorCb(new Error(yt)));
            }processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;const { id: e, timestamp: r } = this.queue.shift();e && this.success[e] || this.getSession(r, this.skuToken, t => {
                    t ? this.errorCb(t) : e && (this.success[e] = !0);
                }, t);
            }
        }(),
              Pt = Ct.getSessionAPI.bind(Ct),
              Dt = new Set(),
              Vt = { create: "create", load: "load", fullLoad: "fullLoad" },
              Lt = { mark(t) {
                e.performance.mark(t);
            }, measure(t, r, n) {
                e.performance.measure(t, r, n);
            } };function Ft(t) {
            const e = t.name.split("?")[0];return xt(e) && e.includes("mapbox-gl.js") ? "javascript" : xt(e) && e.includes("mapbox-gl.css") ? "css" : function (t) {
                return i.API_FONTS_REGEX.test(t);
            }(e) ? "fontRange" : bt(e) ? "sprite" : vt(e) ? "style" : function (t) {
                return i.API_TILEJSON_REGEX.test(t);
            }(e) ? "tilejson" : "other";
        }const Rt = e.performance;function jt(t) {
            const e = t ? t.url.toString() : void 0;return Rt.getEntriesByName(e);
        }let Ut, $t, Ot, qt;const Nt = { now: () => void 0 !== Ot ? Ot : e.performance.now(), setNow(t) {
                Ot = t;
            }, restoreNow() {
                Ot = void 0;
            }, frame(t) {
                const r = e.requestAnimationFrame(t);return { cancel: () => e.cancelAnimationFrame(r) };
            }, getImageData(t, r = 0) {
                const { width: n, height: i } = t;qt || (qt = e.document.createElement("canvas"));const s = qt.getContext("2d", { willReadFrequently: !0 });if (!s) throw new Error("failed to create canvas 2d context");return (n > qt.width || i > qt.height) && (qt.width = n, qt.height = i), s.clearRect(-r, -r, n + 2 * r, i + 2 * r), s.drawImage(t, 0, 0, n, i), s.getImageData(-r, -r, n + 2 * r, i + 2 * r);
            }, resolveURL: t => (Ut || (Ut = e.document.createElement("a")), Ut.href = t, Ut.href), get devicePixelRatio() {
                return e.devicePixelRatio;
            }, get prefersReducedMotion() {
                return !!e.matchMedia && (null == $t && ($t = e.matchMedia("(prefers-reduced-motion: reduce)")), $t.matches);
            } };function Gt(t, e, r) {
            r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));
        }function Xt(t, e, r) {
            if (r && r[t]) {
                const n = r[t].indexOf(e);-1 !== n && r[t].splice(n, 1);
            }
        }class Zt {
            constructor(t, e = {}) {
                z(this, e), this.type = t;
            }
        }class Kt extends Zt {
            constructor(t, e = {}) {
                super("error", z({ error: t }, e));
            }
        }class Yt {
            on(t, e) {
                return this._listeners = this._listeners || {}, Gt(t, e, this._listeners), this;
            }off(t, e) {
                return Xt(t, e, this._listeners), Xt(t, e, this._oneTimeListeners), this;
            }once(t, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Gt(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));
            }fire(t, e) {
                "string" == typeof t && (t = new Zt(t, e || {}));const r = t.type;if (this.listens(r)) {
                    t.target = this;const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];for (const r of e) r.call(this, t);const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];for (const e of n) Xt(r, e, this._oneTimeListeners), e.call(this, t);const i = this._eventedParent;i && (z(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));
                } else t instanceof Kt && console.error(t.error);return this;
            }listens(t) {
                return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));
            }setEventedParent(t, e) {
                return this._eventedParent = t, this._eventedParentData = e, this;
            }
        }var Ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');function Wt(t, ...e) {
            for (const r of e) for (const e in r) t[e] = r[e];return t;
        }function Jt(t) {
            return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;
        }function Qt(t) {
            if (Array.isArray(t)) return t.map(Qt);if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {
                const e = {};for (const r in t) e[r] = Qt(t[r]);return e;
            }return Jt(t);
        }class te extends Error {
            constructor(t, e) {
                super(e), this.message = e, this.key = t;
            }
        }var ee = te;class re {
            constructor(t, e = []) {
                this.parent = t, this.bindings = {};for (const [t, r] of e) this.bindings[t] = r;
            }concat(t) {
                return new re(this, t);
            }get(t) {
                if (this.bindings[t]) return this.bindings[t];if (this.parent) return this.parent.get(t);throw new Error(`${t} not found in scope.`);
            }has(t) {
                return !!this.bindings[t] || !!this.parent && this.parent.has(t);
            }
        }var ne = re;const ie = { kind: "null" },
              se = { kind: "number" },
              ae = { kind: "string" },
              oe = { kind: "boolean" },
              le = { kind: "color" },
              ue = { kind: "object" },
              ce = { kind: "value" },
              he = { kind: "collator" },
              pe = { kind: "formatted" },
              fe = { kind: "resolvedImage" };function de(t, e) {
            return { kind: "array", itemType: t, N: e };
        }function ye(t) {
            if ("array" === t.kind) {
                const e = ye(t.itemType);return "number" == typeof t.N ? `array<${e}, ${t.N}>` : "value" === t.itemType.kind ? "array" : `array<${e}>`;
            }return t.kind;
        }const me = [ie, se, ae, oe, le, pe, ue, de(ce), fe];function ge(t, e) {
            if ("error" === e.kind) return null;if ("array" === t.kind) {
                if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !ge(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null;
            } else {
                if (t.kind === e.kind) return null;if ("value" === t.kind) for (const t of me) if (!ge(t, e)) return null;
            }return `Expected ${ye(t)} but found ${ye(e)} instead.`;
        }function xe(t, e) {
            return e.some(e => e.kind === t.kind);
        }function ve(t, e) {
            return e.some(e => "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t);
        }var be,
            we = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };function _e(t) {
            return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;
        }function Ae(t) {
            return _e("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));
        }function Se(t) {
            return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;var e;
        }function ke(t, e, r) {
            return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;
        }try {
            be = {}.parseCSSColor = function (t) {
                var e,
                    r = t.replace(/ /g, "").toLowerCase();if (r in we) return we[r].slice();if ("#" === r[0]) return 4 === r.length ? (e = parseInt(r.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === r.length && (e = parseInt(r.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;var n = r.indexOf("("),
                    i = r.indexOf(")");if (-1 !== n && i + 1 === r.length) {
                    var s = r.substr(0, n),
                        a = r.substr(n + 1, i - (n + 1)).split(","),
                        o = 1;switch (s) {case "rgba":
                            if (4 !== a.length) return null;o = Se(a.pop());case "rgb":
                            return 3 !== a.length ? null : [Ae(a[0]), Ae(a[1]), Ae(a[2]), o];case "hsla":
                            if (4 !== a.length) return null;o = Se(a.pop());case "hsl":
                            if (3 !== a.length) return null;var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360,
                                u = Se(a[1]),
                                c = Se(a[2]),
                                h = c <= .5 ? c * (u + 1) : c + u - c * u,
                                p = 2 * c - h;return [_e(255 * ke(p, h, l + 1 / 3)), _e(255 * ke(p, h, l)), _e(255 * ke(p, h, l - 1 / 3)), o];default:
                            return null;}
                }return null;
            };
        } catch (t) {}class Ie {
            constructor(t, e, r, n = 1) {
                this.r = t, this.g = e, this.b = r, this.a = n;
            }static parse(t) {
                if (!t) return;if (t instanceof Ie) return t;if ("string" != typeof t) return;const e = be(t);return e ? new Ie(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;
            }toString() {
                const [t, e, r, n] = this.toArray();return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;
            }toArray() {
                const { r: t, g: e, b: r, a: n } = this;return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];
            }toArray01() {
                const { r: t, g: e, b: r, a: n } = this;return 0 === n ? [0, 0, 0, 0] : [t / n, e / n, r / n, n];
            }toArray01PremultipliedAlpha() {
                const { r: t, g: e, b: r, a: n } = this;return [t, e, r, n];
            }
        }Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);var Me = Ie;class Te {
            constructor(t, e, r) {
                this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }compare(t, e) {
                return this.collator.compare(t, e);
            }resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }class ze {
            constructor(t, e, r, n, i) {
                this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }class Be {
            constructor(t) {
                this.sections = t;
            }static fromString(t) {
                return new Be([new ze(t, null, null, null, null)]);
            }isEmpty() {
                return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.name.length);
            }static factory(t) {
                return t instanceof Be ? t : Be.fromString(t);
            }toString() {
                return 0 === this.sections.length ? "" : this.sections.map(t => t.text).join("");
            }serialize() {
                const t = ["format"];for (const e of this.sections) {
                    if (e.image) {
                        t.push(["image", e.image.name]);continue;
                    }t.push(e.text);const r = {};e.fontStack && (r["text-font"] = ["literal", e.fontStack.split(",")]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = ["rgba"].concat(e.textColor.toArray())), t.push(r);
                }return t;
            }
        }class Ee {
            constructor(t) {
                this.name = t.name, this.available = t.available;
            }toString() {
                return this.name;
            }static fromString(t) {
                return t ? new Ee({ name: t, available: !1 }) : null;
            }serialize() {
                return ["image", this.name];
            }
        }function Ce(t, e, r, n) {
            return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }function Pe(t) {
            if (null === t) return !0;if ("string" == typeof t) return !0;if ("boolean" == typeof t) return !0;if ("number" == typeof t) return !0;if (t instanceof Me) return !0;if (t instanceof Te) return !0;if (t instanceof Be) return !0;if (t instanceof Ee) return !0;if (Array.isArray(t)) {
                for (const e of t) if (!Pe(e)) return !1;return !0;
            }if ("object" == typeof t) {
                for (const e in t) if (!Pe(t[e])) return !1;return !0;
            }return !1;
        }function De(t) {
            if (null === t) return ie;if ("string" == typeof t) return ae;if ("boolean" == typeof t) return oe;if ("number" == typeof t) return se;if (t instanceof Me) return le;if (t instanceof Te) return he;if (t instanceof Be) return pe;if (t instanceof Ee) return fe;if (Array.isArray(t)) {
                const e = t.length;let r;for (const e of t) {
                    const t = De(e);if (r) {
                        if (r === t) continue;r = ce;break;
                    }r = t;
                }return de(r || ce, e);
            }return ue;
        }function Ve(t) {
            const e = typeof t;return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof Me || t instanceof Be || t instanceof Ee ? t.toString() : JSON.stringify(t);
        }class Le {
            constructor(t, e) {
                this.type = t, this.value = e;
            }static parse(t, e) {
                if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);if (!Pe(t[1])) return e.error("invalid value");const r = t[1];let n = De(r);const i = e.expectedType;return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new Le(n, r);
            }evaluate() {
                return this.value;
            }eachChild() {}outputDefined() {
                return !0;
            }serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Me ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Be ? this.value.serialize() : this.value;
            }
        }var Fe = Le,
            Re = class {
            constructor(t) {
                this.name = "ExpressionEvaluationError", this.message = t;
            }toJSON() {
                return this.message;
            }
        };const je = { string: ae, number: se, boolean: oe, object: ue };class Ue {
            constructor(t, e) {
                this.type = t, this.args = e;
            }static parse(t, e) {
                if (t.length < 2) return e.error("Expected at least one argument.");let r,
                    n = 1;const i = t[0];if ("array" === i) {
                    let i, s;if (t.length > 2) {
                        const r = t[1];if ("string" != typeof r || !(r in je) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);i = je[r], n++;
                    } else i = ce;if (t.length > 3) {
                        if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);s = t[2], n++;
                    }r = de(i, s);
                } else r = je[i];const s = [];for (; n < t.length; n++) {
                    const r = e.parse(t[n], n, ce);if (!r) return null;s.push(r);
                }return new Ue(r, s);
            }evaluate(t) {
                for (let e = 0; e < this.args.length; e++) {
                    const r = this.args[e].evaluate(t);if (!ge(this.type, De(r))) return r;if (e === this.args.length - 1) throw new Re(`Expected value to be of type ${ye(this.type)}, but found ${ye(De(r))} instead.`);
                }return null;
            }eachChild(t) {
                this.args.forEach(t);
            }outputDefined() {
                return this.args.every(t => t.outputDefined());
            }serialize() {
                const t = this.type,
                      e = [t.kind];if ("array" === t.kind) {
                    const r = t.itemType;if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e.push(r.kind);const n = t.N;("number" == typeof n || this.args.length > 1) && e.push(n);
                    }
                }return e.concat(this.args.map(t => t.serialize()));
            }
        }var $e = Ue;class Oe {
            constructor(t) {
                this.type = pe, this.sections = t;
            }static parse(t, e) {
                if (t.length < 2) return e.error("Expected at least one argument.");const r = t[1];if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");const n = [];let i = !1;for (let r = 1; r <= t.length - 1; ++r) {
                    const s = t[r];if (i && "object" == typeof s && !Array.isArray(s)) {
                        i = !1;let t = null;if (s["font-scale"] && (t = e.parse(s["font-scale"], 1, se), !t)) return null;let r = null;if (s["text-font"] && (r = e.parse(s["text-font"], 1, de(ae)), !r)) return null;let a = null;if (s["text-color"] && (a = e.parse(s["text-color"], 1, le), !a)) return null;const o = n[n.length - 1];o.scale = t, o.font = r, o.textColor = a;
                    } else {
                        const s = e.parse(t[r], 1, ce);if (!s) return null;const a = s.type.kind;if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");i = !0, n.push({ content: s, scale: null, font: null, textColor: null });
                    }
                }return new Oe(n);
            }evaluate(t) {
                return new Be(this.sections.map(e => {
                    const r = e.content.evaluate(t);return De(r) === fe ? new ze("", r, null, null, null) : new ze(Ve(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null);
                }));
            }eachChild(t) {
                for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);
            }outputDefined() {
                return !1;
            }serialize() {
                const t = ["format"];for (const e of this.sections) {
                    t.push(e.content.serialize());const r = {};e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t.push(r);
                }return t;
            }
        }class qe {
            constructor(t) {
                this.type = fe, this.input = t;
            }static parse(t, e) {
                if (2 !== t.length) return e.error("Expected two arguments.");const r = e.parse(t[1], 1, ae);return r ? new qe(r) : e.error("No image name provided.");
            }evaluate(t) {
                const e = this.input.evaluate(t),
                      r = Ee.fromString(e);return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;
            }eachChild(t) {
                t(this.input);
            }outputDefined() {
                return !1;
            }serialize() {
                return ["image", this.input.serialize()];
            }
        }const Ne = { "to-boolean": oe, "to-color": le, "to-number": se, "to-string": ae };class Ge {
            constructor(t, e) {
                this.type = t, this.args = e;
            }static parse(t, e) {
                if (t.length < 2) return e.error("Expected at least one argument.");const r = t[0];if (("to-boolean" === r || "to-string" === r) && 2 !== t.length) return e.error("Expected one argument.");const n = Ne[r],
                      i = [];for (let r = 1; r < t.length; r++) {
                    const n = e.parse(t[r], r, ce);if (!n) return null;i.push(n);
                }return new Ge(n, i);
            }evaluate(t) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t));if ("color" === this.type.kind) {
                    let e, r;for (const n of this.args) {
                        if (e = n.evaluate(t), r = null, e instanceof Me) return e;if ("string" == typeof e) {
                            const r = t.parseColor(e);if (r) return r;
                        } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Ce(e[0], e[1], e[2], e[3]), !r)) return new Me(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                    }throw new Re(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`);
                }if ("number" === this.type.kind) {
                    let e = null;for (const r of this.args) {
                        if (e = r.evaluate(t), null === e) return 0;const n = Number(e);if (!isNaN(n)) return n;
                    }throw new Re(`Could not convert ${JSON.stringify(e)} to number.`);
                }return "formatted" === this.type.kind ? Be.fromString(Ve(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? Ee.fromString(Ve(this.args[0].evaluate(t))) : Ve(this.args[0].evaluate(t));
            }eachChild(t) {
                this.args.forEach(t);
            }outputDefined() {
                return this.args.every(t => t.outputDefined());
            }serialize() {
                if ("formatted" === this.type.kind) return new Oe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();if ("resolvedImage" === this.type.kind) return new qe(this.args[0]).serialize();const t = [`to-${this.type.kind}`];return this.eachChild(e => {
                    t.push(e.serialize());
                }), t;
            }
        }var Xe = Ge;const Ze = ["Unknown", "Point", "LineString", "Polygon"];var Ke = class {
            constructor() {
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
            }id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? Ze[this.feature.type] : this.feature.type : null;
            }geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }canonicalID() {
                return this.canonical;
            }properties() {
                return this.feature && this.feature.properties || {};
            }distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t = this.featureDistanceData.center,
                          e = this.featureDistanceData.scale,
                          { x: r, y: n } = this.featureTileCoord;return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);
                }return 0;
            }parseColor(t) {
                let e = this._parseColorCache[t];return e || (e = this._parseColorCache[t] = Me.parse(t)), e;
            }
        };class Ye {
            constructor(t, e, r, n) {
                this.name = t, this.type = e, this._evaluate = r, this.args = n;
            }evaluate(t) {
                return this._evaluate(t, this.args);
            }eachChild(t) {
                this.args.forEach(t);
            }outputDefined() {
                return !1;
            }serialize() {
                return [this.name].concat(this.args.map(t => t.serialize()));
            }static parse(t, e) {
                const r = t[0],
                      n = Ye.definitions[r];if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);const i = Array.isArray(n) ? n[0] : n.type,
                      s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,
                      a = s.filter(([e]) => !Array.isArray(e) || e.length === t.length - 1);let o = null;for (const [n, s] of a) {
                    o = new _r(e.registry, e.path, null, e.scope);const a = [];let l = !1;for (let e = 1; e < t.length; e++) {
                        const r = t[e],
                              i = Array.isArray(n) ? n[e - 1] : n.type,
                              s = o.parse(r, 1 + a.length, i);if (!s) {
                            l = !0;break;
                        }a.push(s);
                    }if (!l) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {
                        for (let t = 0; t < a.length; t++) {
                            const e = Array.isArray(n) ? n[t] : n.type,
                                  r = a[t];o.concat(t + 1).checkSubtype(e, r.type);
                        }if (0 === o.errors.length) return new Ye(r, i, s, a);
                    }
                }if (1 === a.length) e.errors.push(...o.errors);else {
                    const r = (a.length ? a : s).map(([t]) => {
                        return e = t, Array.isArray(e) ? `(${e.map(ye).join(", ")})` : `(${ye(e.type)}...)`;var e;
                    }).join(" | "),
                          n = [];for (let r = 1; r < t.length; r++) {
                        const i = e.parse(t[r], 1 + n.length);if (!i) return null;n.push(ye(i.type));
                    }e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }return null;
            }static register(t, e) {
                Ye.definitions = e;for (const r in e) t[r] = Ye;
            }
        }var He = Ye;class We {
            constructor(t, e, r) {
                this.type = he, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;
            }static parse(t, e) {
                if (2 !== t.length) return e.error("Expected one argument.");const r = t[1];if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");const n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, oe);if (!n) return null;const i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, oe);if (!i) return null;let s = null;return r.locale && (s = e.parse(r.locale, 1, ae), !s) ? null : new We(n, i, s);
            }evaluate(t) {
                return new Te(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
            }eachChild(t) {
                t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
            }outputDefined() {
                return !1;
            }serialize() {
                const t = {};return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t];
            }
        }const Je = 8192;function Qe(t, e) {
            t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);
        }function tr(t, e) {
            return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);
        }function er(t, e) {
            const r = (180 + t[0]) / 360,
                  n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,
                  i = Math.pow(2, e.z);return [Math.round(r * i * Je), Math.round(n * i * Je)];
        }function rr(t, e, r) {
            const n = t[0] - e[0],
                  i = t[1] - e[1],
                  s = t[0] - r[0],
                  a = t[1] - r[1];return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;
        }function nr(t, e) {
            let r = !1;for (let a = 0, o = e.length; a < o; a++) {
                const o = e[a];for (let e = 0, a = o.length; e < a - 1; e++) {
                    if (rr(t, o[e], o[e + 1])) return !1;(i = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);
                }
            }var n, i, s;return r;
        }function ir(t, e) {
            for (let r = 0; r < e.length; r++) if (nr(t, e[r])) return !0;return !1;
        }function sr(t, e, r, n) {
            const i = n[0] - r[0],
                  s = n[1] - r[1],
                  a = (t[0] - r[0]) * s - i * (t[1] - r[1]),
                  o = (e[0] - r[0]) * s - i * (e[1] - r[1]);return a > 0 && o < 0 || a < 0 && o > 0;
        }function ar(t, e, r) {
            for (const u of r) for (let r = 0; r < u.length - 1; ++r) if (0 != (o = [(a = u[r + 1])[0] - (s = u[r])[0], a[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - o[1] * l[0] && sr(n, i, s, a) && sr(s, a, n, i)) return !0;var n, i, s, a, o, l;return !1;
        }function or(t, e) {
            for (let r = 0; r < t.length; ++r) if (!nr(t[r], e)) return !1;for (let r = 0; r < t.length - 1; ++r) if (ar(t[r], t[r + 1], e)) return !1;return !0;
        }function lr(t, e) {
            for (let r = 0; r < e.length; r++) if (or(t, e[r])) return !0;return !1;
        }function ur(t, e, r) {
            const n = [];for (let i = 0; i < t.length; i++) {
                const s = [];for (let n = 0; n < t[i].length; n++) {
                    const a = er(t[i][n], r);Qe(e, a), s.push(a);
                }n.push(s);
            }return n;
        }function cr(t, e, r) {
            const n = [];for (let i = 0; i < t.length; i++) {
                const s = ur(t[i], e, r);n.push(s);
            }return n;
        }function hr(t, e, r, n) {
            if (t[0] < r[0] || t[0] > r[2]) {
                const e = .5 * n;let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;
            }Qe(e, t);
        }function pr(t, e, r, n) {
            const i = Math.pow(2, n.z) * Je,
                  s = [n.x * Je, n.y * Je],
                  a = [];if (!t) return a;for (const n of t) for (const t of n) {
                const n = [t.x + s[0], t.y + s[1]];hr(n, e, r, i), a.push(n);
            }return a;
        }function fr(t, e, r, n) {
            const i = Math.pow(2, n.z) * Je,
                  s = [n.x * Je, n.y * Je],
                  a = [];if (!t) return a;for (const r of t) {
                const t = [];for (const n of r) {
                    const r = [n.x + s[0], n.y + s[1]];Qe(e, r), t.push(r);
                }a.push(t);
            }if (e[2] - e[0] <= i / 2) {
                (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;for (const t of a) for (const n of t) hr(n, e, r, i);
            }var o;return a;
        }class dr {
            constructor(t, e) {
                this.type = oe, this.geojson = t, this.geometries = e;
            }static parse(t, e) {
                if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);if (Pe(t[1])) {
                    const e = t[1];if ("FeatureCollection" === e.type) for (let t = 0; t < e.features.length; ++t) {
                        const r = e.features[t].geometry.type;if ("Polygon" === r || "MultiPolygon" === r) return new dr(e, e.features[t].geometry);
                    } else if ("Feature" === e.type) {
                        const t = e.geometry.type;if ("Polygon" === t || "MultiPolygon" === t) return new dr(e, e.geometry);
                    } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new dr(e, e);
                }return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }evaluate(t) {
                if (null != t.geometry() && null != t.canonicalID()) {
                    if ("Point" === t.geometryType()) return function (t, e) {
                        const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                              i = t.canonicalID();if (!i) return !1;if ("Polygon" === e.type) {
                            const s = ur(e.coordinates, n, i),
                                  a = pr(t.geometry(), r, n, i);if (!tr(r, n)) return !1;for (const t of a) if (!nr(t, s)) return !1;
                        }if ("MultiPolygon" === e.type) {
                            const s = cr(e.coordinates, n, i),
                                  a = pr(t.geometry(), r, n, i);if (!tr(r, n)) return !1;for (const t of a) if (!ir(t, s)) return !1;
                        }return !0;
                    }(t, this.geometries);if ("LineString" === t.geometryType()) return function (t, e) {
                        const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                              i = t.canonicalID();if (!i) return !1;if ("Polygon" === e.type) {
                            const s = ur(e.coordinates, n, i),
                                  a = fr(t.geometry(), r, n, i);if (!tr(r, n)) return !1;for (const t of a) if (!or(t, s)) return !1;
                        }if ("MultiPolygon" === e.type) {
                            const s = cr(e.coordinates, n, i),
                                  a = fr(t.geometry(), r, n, i);if (!tr(r, n)) return !1;for (const t of a) if (!lr(t, s)) return !1;
                        }return !0;
                    }(t, this.geometries);
                }return !1;
            }eachChild() {}outputDefined() {
                return !0;
            }serialize() {
                return ["within", this.geojson];
            }
        }var yr = dr;function mr(t) {
            if (t instanceof He) {
                if ("get" === t.name && 1 === t.args.length) return !1;if ("feature-state" === t.name) return !1;if ("has" === t.name && 1 === t.args.length) return !1;if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1;if (/^filter-/.test(t.name)) return !1;
            }if (t instanceof yr) return !1;let e = !0;return t.eachChild(t => {
                e && !mr(t) && (e = !1);
            }), e;
        }function gr(t) {
            if (t instanceof He && "feature-state" === t.name) return !1;let e = !0;return t.eachChild(t => {
                e && !gr(t) && (e = !1);
            }), e;
        }function xr(t, e) {
            if (t instanceof He && e.indexOf(t.name) >= 0) return !1;let r = !0;return t.eachChild(t => {
                r && !xr(t, e) && (r = !1);
            }), r;
        }class vr {
            constructor(t, e) {
                this.type = e.type, this.name = t, this.boundExpression = e;
            }static parse(t, e) {
                if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument.");const r = t[1];return e.scope.has(r) ? new vr(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }evaluate(t) {
                return this.boundExpression.evaluate(t);
            }eachChild() {}outputDefined() {
                return !1;
            }serialize() {
                return ["var", this.name];
            }
        }var br = vr;class wr {
            constructor(t, e = [], r, n = new ne(), i = []) {
                this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r;
            }parse(t, e, r, n, i = {}) {
                return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);
            }_parse(t, e) {
                function r(t, e, r) {
                    return "assert" === r ? new $e(e, [t]) : "coerce" === r ? new Xe(e, [t]) : t;
                }if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) {
                    if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');const n = t[0];if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;const i = this.registry[n];if (i) {
                        let n = i.parse(t, this);if (!n) return null;if (this.expectedType) {
                            const t = this.expectedType,
                                  i = n.type;if ("string" !== t.kind && "number" !== t.kind && "boolean" !== t.kind && "object" !== t.kind && "array" !== t.kind || "value" !== i.kind) {
                                if ("color" !== t.kind && "formatted" !== t.kind && "resolvedImage" !== t.kind || "value" !== i.kind && "string" !== i.kind) {
                                    if (this.checkSubtype(t, i)) return null;
                                } else n = r(n, t, e.typeAnnotation || "coerce");
                            } else n = r(n, t, e.typeAnnotation || "assert");
                        }if (!(n instanceof Fe) && "resolvedImage" !== n.type.kind && Ar(n)) {
                            const t = new Ke();try {
                                n = new Fe(n.type, n.evaluate(t));
                            } catch (t) {
                                return this.error(t.message), null;
                            }
                        }return n;
                    }return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
                }return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
            }concat(t, e, r) {
                const n = "number" == typeof t ? this.path.concat(t) : this.path,
                      i = r ? this.scope.concat(r) : this.scope;return new wr(this.registry, n, e || null, i, this.errors);
            }error(t, ...e) {
                const r = `${this.key}${e.map(t => `[${t}]`).join("")}`;this.errors.push(new ee(r, t));
            }checkSubtype(t, e) {
                const r = ge(t, e);return r && this.error(r), r;
            }
        }var _r = wr;function Ar(t) {
            if (t instanceof br) return Ar(t.boundExpression);if (t instanceof He && "error" === t.name) return !1;if (t instanceof We) return !1;if (t instanceof yr) return !1;const e = t instanceof Xe || t instanceof $e;let r = !0;return t.eachChild(t => {
                r = e ? r && Ar(t) : r && t instanceof Fe;
            }), !!r && mr(t) && xr(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
        }function Sr(t, e) {
            const r = t.length - 1;let n,
                i,
                s = 0,
                a = r,
                o = 0;for (; s <= a;) if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) {
                if (o === r || e < i) return o;s = o + 1;
            } else {
                if (!(n > e)) throw new Re("Input is not a number.");a = o - 1;
            }return 0;
        }class kr {
            constructor(t, e, r) {
                this.type = t, this.input = e, this.labels = [], this.outputs = [];for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);
            }static parse(t, e) {
                if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");const r = e.parse(t[1], 1, se);if (!r) return null;const n = [];let i = null;e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);for (let r = 1; r < t.length; r += 2) {
                    const s = 1 === r ? -1 / 0 : t[r],
                          a = t[r + 1],
                          o = r,
                          l = r + 1;if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);const u = e.parse(a, l, i);if (!u) return null;i = i || u.type, n.push([s, u]);
                }return new kr(i, r, n);
            }evaluate(t) {
                const e = this.labels,
                      r = this.outputs;if (1 === e.length) return r[0].evaluate(t);const n = this.input.evaluate(t);if (n <= e[0]) return r[0].evaluate(t);const i = e.length;return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Sr(e, n)].evaluate(t);
            }eachChild(t) {
                t(this.input);for (const e of this.outputs) t(e);
            }outputDefined() {
                return this.outputs.every(t => t.outputDefined());
            }serialize() {
                const t = ["step", this.input.serialize()];for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());return t;
            }
        }var Ir = kr;function Mr(t, e, r) {
            return t * (1 - r) + e * r;
        }var Tr = Object.freeze({ __proto__: null, number: Mr, color: function (t, e, r) {
                return new Me(Mr(t.r, e.r, r), Mr(t.g, e.g, r), Mr(t.b, e.b, r), Mr(t.a, e.a, r));
            }, array: function (t, e, r) {
                return t.map((t, n) => Mr(t, e[n], r));
            } });const zr = .95047,
              Br = 1.08883,
              Er = 4 / 29,
              Cr = 6 / 29,
              Pr = 3 * Cr * Cr,
              Dr = Math.PI / 180,
              Vr = 180 / Math.PI;function Lr(t) {
            return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Pr + Er;
        }function Fr(t) {
            return t > Cr ? t * t * t : Pr * (t - Er);
        }function Rr(t) {
            return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);
        }function jr(t) {
            return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
        }function Ur(t) {
            const e = jr(t.r),
                  r = jr(t.g),
                  n = jr(t.b),
                  i = Lr((.4124564 * e + .3575761 * r + .1804375 * n) / zr),
                  s = Lr((.2126729 * e + .7151522 * r + .072175 * n) / 1);return { l: 116 * s - 16, a: 500 * (i - s), b: 200 * (s - Lr((.0193339 * e + .119192 * r + .9503041 * n) / Br)), alpha: t.a };
        }function $r(t) {
            let e = (t.l + 16) / 116,
                r = isNaN(t.a) ? e : e + t.a / 500,
                n = isNaN(t.b) ? e : e - t.b / 200;return e = 1 * Fr(e), r = zr * Fr(r), n = Br * Fr(n), new Me(Rr(3.2404542 * r - 1.5371385 * e - .4985314 * n), Rr(-.969266 * r + 1.8760108 * e + .041556 * n), Rr(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);
        }function Or(t, e, r) {
            const n = e - t;return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }const qr = { forward: Ur, reverse: $r, interpolate: function (t, e, r) {
                return { l: Mr(t.l, e.l, r), a: Mr(t.a, e.a, r), b: Mr(t.b, e.b, r), alpha: Mr(t.alpha, e.alpha, r) };
            } },
              Nr = { forward: function (t) {
                const { l: e, a: r, b: n } = Ur(t),
                      i = Math.atan2(n, r) * Vr;return { h: i < 0 ? i + 360 : i, c: Math.sqrt(r * r + n * n), l: e, alpha: t.a };
            }, reverse: function (t) {
                const e = t.h * Dr,
                      r = t.c;return $r({ l: t.l, a: Math.cos(e) * r, b: Math.sin(e) * r, alpha: t.alpha });
            }, interpolate: function (t, e, r) {
                return { h: Or(t.h, e.h, r), c: Mr(t.c, e.c, r), l: Mr(t.l, e.l, r), alpha: Mr(t.alpha, e.alpha, r) };
            } };var Gr = Object.freeze({ __proto__: null, lab: qr, hcl: Nr });class Xr {
            constructor(t, e, r, n, i) {
                this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);
            }static interpolationFactor(t, e, r, n) {
                let i = 0;if ("exponential" === t.name) i = Zr(e, t.base, r, n);else if ("linear" === t.name) i = Zr(e, 1, r, n);else if ("cubic-bezier" === t.name) {
                    const s = t.controlPoints;i = new p(s[0], s[1], s[2], s[3]).solve(Zr(e, 1, r, n));
                }return i;
            }static parse(t, e) {
                let [r, n, i, ...s] = t;if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);if ("linear" === n[0]) n = { name: "linear" };else if ("exponential" === n[0]) {
                    const t = n[1];if ("number" != typeof t) return e.error("Exponential interpolation requires a numeric base.", 1, 1);n = { name: "exponential", base: t };
                } else {
                    if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);{
                        const t = n.slice(1);if (4 !== t.length || t.some(t => "number" != typeof t || t < 0 || t > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);n = { name: "cubic-bezier", controlPoints: t };
                    }
                }if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");if (i = e.parse(i, 2, se), !i) return null;const a = [];let o = null;"interpolate-hcl" === r || "interpolate-lab" === r ? o = le : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType);for (let t = 0; t < s.length; t += 2) {
                    const r = s[t],
                          n = s[t + 1],
                          i = t + 3,
                          l = t + 4;if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);const u = e.parse(n, l, o);if (!u) return null;o = o || u.type, a.push([r, u]);
                }return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new Xr(o, r, n, i, a) : e.error(`Type ${ye(o)} is not interpolatable.`);
            }evaluate(t) {
                const e = this.labels,
                      r = this.outputs;if (1 === e.length) return r[0].evaluate(t);const n = this.input.evaluate(t);if (n <= e[0]) return r[0].evaluate(t);const i = e.length;if (n >= e[i - 1]) return r[i - 1].evaluate(t);const s = Sr(e, n),
                      a = Xr.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),
                      o = r[s].evaluate(t),
                      l = r[s + 1].evaluate(t);return "interpolate" === this.operator ? Tr[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? Nr.reverse(Nr.interpolate(Nr.forward(o), Nr.forward(l), a)) : qr.reverse(qr.interpolate(qr.forward(o), qr.forward(l), a));
            }eachChild(t) {
                t(this.input);for (const e of this.outputs) t(e);
            }outputDefined() {
                return this.outputs.every(t => t.outputDefined());
            }serialize() {
                let t;t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);const e = [this.operator, t, this.input.serialize()];for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());return e;
            }
        }function Zr(t, e, r, n) {
            const i = n - r,
                  s = t - r;return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
        }var Kr = Xr;class Yr {
            constructor(t, e) {
                this.type = t, this.args = e;
            }static parse(t, e) {
                if (t.length < 2) return e.error("Expectected at least one argument.");let r = null;const n = e.expectedType;n && "value" !== n.kind && (r = n);const i = [];for (const n of t.slice(1)) {
                    const t = e.parse(n, 1 + i.length, r, void 0, { typeAnnotation: "omit" });if (!t) return null;r = r || t.type, i.push(t);
                }const s = n && i.some(t => ge(n, t.type));return new Yr(s ? ce : r, i);
            }evaluate(t) {
                let e,
                    r = null,
                    n = 0;for (const i of this.args) {
                    if (n++, r = i.evaluate(t), r && r instanceof Ee && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;if (null !== r) break;
                }return r;
            }eachChild(t) {
                this.args.forEach(t);
            }outputDefined() {
                return this.args.every(t => t.outputDefined());
            }serialize() {
                const t = ["coalesce"];return this.eachChild(e => {
                    t.push(e.serialize());
                }), t;
            }
        }var Hr = Yr;class Wr {
            constructor(t, e) {
                this.type = e.type, this.bindings = [].concat(t), this.result = e;
            }evaluate(t) {
                return this.result.evaluate(t);
            }eachChild(t) {
                for (const e of this.bindings) t(e[1]);t(this.result);
            }static parse(t, e) {
                if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);const r = [];for (let n = 1; n < t.length - 1; n += 2) {
                    const i = t[n];if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n);const s = e.parse(t[n + 1], n + 1);if (!s) return null;r.push([i, s]);
                }const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);return n ? new Wr(r, n) : null;
            }outputDefined() {
                return this.result.outputDefined();
            }serialize() {
                const t = ["let"];for (const [e, r] of this.bindings) t.push(e, r.serialize());return t.push(this.result.serialize()), t;
            }
        }var Jr = Wr;class Qr {
            constructor(t, e, r) {
                this.type = t, this.index = e, this.input = r;
            }static parse(t, e) {
                if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);const r = e.parse(t[1], 1, se),
                      n = e.parse(t[2], 2, de(e.expectedType || ce));return r && n ? new Qr(n.type.itemType, r, n) : null;
            }evaluate(t) {
                const e = this.index.evaluate(t),
                      r = this.input.evaluate(t);if (e < 0) throw new Re(`Array index out of bounds: ${e} < 0.`);if (e >= r.length) throw new Re(`Array index out of bounds: ${e} > ${r.length - 1}.`);if (e !== Math.floor(e)) throw new Re(`Array index must be an integer, but found ${e} instead.`);return r[e];
            }eachChild(t) {
                t(this.index), t(this.input);
            }outputDefined() {
                return !1;
            }serialize() {
                return ["at", this.index.serialize(), this.input.serialize()];
            }
        }var tn = Qr;class en {
            constructor(t, e) {
                this.type = oe, this.needle = t, this.haystack = e;
            }static parse(t, e) {
                if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);const r = e.parse(t[1], 1, ce),
                      n = e.parse(t[2], 2, ce);return r && n ? xe(r.type, [oe, ae, se, ie, ce]) ? new en(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r.type)} instead`) : null;
            }evaluate(t) {
                const e = this.needle.evaluate(t),
                      r = this.haystack.evaluate(t);if (null == r) return !1;if (!ve(e, ["boolean", "string", "number", "null"])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e))} instead.`);if (!ve(r, ["string", "array"])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r))} instead.`);return r.indexOf(e) >= 0;
            }eachChild(t) {
                t(this.needle), t(this.haystack);
            }outputDefined() {
                return !0;
            }serialize() {
                return ["in", this.needle.serialize(), this.haystack.serialize()];
            }
        }var rn = en;class nn {
            constructor(t, e, r) {
                this.type = se, this.needle = t, this.haystack = e, this.fromIndex = r;
            }static parse(t, e) {
                if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);const r = e.parse(t[1], 1, ce),
                      n = e.parse(t[2], 2, ce);if (!r || !n) return null;if (!xe(r.type, [oe, ae, se, ie, ce])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r.type)} instead`);if (4 === t.length) {
                    const i = e.parse(t[3], 3, se);return i ? new nn(r, n, i) : null;
                }return new nn(r, n);
            }evaluate(t) {
                const e = this.needle.evaluate(t),
                      r = this.haystack.evaluate(t);if (!ve(e, ["boolean", "string", "number", "null"])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e))} instead.`);if (!ve(r, ["string", "array"])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r))} instead.`);if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t);return r.indexOf(e, n);
                }return r.indexOf(e);
            }eachChild(t) {
                t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
            }outputDefined() {
                return !1;
            }serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t = this.fromIndex.serialize();return ["index-of", this.needle.serialize(), this.haystack.serialize(), t];
                }return ["index-of", this.needle.serialize(), this.haystack.serialize()];
            }
        }var sn = nn;class an {
            constructor(t, e, r, n, i, s) {
                this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
            }static parse(t, e) {
                if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");let r, n;e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);const i = {},
                      s = [];for (let a = 2; a < t.length - 1; a += 2) {
                    let o = t[a];const l = t[a + 1];Array.isArray(o) || (o = [o]);const u = e.concat(a);if (0 === o.length) return u.error("Expected at least one branch label.");for (const t of o) {
                        if ("number" != typeof t && "string" != typeof t) return u.error("Branch labels must be numbers or strings.");if ("number" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if ("number" == typeof t && Math.floor(t) !== t) return u.error("Numeric branch labels must be integer values.");if (r) {
                            if (u.checkSubtype(r, De(t))) return null;
                        } else r = De(t);if (void 0 !== i[String(t)]) return u.error("Branch labels must be unique.");i[String(t)] = s.length;
                    }const c = e.parse(l, a, n);if (!c) return null;n = n || c.type, s.push(c);
                }const a = e.parse(t[1], 1, ce);if (!a) return null;const o = e.parse(t[t.length - 1], t.length - 1, n);return o ? "value" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new an(r, n, a, i, s, o) : null;
            }evaluate(t) {
                const e = this.input.evaluate(t);return (De(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);
            }eachChild(t) {
                t(this.input), this.outputs.forEach(t), t(this.otherwise);
            }outputDefined() {
                return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();
            }serialize() {
                const t = ["match", this.input.serialize()],
                      e = Object.keys(this.cases).sort(),
                      r = [],
                      n = {};for (const t of e) {
                    const e = n[this.cases[t]];void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);
                }const i = t => "number" === this.inputType.kind ? Number(t) : t;for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());return t.push(this.otherwise.serialize()), t;
            }
        }var on = an;class ln {
            constructor(t, e, r) {
                this.type = t, this.branches = e, this.otherwise = r;
            }static parse(t, e) {
                if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");let r;e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);const n = [];for (let i = 1; i < t.length - 1; i += 2) {
                    const s = e.parse(t[i], i, oe);if (!s) return null;const a = e.parse(t[i + 1], i + 1, r);if (!a) return null;n.push([s, a]), r = r || a.type;
                }const i = e.parse(t[t.length - 1], t.length - 1, r);return i ? new ln(r, n, i) : null;
            }evaluate(t) {
                for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);return this.otherwise.evaluate(t);
            }eachChild(t) {
                for (const [e, r] of this.branches) t(e), t(r);t(this.otherwise);
            }outputDefined() {
                return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();
            }serialize() {
                const t = ["case"];return this.eachChild(e => {
                    t.push(e.serialize());
                }), t;
            }
        }var un = ln;class cn {
            constructor(t, e, r, n) {
                this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;
            }static parse(t, e) {
                if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);const r = e.parse(t[1], 1, ce),
                      n = e.parse(t[2], 2, se);if (!r || !n) return null;if (!xe(r.type, [de(ce), ae, ce])) return e.error(`Expected first argument to be of type array or string, but found ${ye(r.type)} instead`);if (4 === t.length) {
                    const i = e.parse(t[3], 3, se);return i ? new cn(r.type, r, n, i) : null;
                }return new cn(r.type, r, n);
            }evaluate(t) {
                const e = this.input.evaluate(t),
                      r = this.beginIndex.evaluate(t);if (!ve(e, ["string", "array"])) throw new Re(`Expected first argument to be of type array or string, but found ${ye(De(e))} instead.`);if (this.endIndex) {
                    const n = this.endIndex.evaluate(t);return e.slice(r, n);
                }return e.slice(r);
            }eachChild(t) {
                t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
            }outputDefined() {
                return !1;
            }serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t = this.endIndex.serialize();return ["slice", this.input.serialize(), this.beginIndex.serialize(), t];
                }return ["slice", this.input.serialize(), this.beginIndex.serialize()];
            }
        }var hn = cn;function pn(t, e) {
            return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;
        }function fn(t, e, r, n) {
            return 0 === n.compare(e, r);
        }function dn(t, e, r) {
            const n = "==" !== t && "!=" !== t;return class i {
                constructor(t, e, r) {
                    this.type = oe, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind;
                }static parse(t, e) {
                    if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments.");const r = t[0];let s = e.parse(t[1], 1, ce);if (!s) return null;if (!pn(r, s.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${ye(s.type)}'.`);let a = e.parse(t[2], 2, ce);if (!a) return null;if (!pn(r, a.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${ye(a.type)}'.`);if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error(`Cannot compare types '${ye(s.type)}' and '${ye(a.type)}'.`);n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new $e(a.type, [s]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new $e(s.type, [a])));let o = null;if (4 === t.length) {
                        if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error("Cannot use collator to compare non-string types.");if (o = e.parse(t[3], 3, he), !o) return null;
                    }return new i(s, a, o);
                }evaluate(i) {
                    const s = this.lhs.evaluate(i),
                          a = this.rhs.evaluate(i);if (n && this.hasUntypedArgument) {
                        const e = De(s),
                              r = De(a);if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new Re(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);
                    }if (this.collator && !n && this.hasUntypedArgument) {
                        const t = De(s),
                              r = De(a);if ("string" !== t.kind || "string" !== r.kind) return e(i, s, a);
                    }return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);
                }eachChild(t) {
                    t(this.lhs), t(this.rhs), this.collator && t(this.collator);
                }outputDefined() {
                    return !0;
                }serialize() {
                    const e = [t];return this.eachChild(t => {
                        e.push(t.serialize());
                    }), e;
                }
            };
        }const yn = dn("==", function (t, e, r) {
            return e === r;
        }, fn),
              mn = dn("!=", function (t, e, r) {
            return e !== r;
        }, function (t, e, r, n) {
            return !fn(0, e, r, n);
        }),
              gn = dn("<", function (t, e, r) {
            return e < r;
        }, function (t, e, r, n) {
            return n.compare(e, r) < 0;
        }),
              xn = dn(">", function (t, e, r) {
            return e > r;
        }, function (t, e, r, n) {
            return n.compare(e, r) > 0;
        }),
              vn = dn("<=", function (t, e, r) {
            return e <= r;
        }, function (t, e, r, n) {
            return n.compare(e, r) <= 0;
        }),
              bn = dn(">=", function (t, e, r) {
            return e >= r;
        }, function (t, e, r, n) {
            return n.compare(e, r) >= 0;
        });class wn {
            constructor(t, e, r, n, i, s) {
                this.type = ae, this.number = t, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;
            }static parse(t, e) {
                if (3 !== t.length) return e.error("Expected two arguments.");const r = e.parse(t[1], 1, se);if (!r) return null;const n = t[2];if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");let i = null;if (n.locale && (i = e.parse(n.locale, 1, ae), !i)) return null;let s = null;if (n.currency && (s = e.parse(n.currency, 1, ae), !s)) return null;let a = null;if (n.unit && (a = e.parse(n.unit, 1, ae), !a)) return null;let o = null;if (n["min-fraction-digits"] && (o = e.parse(n["min-fraction-digits"], 1, se), !o)) return null;let l = null;return n["max-fraction-digits"] && (l = e.parse(n["max-fraction-digits"], 1, se), !l) ? null : new wn(r, i, s, a, o, l);
            }evaluate(t) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, unit: this.unit ? this.unit.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
            }eachChild(t) {
                t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
            }outputDefined() {
                return !1;
            }serialize() {
                const t = {};return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t];
            }
        }class _n {
            constructor(t) {
                this.type = se, this.input = t;
            }static parse(t, e) {
                if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);const r = e.parse(t[1], 1);return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${ye(r.type)} instead.`) : new _n(r) : null;
            }evaluate(t) {
                const e = this.input.evaluate(t);if ("string" == typeof e) return e.length;if (Array.isArray(e)) return e.length;throw new Re(`Expected value to be of type string or array, but found ${ye(De(e))} instead.`);
            }eachChild(t) {
                t(this.input);
            }outputDefined() {
                return !1;
            }serialize() {
                const t = ["length"];return this.eachChild(e => {
                    t.push(e.serialize());
                }), t;
            }
        }const An = { "==": yn, "!=": mn, ">": xn, "<": gn, ">=": bn, "<=": vn, array: $e, at: tn, boolean: $e, case: un, coalesce: Hr, collator: We, format: Oe, image: qe, in: rn, "index-of": sn, interpolate: Kr, "interpolate-hcl": Kr, "interpolate-lab": Kr, length: _n, let: Jr, literal: Fe, match: on, number: $e, "number-format": wn, object: $e, slice: hn, step: Ir, string: $e, "to-boolean": Xe, "to-color": Xe, "to-number": Xe, "to-string": Xe, var: br, within: yr };function Sn(t, [e, r, n, i]) {
            e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);const s = i ? i.evaluate(t) : 1,
                  a = Ce(e, r, n, s);if (a) throw new Re(a);return new Me(e / 255 * s, r / 255 * s, n / 255 * s, s);
        }function kn(t, e) {
            return t in e;
        }function In(t, e) {
            const r = e[t];return void 0 === r ? null : r;
        }function Mn(t) {
            return { type: t };
        }He.register(An, { error: [{ kind: "error" }, [ae], (t, [e]) => {
                throw new Re(e.evaluate(t));
            }], typeof: [ae, [ce], (t, [e]) => ye(De(e.evaluate(t)))], "to-rgba": [de(se, 4), [le], (t, [e]) => e.evaluate(t).toArray()], rgb: [le, [se, se, se], Sn], rgba: [le, [se, se, se, se], Sn], has: { type: oe, overloads: [[[ae], (t, [e]) => kn(e.evaluate(t), t.properties())], [[ae, ue], (t, [e, r]) => kn(e.evaluate(t), r.evaluate(t))]] }, get: { type: ce, overloads: [[[ae], (t, [e]) => In(e.evaluate(t), t.properties())], [[ae, ue], (t, [e, r]) => In(e.evaluate(t), r.evaluate(t))]] }, "feature-state": [ce, [ae], (t, [e]) => In(e.evaluate(t), t.featureState || {})], properties: [ue, [], t => t.properties()], "geometry-type": [ae, [], t => t.geometryType()], id: [ce, [], t => t.id()], zoom: [se, [], t => t.globals.zoom], pitch: [se, [], t => t.globals.pitch || 0], "distance-from-center": [se, [], t => t.distanceFromCenter()], "heatmap-density": [se, [], t => t.globals.heatmapDensity || 0], "line-progress": [se, [], t => t.globals.lineProgress || 0], "sky-radial-progress": [se, [], t => t.globals.skyRadialProgress || 0], accumulated: [ce, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated], "+": [se, Mn(se), (t, e) => {
                let r = 0;for (const n of e) r += n.evaluate(t);return r;
            }], "*": [se, Mn(se), (t, e) => {
                let r = 1;for (const n of e) r *= n.evaluate(t);return r;
            }], "-": { type: se, overloads: [[[se, se], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[se], (t, [e]) => -e.evaluate(t)]] }, "/": [se, [se, se], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)], "%": [se, [se, se], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)], ln2: [se, [], () => Math.LN2], pi: [se, [], () => Math.PI], e: [se, [], () => Math.E], "^": [se, [se, se], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))], sqrt: [se, [se], (t, [e]) => Math.sqrt(e.evaluate(t))], log10: [se, [se], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10], ln: [se, [se], (t, [e]) => Math.log(e.evaluate(t))], log2: [se, [se], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2], sin: [se, [se], (t, [e]) => Math.sin(e.evaluate(t))], cos: [se, [se], (t, [e]) => Math.cos(e.evaluate(t))], tan: [se, [se], (t, [e]) => Math.tan(e.evaluate(t))], asin: [se, [se], (t, [e]) => Math.asin(e.evaluate(t))], acos: [se, [se], (t, [e]) => Math.acos(e.evaluate(t))], atan: [se, [se], (t, [e]) => Math.atan(e.evaluate(t))], min: [se, Mn(se), (t, e) => Math.min(...e.map(e => e.evaluate(t)))], max: [se, Mn(se), (t, e) => Math.max(...e.map(e => e.evaluate(t)))], abs: [se, [se], (t, [e]) => Math.abs(e.evaluate(t))], round: [se, [se], (t, [e]) => {
                const r = e.evaluate(t);return r < 0 ? -Math.round(-r) : Math.round(r);
            }], floor: [se, [se], (t, [e]) => Math.floor(e.evaluate(t))], ceil: [se, [se], (t, [e]) => Math.ceil(e.evaluate(t))], "filter-==": [oe, [ae, ce], (t, [e, r]) => t.properties()[e.value] === r.value], "filter-id-==": [oe, [ce], (t, [e]) => t.id() === e.value], "filter-type-==": [oe, [ae], (t, [e]) => t.geometryType() === e.value], "filter-<": [oe, [ae, ce], (t, [e, r]) => {
                const n = t.properties()[e.value],
                      i = r.value;return typeof n == typeof i && n < i;
            }], "filter-id-<": [oe, [ce], (t, [e]) => {
                const r = t.id(),
                      n = e.value;return typeof r == typeof n && r < n;
            }], "filter->": [oe, [ae, ce], (t, [e, r]) => {
                const n = t.properties()[e.value],
                      i = r.value;return typeof n == typeof i && n > i;
            }], "filter-id->": [oe, [ce], (t, [e]) => {
                const r = t.id(),
                      n = e.value;return typeof r == typeof n && r > n;
            }], "filter-<=": [oe, [ae, ce], (t, [e, r]) => {
                const n = t.properties()[e.value],
                      i = r.value;return typeof n == typeof i && n <= i;
            }], "filter-id-<=": [oe, [ce], (t, [e]) => {
                const r = t.id(),
                      n = e.value;return typeof r == typeof n && r <= n;
            }], "filter->=": [oe, [ae, ce], (t, [e, r]) => {
                const n = t.properties()[e.value],
                      i = r.value;return typeof n == typeof i && n >= i;
            }], "filter-id->=": [oe, [ce], (t, [e]) => {
                const r = t.id(),
                      n = e.value;return typeof r == typeof n && r >= n;
            }], "filter-has": [oe, [ce], (t, [e]) => e.value in t.properties()], "filter-has-id": [oe, [], t => null !== t.id() && void 0 !== t.id()], "filter-type-in": [oe, [de(ae)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0], "filter-id-in": [oe, [de(ce)], (t, [e]) => e.value.indexOf(t.id()) >= 0], "filter-in-small": [oe, [ae, de(ce)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0], "filter-in-large": [oe, [ae, de(ce)], (t, [e, r]) => function (t, e, r, n) {
                for (; r <= n;) {
                    const i = r + n >> 1;if (e[i] === t) return !0;e[i] > t ? n = i - 1 : r = i + 1;
                }return !1;
            }(t.properties()[e.value], r.value, 0, r.value.length - 1)], all: { type: oe, overloads: [[[oe, oe], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Mn(oe), (t, e) => {
                    for (const r of e) if (!r.evaluate(t)) return !1;return !0;
                }]] }, any: { type: oe, overloads: [[[oe, oe], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Mn(oe), (t, e) => {
                    for (const r of e) if (r.evaluate(t)) return !0;return !1;
                }]] }, "!": [oe, [oe], (t, [e]) => !e.evaluate(t)], "is-supported-script": [oe, [ae], (t, [e]) => {
                const r = t.globals && t.globals.isSupportedScript;return !r || r(e.evaluate(t));
            }], upcase: [ae, [ae], (t, [e]) => e.evaluate(t).toUpperCase()], downcase: [ae, [ae], (t, [e]) => e.evaluate(t).toLowerCase()], concat: [ae, Mn(ce), (t, e) => e.map(e => Ve(e.evaluate(t))).join("")], "resolved-locale": [ae, [he], (t, [e]) => e.evaluate(t).resolvedLocale()] });var Tn = An;function zn(t) {
            return { result: "success", value: t };
        }function Bn(t) {
            return { result: "error", value: t };
        }function En(t) {
            return "data-driven" === t["property-type"];
        }function Cn(t) {
            return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;
        }function Pn(t) {
            return !!t.expression && t.expression.interpolated;
        }function Dn(t) {
            return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t;
        }function Vn(t) {
            return "object" == typeof t && null !== t && !Array.isArray(t);
        }function Ln(t) {
            return t;
        }function Fn(t, e) {
            const r = "color" === e.type,
                  n = t.stops && "object" == typeof t.stops[0][0],
                  i = n || !(n || void 0 !== t.property),
                  s = t.type || (Pn(e) ? "exponential" : "interval");if (r && ((t = Wt({}, t)).stops && (t.stops = t.stops.map(t => [t[0], Me.parse(t[1])])), t.default = Me.parse(t.default ? t.default : e.default)), t.colorSpace && "rgb" !== t.colorSpace && !Gr[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);let a, o, l;if ("exponential" === s) a = $n;else if ("interval" === s) a = Un;else if ("categorical" === s) {
                a = jn, o = Object.create(null);for (const e of t.stops) o[e[0]] = e[1];l = typeof t.stops[0][0];
            } else {
                if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);a = On;
            }if (n) {
                const r = {},
                      n = [];for (let e = 0; e < t.stops.length; e++) {
                    const i = t.stops[e],
                          s = i[0].zoom;void 0 === r[s] && (r[s] = { zoom: s, type: t.type, property: t.property, default: t.default, stops: [] }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);
                }const i = [];for (const t of n) i.push([r[t].zoom, Fn(r[t], e)]);const s = { name: "linear" };return { kind: "composite", interpolationType: s, interpolationFactor: Kr.interpolationFactor.bind(void 0, s), zoomStops: i.map(t => t[0]), evaluate: ({ zoom: r }, n) => $n({ stops: i, base: t.base }, e, r).evaluate(r, n) };
            }if (i) {
                const r = "exponential" === s ? { name: "exponential", base: void 0 !== t.base ? t.base : 1 } : null;return { kind: "camera", interpolationType: r, interpolationFactor: Kr.interpolationFactor.bind(void 0, r), zoomStops: t.stops.map(t => t[0]), evaluate: ({ zoom: r }) => a(t, e, r, o, l) };
            }return { kind: "source", evaluate(r, n) {
                    const i = n && n.properties ? n.properties[t.property] : void 0;return void 0 === i ? Rn(t.default, e.default) : a(t, e, i, o, l);
                } };
        }function Rn(t, e, r) {
            return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;
        }function jn(t, e, r, n, i) {
            return Rn(typeof r === i ? n[r] : void 0, t.default, e.default);
        }function Un(t, e, r) {
            if ("number" !== Dn(r)) return Rn(t.default, e.default);const n = t.stops.length;if (1 === n) return t.stops[0][1];if (r <= t.stops[0][0]) return t.stops[0][1];if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];const i = Sr(t.stops.map(t => t[0]), r);return t.stops[i][1];
        }function $n(t, e, r) {
            const n = void 0 !== t.base ? t.base : 1;if ("number" !== Dn(r)) return Rn(t.default, e.default);const i = t.stops.length;if (1 === i) return t.stops[0][1];if (r <= t.stops[0][0]) return t.stops[0][1];if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];const s = Sr(t.stops.map(t => t[0]), r),
                  a = function (t, e, r, n) {
                const i = n - r,
                      s = t - r;return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
            }(r, n, t.stops[s][0], t.stops[s + 1][0]),
                  o = t.stops[s][1],
                  l = t.stops[s + 1][1];let u = Tr[e.type] || Ln;if (t.colorSpace && "rgb" !== t.colorSpace) {
                const e = Gr[t.colorSpace];u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));
            }return "function" == typeof o.evaluate ? { evaluate(...t) {
                    const e = o.evaluate.apply(void 0, t),
                          r = l.evaluate.apply(void 0, t);if (void 0 !== e && void 0 !== r) return u(e, r, a);
                } } : u(o, l, a);
        }function On(t, e, r) {
            return "color" === e.type ? r = Me.parse(r) : "formatted" === e.type ? r = Be.fromString(r.toString()) : "resolvedImage" === e.type ? r = Ee.fromString(r.toString()) : Dn(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), Rn(r, t.default, e.default);
        }class qn {
            constructor(t, e) {
                this.expression = t, this._warningHistory = {}, this._evaluator = new Ke(), this._defaultValue = e ? function (t) {
                    return "color" === t.type && (Vn(t.default) || Array.isArray(t.default)) ? new Me(0, 0, 0, 0) : "color" === t.type ? Me.parse(t.default) || null : void 0 === t.default ? null : t.default;
                }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null;
            }evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {
                return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
            }evaluate(t, e, r, n, i, s, a, o) {
                this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;try {
                    const t = this.expression.evaluate(this._evaluator);if (null == t || "number" == typeof t && t != t) return this._defaultValue;if (this._enumValues && !(t in this._enumValues)) throw new Re(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(", ")}, but found ${JSON.stringify(t)} instead.`);return t;
                } catch (t) {
                    return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue;
                }
            }
        }function Nn(t) {
            return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in Tn;
        }function Gn(t, e) {
            const r = new _r(Tn, [], e ? function (t) {
                const e = { color: le, string: ae, number: se, enum: ae, boolean: oe, formatted: pe, resolvedImage: fe };return "array" === t.type ? de(e[t.value] || ce, t.length) : e[t.type];
            }(e) : void 0),
                  n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? { typeAnnotation: "coerce" } : void 0);return n ? zn(new qn(n, e)) : Bn(r.errors);
        }class Xn {
            constructor(t, e) {
                this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !gr(e.expression);
            }evaluateWithoutErrorHandling(t, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
            }evaluate(t, e, r, n, i, s) {
                return this._styleExpression.evaluate(t, e, r, n, i, s);
            }
        }class Zn {
            constructor(t, e, r, n) {
                this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t && !gr(e.expression), this.interpolationType = n;
            }evaluateWithoutErrorHandling(t, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
            }evaluate(t, e, r, n, i, s) {
                return this._styleExpression.evaluate(t, e, r, n, i, s);
            }interpolationFactor(t, e, r) {
                return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, t, e, r) : 0;
            }
        }function Kn(t, e) {
            if ("error" === (t = Gn(t, e)).result) return t;const r = t.value.expression,
                  n = mr(r);if (!n && !En(e)) return Bn([new ee("", "data expressions not supported")]);const i = xr(r, ["zoom", "pitch", "distance-from-center"]);if (!i && !Cn(e)) return Bn([new ee("", "zoom expressions not supported")]);const s = Hn(r);return s || i ? s instanceof ee ? Bn([s]) : s instanceof Kr && !Pn(e) ? Bn([new ee("", '"interpolate" expressions cannot be used with this property')]) : zn(s ? new Zn(n ? "camera" : "composite", t.value, s.labels, s instanceof Kr ? s.interpolation : void 0) : new Xn(n ? "constant" : "source", t.value)) : Bn([new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }class Yn {
            constructor(t, e) {
                this._parameters = t, this._specification = e, Wt(this, Fn(this._parameters, this._specification));
            }static deserialize(t) {
                return new Yn(t._parameters, t._specification);
            }static serialize(t) {
                return { _parameters: t._parameters, _specification: t._specification };
            }
        }function Hn(t) {
            let e = null;if (t instanceof Jr) e = Hn(t.result);else if (t instanceof Hr) {
                for (const r of t.args) if (e = Hn(r), e) break;
            } else (t instanceof Ir || t instanceof Kr) && t.input instanceof He && "zoom" === t.input.name && (e = t);return e instanceof ee || t.eachChild(t => {
                const r = Hn(t);r instanceof ee ? e = r : !e && r ? e = new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && r && e !== r && (e = new ee("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e;
        }class Wn {
            constructor(t, e, r, n) {
                this.message = (t ? `${t}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);
            }
        }function Jn(t) {
            const e = t.key,
                  r = t.value,
                  n = t.valueSpec || {},
                  i = t.objectElementValidators || {},
                  s = t.style,
                  a = t.styleSpec;let o = [];const l = Dn(r);if ("object" !== l) return [new Wn(e, r, `object expected, ${l} found`)];for (const t in r) {
                const l = t.split(".")[0],
                      u = n[l] || n["*"];let c;i[l] ? c = i[l] : n[l] ? c = Ci : i["*"] ? c = i["*"] : n["*"] && (c = Ci), c ? o = o.concat(c({ key: (e ? `${e}.` : e) + t, value: r[t], valueSpec: u, style: s, styleSpec: a, object: r, objectKey: t }, r)) : o.push(new Wn(e, r[t], `unknown property "${t}"`));
            }for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && o.push(new Wn(e, r, `missing required property "${t}"`));return o;
        }function Qn(t) {
            const e = t.value,
                  r = t.valueSpec,
                  n = t.style,
                  i = t.styleSpec,
                  s = t.key,
                  a = t.arrayElementValidator || Ci;if ("array" !== Dn(e)) return [new Wn(s, e, `array expected, ${Dn(e)} found`)];if (r.length && e.length !== r.length) return [new Wn(s, e, `array length ${r.length} expected, length ${e.length} found`)];if (r["min-length"] && e.length < r["min-length"]) return [new Wn(s, e, `array length at least ${r["min-length"]} expected, length ${e.length} found`)];let o = { type: r.value, values: r.values, minimum: r.minimum, maximum: r.maximum, function: void 0 };i.$version < 7 && (o.function = r.function), "object" === Dn(r.value) && (o = r.value);let l = [];for (let t = 0; t < e.length; t++) l = l.concat(a({ array: e, arrayIndex: t, value: e[t], valueSpec: o, style: n, styleSpec: i, key: `${s}[${t}]` }));return l;
        }function ti(t) {
            const e = t.key,
                  r = t.value,
                  n = t.valueSpec;let i = Dn(r);if ("number" === i && r != r && (i = "NaN"), "number" !== i) return [new Wn(e, r, `number expected, ${i} found`)];if ("minimum" in n) {
                let i = n.minimum;if ("array" === Dn(n.minimum) && (i = n.minimum[t.arrayIndex]), r < i) return [new Wn(e, r, `${r} is less than the minimum value ${i}`)];
            }if ("maximum" in n) {
                let i = n.maximum;if ("array" === Dn(n.maximum) && (i = n.maximum[t.arrayIndex]), r > i) return [new Wn(e, r, `${r} is greater than the maximum value ${i}`)];
            }return [];
        }function ei(t) {
            const e = t.valueSpec,
                  r = Jt(t.value.type);let n,
                i,
                s,
                a = {};const o = "categorical" !== r && void 0 === t.value.property,
                  l = !o,
                  u = "array" === Dn(t.value.stops) && "array" === Dn(t.value.stops[0]) && "object" === Dn(t.value.stops[0][0]),
                  c = Jn({ key: t.key, value: t.value, valueSpec: t.styleSpec.function, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { stops: function (t) {
                        if ("identity" === r) return [new Wn(t.key, t.value, 'identity function may not have a "stops" property')];let e = [];const n = t.value;return e = e.concat(Qn({ key: t.key, value: n, valueSpec: t.valueSpec, style: t.style, styleSpec: t.styleSpec, arrayElementValidator: h })), "array" === Dn(n) && 0 === n.length && e.push(new Wn(t.key, n, "array must have at least one stop")), e;
                    }, default: function (t) {
                        return Ci({ key: t.key, value: t.value, valueSpec: e, style: t.style, styleSpec: t.styleSpec });
                    } } });return "identity" === r && o && c.push(new Wn(t.key, t.value, 'missing required property "property"')), "identity" === r || t.value.stops || c.push(new Wn(t.key, t.value, 'missing required property "stops"')), "exponential" === r && t.valueSpec.expression && !Pn(t.valueSpec) && c.push(new Wn(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (l && !En(t.valueSpec) ? c.push(new Wn(t.key, t.value, "property functions not supported")) : o && !Cn(t.valueSpec) && c.push(new Wn(t.key, t.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== t.value.property || c.push(new Wn(t.key, t.value, '"property" property is required')), c;function h(t) {
                let r = [];const n = t.value,
                      o = t.key;if ("array" !== Dn(n)) return [new Wn(o, n, `array expected, ${Dn(n)} found`)];if (2 !== n.length) return [new Wn(o, n, `array length 2 expected, length ${n.length} found`)];if (u) {
                    if ("object" !== Dn(n[0])) return [new Wn(o, n, `object expected, ${Dn(n[0])} found`)];if (void 0 === n[0].zoom) return [new Wn(o, n, "object stop key must have zoom")];if (void 0 === n[0].value) return [new Wn(o, n, "object stop key must have value")];const e = Jt(n[0].zoom);if ("number" != typeof e) return [new Wn(o, n[0].zoom, "stop zoom values must be numbers")];if (s && s > e) return [new Wn(o, n[0].zoom, "stop zoom values must appear in ascending order")];e !== s && (s = e, i = void 0, a = {}), r = r.concat(Jn({ key: `${o}[0]`, value: n[0], valueSpec: { zoom: {} }, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { zoom: ti, value: p } }));
                } else r = r.concat(p({ key: `${o}[0]`, value: n[0], valueSpec: {}, style: t.style, styleSpec: t.styleSpec }, n));return Nn(Qt(n[1])) ? r.concat([new Wn(`${o}[1]`, n[1], "expressions are not allowed in function stops.")]) : r.concat(Ci({ key: `${o}[1]`, value: n[1], valueSpec: e, style: t.style, styleSpec: t.styleSpec }));
            }function p(t, s) {
                const o = Dn(t.value),
                      l = Jt(t.value),
                      u = null !== t.value ? t.value : s;if (n) {
                    if (o !== n) return [new Wn(t.key, u, `${o} stop domain type must match previous stop domain type ${n}`)];
                } else n = o;if ("number" !== o && "string" !== o && "boolean" !== o && "number" != typeof l && "string" != typeof l && "boolean" != typeof l) return [new Wn(t.key, u, "stop domain value must be a number, string, or boolean")];if ("number" !== o && "categorical" !== r) {
                    let n = `number expected, ${o} found`;return En(e) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Wn(t.key, u, n)];
                }return "categorical" !== r || "number" !== o || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && "number" == typeof l && "number" == typeof i && void 0 !== i && l < i ? [new Wn(t.key, u, "stop domain values must appear in ascending order")] : (i = l, "categorical" === r && l in a ? [new Wn(t.key, u, "stop domain values must be unique")] : (a[l] = !0, [])) : [new Wn(t.key, u, `integer expected, found ${String(l)}`)];
            }
        }function ri(t) {
            const e = ("property" === t.expressionContext ? Kn : Gn)(Qt(t.value), t.valueSpec);if ("error" === e.result) return e.value.map(e => new Wn(`${t.key}${e.key}`, t.value, e.message));const r = e.value.expression || e.value._styleExpression.expression;if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined()) return [new Wn(t.key, t.value, `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];if ("property" === t.expressionContext && "layout" === t.propertyType && !gr(r)) return [new Wn(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')];if ("filter" === t.expressionContext) return ni(r, t);if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {
                if (!xr(r, ["zoom", "feature-state"])) return [new Wn(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];if ("cluster-initial" === t.expressionContext && !mr(r)) return [new Wn(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }return [];
        }function ni(t, e) {
            const r = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);if (e.valueSpec && e.valueSpec.expression) for (const t of e.valueSpec.expression.parameters) r.delete(t);if (0 === r.size) return [];const n = [];return t instanceof He && r.has(t.name) ? [new Wn(e.key, e.value, `["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild(t => {
                n.push(...ni(t, e));
            }), n);
        }function ii(t) {
            const e = t.key,
                  r = t.value,
                  n = t.valueSpec,
                  i = [];return Array.isArray(n.values) ? -1 === n.values.indexOf(Jt(r)) && i.push(new Wn(e, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(Jt(r)) && i.push(new Wn(e, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i;
        }function si(t) {
            if (!0 === t || !1 === t) return !0;if (!Array.isArray(t) || 0 === t.length) return !1;switch (t[0]) {case "has":
                    return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];case "in":
                    return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));case "!in":case "!has":case "none":
                    return !1;case "==":case "!=":case ">":case ">=":case "<":case "<=":
                    return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);case "any":case "all":
                    for (const e of t.slice(1)) if (!si(e) && "boolean" != typeof e) return !1;return !0;default:
                    return !0;}
        }function ai(t, e = "fill") {
            if (null == t) return { filter: () => !0, needGeometry: !1, needFeature: !1 };si(t) || (t = fi(t));const r = t;let n = !0;try {
                n = function (t) {
                    if (!ui(t)) return t;let e = Qt(t);return li(e), e = oi(e), e;
                }(r);
            } catch (t) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `);
            }const i = Ht[`filter_${e}`],
                  s = Gn(n, i);let a = null;if ("error" === s.result) throw new Error(s.value.map(t => `${t.key}: ${t.message}`).join(", "));a = (t, e, r) => s.value.evaluate(t, e, {}, r);let o = null,
                l = null;if (n !== r) {
                const t = Gn(r, i);if ("error" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(", "));o = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s), l = !mr(t.value.expression);
            }return { filter: a, dynamicFilter: o || void 0, needGeometry: pi(n), needFeature: !!l };
        }function oi(t) {
            if (!Array.isArray(t)) return t;const e = function (t) {
                if (ci.has(t[0])) for (let e = 1; e < t.length; e++) if (ui(t[e])) return !0;return t;
            }(t);return !0 === e ? e : e.map(t => oi(t));
        }function li(t) {
            let e = !1;const r = [];if ("case" === t[0]) {
                for (let n = 1; n < t.length - 1; n += 2) e = e || ui(t[n]), r.push(t[n + 1]);r.push(t[t.length - 1]);
            } else if ("match" === t[0]) {
                e = e || ui(t[1]);for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);r.push(t[t.length - 1]);
            } else if ("step" === t[0]) {
                e = e || ui(t[1]);for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);
            }e && (t.length = 0, t.push("any", ...r));for (let e = 1; e < t.length; e++) li(t[e]);
        }function ui(t) {
            if (!Array.isArray(t)) return !1;if ("pitch" === (e = t[0]) || "distance-from-center" === e) return !0;var e;for (let e = 1; e < t.length; e++) if (ui(t[e])) return !0;return !1;
        }const ci = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);function hi(t, e) {
            return t < e ? -1 : t > e ? 1 : 0;
        }function pi(t) {
            if (!Array.isArray(t)) return !1;if ("within" === t[0]) return !0;for (let e = 1; e < t.length; e++) if (pi(t[e])) return !0;return !1;
        }function fi(t) {
            if (!t) return !0;const e = t[0];return t.length <= 1 ? "any" !== e : "==" === e ? di(t[1], t[2], "==") : "!=" === e ? gi(di(t[1], t[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? di(t[1], t[2], e) : "any" === e ? (r = t.slice(1), ["any"].concat(r.map(fi))) : "all" === e ? ["all"].concat(t.slice(1).map(fi)) : "none" === e ? ["all"].concat(t.slice(1).map(fi).map(gi)) : "in" === e ? yi(t[1], t.slice(2)) : "!in" === e ? gi(yi(t[1], t.slice(2))) : "has" === e ? mi(t[1]) : "!has" === e ? gi(mi(t[1])) : "within" !== e || t;var r;
        }function di(t, e, r) {
            switch (t) {case "$type":
                    return [`filter-type-${r}`, e];case "$id":
                    return [`filter-id-${r}`, e];default:
                    return [`filter-${r}`, t, e];}
        }function yi(t, e) {
            if (0 === e.length) return !1;switch (t) {case "$type":
                    return ["filter-type-in", ["literal", e]];case "$id":
                    return ["filter-id-in", ["literal", e]];default:
                    return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? ["filter-in-large", t, ["literal", e.sort(hi)]] : ["filter-in-small", t, ["literal", e]];}
        }function mi(t) {
            switch (t) {case "$type":
                    return !0;case "$id":
                    return ["filter-has-id"];default:
                    return ["filter-has", t];}
        }function gi(t) {
            return ["!", t];
        }function xi(t) {
            return si(Qt(t.value)) ? ri(Wt({}, t, { expressionContext: "filter", valueSpec: t.styleSpec[`filter_${t.layerType || "fill"}`] })) : vi(t);
        }function vi(t) {
            const e = t.value,
                  r = t.key;if ("array" !== Dn(e)) return [new Wn(r, e, `array expected, ${Dn(e)} found`)];const n = t.styleSpec;let i,
                s = [];if (e.length < 1) return [new Wn(r, e, "filter array must have at least 1 element")];switch (s = s.concat(ii({ key: `${r}[0]`, value: e[0], valueSpec: n.filter_operator, style: t.style, styleSpec: t.styleSpec })), Jt(e[0])) {case "<":case "<=":case ">":case ">=":
                    e.length >= 2 && "$type" === Jt(e[1]) && s.push(new Wn(r, e, `"$type" cannot be use with operator "${e[0]}"`));case "==":case "!=":
                    3 !== e.length && s.push(new Wn(r, e, `filter array for operator "${e[0]}" must have 3 elements`));case "in":case "!in":
                    e.length >= 2 && (i = Dn(e[1]), "string" !== i && s.push(new Wn(`${r}[1]`, e[1], `string expected, ${i} found`)));for (let a = 2; a < e.length; a++) i = Dn(e[a]), "$type" === Jt(e[1]) ? s = s.concat(ii({ key: `${r}[${a}]`, value: e[a], valueSpec: n.geometry_type, style: t.style, styleSpec: t.styleSpec })) : "string" !== i && "number" !== i && "boolean" !== i && s.push(new Wn(`${r}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`));break;case "any":case "all":case "none":
                    for (let n = 1; n < e.length; n++) s = s.concat(vi({ key: `${r}[${n}]`, value: e[n], style: t.style, styleSpec: t.styleSpec }));break;case "has":case "!has":
                    i = Dn(e[1]), 2 !== e.length ? s.push(new Wn(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : "string" !== i && s.push(new Wn(`${r}[1]`, e[1], `string expected, ${i} found`));break;case "within":
                    i = Dn(e[1]), 2 !== e.length ? s.push(new Wn(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : "object" !== i && s.push(new Wn(`${r}[1]`, e[1], `object expected, ${i} found`));}return s;
        }function bi(t, e) {
            const r = t.key,
                  n = t.style,
                  i = t.styleSpec,
                  s = t.value,
                  a = t.objectKey,
                  o = i[`${e}_${t.layerType}`];if (!o) return [];const l = a.match(/^(.*)-transition$/);if ("paint" === e && l && o[l[1]] && o[l[1]].transition) return Ci({ key: r, value: s, valueSpec: i.transition, style: n, styleSpec: i });const u = t.valueSpec || o[a];if (!u) return [new Wn(r, s, `unknown property "${a}"`)];let c;if ("string" === Dn(s) && En(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) return [new Wn(r, s, `"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c[1])} }\`.`)];const h = [];return "symbol" === t.layerType && ("text-field" === a && n && !n.glyphs && h.push(new Wn(r, s, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && Vn(Qt(s)) && "identity" === Jt(s.type) && h.push(new Wn(r, s, '"text-font" does not support identity functions'))), h.concat(Ci({ key: t.key, value: s, valueSpec: u, style: n, styleSpec: i, expressionContext: "property", propertyType: e, propertyKey: a }));
        }function wi(t) {
            return bi(t, "paint");
        }function _i(t) {
            return bi(t, "layout");
        }function Ai(t) {
            let e = [];const r = t.value,
                  n = t.key,
                  i = t.style,
                  s = t.styleSpec;r.type || r.ref || e.push(new Wn(n, r, 'either "type" or "ref" is required'));let a = Jt(r.type);const o = Jt(r.ref);if (r.id) {
                const s = Jt(r.id);for (let a = 0; a < t.arrayIndex; a++) {
                    const t = i.layers[a];Jt(t.id) === s && e.push(new Wn(n, r.id, `duplicate layer id "${r.id}", previously used at line ${t.id.__line__}`));
                }
            }if ("ref" in r) {
                let t;["type", "source", "source-layer", "filter", "layout"].forEach(t => {
                    t in r && e.push(new Wn(n, r[t], `"${t}" is prohibited for ref layers`));
                }), i.layers.forEach(e => {
                    Jt(e.id) === o && (t = e);
                }), t ? t.ref ? e.push(new Wn(n, r.ref, "ref cannot reference another ref layer")) : a = Jt(t.type) : "string" == typeof o && e.push(new Wn(n, r.ref, `ref layer "${o}" not found`));
            } else if ("background" !== a && "sky" !== a) if (r.source) {
                const t = i.sources && i.sources[r.source],
                      s = t && Jt(t.type);t ? "vector" === s && "raster" === a ? e.push(new Wn(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster" === s && "raster" !== a ? e.push(new Wn(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== s || r["source-layer"] ? "raster-dem" === s && "hillshade" !== a ? e.push(new Wn(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !r.paint || !r.paint["line-gradient"] && !r.paint["line-trim-offset"] || "geojson" === s && t.lineMetrics || e.push(new Wn(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new Wn(n, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new Wn(n, r.source, `source "${r.source}" not found`));
            } else e.push(new Wn(n, r, 'missing required property "source"'));return e = e.concat(Jn({ key: n, value: r, valueSpec: s.layer, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": () => [], type: () => Ci({ key: `${n}.type`, value: r.type, valueSpec: s.layer.type, style: t.style, styleSpec: t.styleSpec, object: r, objectKey: "type" }), filter: t => xi(Wt({ layerType: a }, t)), layout: t => Jn({ layer: r, key: t.key, value: t.value, valueSpec: {}, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": t => _i(Wt({ layerType: a }, t)) } }), paint: t => Jn({ layer: r, key: t.key, value: t.value, valueSpec: {}, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": t => wi(Wt({ layerType: a }, t)) } }) } })), e;
        }function Si(t) {
            const e = t.value,
                  r = t.key,
                  n = Dn(e);return "string" !== n ? [new Wn(r, e, `string expected, ${n} found`)] : [];
        }const ki = { promoteId: function ({ key: t, value: e }) {
                if ("string" === Dn(e)) return Si({ key: t, value: e });{
                    const r = [];for (const n in e) r.push(...Si({ key: `${t}.${n}`, value: e[n] }));return r;
                }
            } };function Ii(t) {
            const e = t.value,
                  r = t.key,
                  n = t.styleSpec,
                  i = t.style;if (!e.type) return [new Wn(r, e, '"type" is required')];const s = Jt(e.type);let a;switch (s) {case "vector":case "raster":case "raster-dem":
                    return a = Jn({ key: r, value: e, valueSpec: n[`source_${s.replace("-", "_")}`], style: t.style, styleSpec: n, objectElementValidators: ki }), a;case "geojson":
                    if (a = Jn({ key: r, value: e, valueSpec: n.source_geojson, style: i, styleSpec: n, objectElementValidators: ki }), e.cluster) for (const t in e.clusterProperties) {
                        const [n, i] = e.clusterProperties[t],
                              s = "string" == typeof n ? [n, ["accumulated"], ["get", t]] : n;a.push(...ri({ key: `${r}.${t}.map`, value: i, expressionContext: "cluster-map" })), a.push(...ri({ key: `${r}.${t}.reduce`, value: s, expressionContext: "cluster-reduce" }));
                    }return a;case "video":
                    return Jn({ key: r, value: e, valueSpec: n.source_video, style: i, styleSpec: n });case "image":
                    return Jn({ key: r, value: e, valueSpec: n.source_image, style: i, styleSpec: n });case "canvas":
                    return [new Wn(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];default:
                    return ii({ key: `${r}.type`, value: e.type, valueSpec: { values: Mi(n) }, style: i, styleSpec: n });}
        }function Mi(t) {
            return t.source.reduce((e, r) => {
                const n = t[r];return "enum" === n.type.type && (e = e.concat(Object.keys(n.type.values))), e;
            }, []);
        }function Ti(t) {
            const e = t.value,
                  r = t.styleSpec,
                  n = r.light,
                  i = t.style;let s = [];const a = Dn(e);if (void 0 === e) return s;if ("object" !== a) return s = s.concat([new Wn("light", e, `object expected, ${a} found`)]), s;for (const t in e) {
                const a = t.match(/^(.*)-transition$/);s = s.concat(a && n[a[1]] && n[a[1]].transition ? Ci({ key: t, value: e[t], valueSpec: r.transition, style: i, styleSpec: r }) : n[t] ? Ci({ key: t, value: e[t], valueSpec: n[t], style: i, styleSpec: r }) : [new Wn(t, e[t], `unknown property "${t}"`)]);
            }return s;
        }function zi(t) {
            const e = t.value,
                  r = t.key,
                  n = t.style,
                  i = t.styleSpec,
                  s = i.terrain;let a = [];const o = Dn(e);if (void 0 === e) return a;if ("object" !== o) return a = a.concat([new Wn("terrain", e, `object expected, ${o} found`)]), a;for (const t in e) {
                const r = t.match(/^(.*)-transition$/);a = a.concat(r && s[r[1]] && s[r[1]].transition ? Ci({ key: t, value: e[t], valueSpec: i.transition, style: n, styleSpec: i }) : s[t] ? Ci({ key: t, value: e[t], valueSpec: s[t], style: n, styleSpec: i }) : [new Wn(t, e[t], `unknown property "${t}"`)]);
            }if (e.source) {
                const t = n.sources && n.sources[e.source],
                      i = t && Jt(t.type);t ? "raster-dem" !== i && a.push(new Wn(r, e.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)) : a.push(new Wn(r, e.source, `source "${e.source}" not found`));
            } else a.push(new Wn(r, e, 'terrain is missing required property "source"'));return a;
        }function Bi(t) {
            const e = t.value,
                  r = t.style,
                  n = t.styleSpec,
                  i = n.fog;let s = [];const a = Dn(e);if (void 0 === e) return s;if ("object" !== a) return s = s.concat([new Wn("fog", e, `object expected, ${a} found`)]), s;for (const t in e) {
                const a = t.match(/^(.*)-transition$/);s = s.concat(a && i[a[1]] && i[a[1]].transition ? Ci({ key: t, value: e[t], valueSpec: n.transition, style: r, styleSpec: n }) : i[t] ? Ci({ key: t, value: e[t], valueSpec: i[t], style: r, styleSpec: n }) : [new Wn(t, e[t], `unknown property "${t}"`)]);
            }return s;
        }const Ei = { "*": () => [], array: Qn, boolean: function (t) {
                const e = t.value,
                      r = t.key,
                      n = Dn(e);return "boolean" !== n ? [new Wn(r, e, `boolean expected, ${n} found`)] : [];
            }, number: ti, color: function (t) {
                const e = t.key,
                      r = t.value,
                      n = Dn(r);return "string" !== n ? [new Wn(e, r, `color expected, ${n} found`)] : null === be(r) ? [new Wn(e, r, `color expected, "${r}" found`)] : [];
            }, enum: ii, filter: xi, function: ei, layer: Ai, object: Jn, source: Ii, light: Ti, terrain: zi, fog: Bi, string: Si, formatted: function (t) {
                return 0 === Si(t).length ? [] : ri(t);
            }, resolvedImage: function (t) {
                return 0 === Si(t).length ? [] : ri(t);
            }, projection: function (t) {
                const e = t.value,
                      r = t.styleSpec,
                      n = r.projection,
                      i = t.style;let s = [];const a = Dn(e);if ("object" === a) for (const t in e) s = s.concat(Ci({ key: t, value: e[t], valueSpec: n[t], style: i, styleSpec: r }));else "string" !== a && (s = s.concat([new Wn("projection", e, `object or string expected, ${a} found`)]));return s;
            } };function Ci(t) {
            const e = t.value,
                  r = t.valueSpec,
                  n = t.styleSpec;return r.expression && Vn(Jt(e)) ? ei(t) : r.expression && Nn(Qt(e)) ? ri(t) : r.type && Ei[r.type] ? Ei[r.type](t) : Jn(Wt({}, t, { valueSpec: r.type ? n[r.type] : r }));
        }function Pi(t) {
            const e = t.value,
                  r = t.key,
                  n = Si(t);return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new Wn(r, e, '"glyphs" url must include a "{fontstack}" token')), -1 === e.indexOf("{range}") && n.push(new Wn(r, e, '"glyphs" url must include a "{range}" token'))), n;
        }function Di(t, e = Ht) {
            return Fi(Ci({ key: "", value: t, valueSpec: e.$root, styleSpec: e, style: t, objectElementValidators: { glyphs: Pi, "*": () => [] } }));
        }const Vi = t => Fi(wi(t)),
              Li = t => Fi(_i(t));function Fi(t) {
            return t.slice().sort((t, e) => t.line && e.line ? t.line - e.line : 0);
        }function Ri(t, e) {
            let r = !1;if (e && e.length) for (const n of e) t.fire(new Kt(new Error(n.message))), r = !0;return r;
        }var ji = Ui;function Ui(t, e, r) {
            var n = this.cells = [];if (t instanceof ArrayBuffer) {
                this.arrayBuffer = t;var i = new Int32Array(this.arrayBuffer);t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);for (var s = 0; s < this.d * this.d; s++) {
                    var a = i[3 + s],
                        o = i[3 + s + 1];n.push(a === o ? null : i.subarray(a, o));
                }var l = i[3 + n.length + 1];this.keys = i.subarray(i[3 + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;
            } else {
                this.d = e + 2 * r;for (var u = 0; u < this.d * this.d; u++) n.push([]);this.keys = [], this.bboxes = [];
            }this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;var c = r / e * t;this.min = -c, this.max = t + c;
        }Ui.prototype.insert = function (t, e, r, n, i) {
            this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
        }, Ui.prototype._insertReadonly = function () {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, Ui.prototype._insertCell = function (t, e, r, n, i, s) {
            this.cells[i].push(s);
        }, Ui.prototype.query = function (t, e, r, n, i) {
            var s = this.min,
                a = this.max;if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);var o = [];return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i), o;
        }, Ui.prototype._queryCell = function (t, e, r, n, i, s, a, o) {
            var l = this.cells[i];if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {
                var p = l[h];if (void 0 === a[p]) {
                    var f = 4 * p;(o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;
                }
            }
        }, Ui.prototype._forEachCell = function (t, e, r, n, i, s, a, o) {
            for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var f = u; f <= h; f++) {
                var d = this.d * f + p;if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, s, a, o)) return;
            }
        }, Ui.prototype._convertFromCellCoord = function (t) {
            return (t - this.padding) / this.scale;
        }, Ui.prototype._convertToCellCoord = function (t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
        }, Ui.prototype.toArrayBuffer = function () {
            if (this.arrayBuffer) return this.arrayBuffer;for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);i[0] = this.extent, i[1] = this.n, i[2] = this.padding;for (var s = e, a = 0; a < t.length; a++) {
                var o = t[a];i[3 + a] = s, i.set(o, s), s += o.length;
            }return i[3 + t.length] = s, i.set(this.keys, s), i[3 + t.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;
        };const $i = {};function Oi(t, e, r = {}) {
            Object.defineProperty(t, "_classRegistryKey", { value: e, writeable: !1 }), $i[e] = { klass: t, omit: r.omit || [] };
        }Oi(Object, "Object"), ji.serialize = function (t, e) {
            const r = t.toArrayBuffer();return e && e.push(r), { buffer: r };
        }, ji.deserialize = function (t) {
            return new ji(t.buffer);
        }, Object.defineProperty(ji, "name", { value: "Grid" }), Oi(ji, "Grid"), Oi(Me, "Color"), Oi(Error, "Error"), Oi(at, "AJAXError"), Oi(Ee, "ResolvedImage"), Oi(Yn, "StylePropertyFunction"), Oi(qn, "StyleExpression", { omit: ["_evaluator"] }), Oi(Zn, "ZoomDependentExpression"), Oi(Xn, "ZoomConstantExpression"), Oi(He, "CompoundExpression", { omit: ["_evaluate"] });for (const t in Tn) $i[Tn[t]._classRegistryKey] || Oi(Tn[t], `Expression${t}`);function qi(t) {
            return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name);
        }function Ni(t) {
            return e.ImageBitmap && t instanceof e.ImageBitmap;
        }function Gi(t, r) {
            if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;if (qi(t) || Ni(t)) return r && r.push(t), t;if (ArrayBuffer.isView(t)) {
                const e = t;return r && r.push(e.buffer), e;
            }if (t instanceof e.ImageData) return r && r.push(t.data.buffer), t;if (Array.isArray(t)) {
                const e = [];for (const n of t) e.push(Gi(n, r));return e;
            }if ("object" == typeof t) {
                const e = t.constructor,
                      n = e._classRegistryKey;if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);const i = e.serialize ? e.serialize(t, r) : {};if (!e.serialize) {
                    for (const e in t) t.hasOwnProperty(e) && ($i[n].omit.indexOf(e) >= 0 || (i[e] = Gi(t[e], r)));t instanceof Error && (i.message = t.message);
                }if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");return "Object" !== n && (i.$name = n), i;
            }throw new Error("can't serialize object of type " + typeof t);
        }function Xi(t) {
            if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || qi(t) || Ni(t) || ArrayBuffer.isView(t) || t instanceof e.ImageData) return t;if (Array.isArray(t)) return t.map(Xi);if ("object" == typeof t) {
                const e = t.$name || "Object",
                      { klass: r } = $i[e];if (!r) throw new Error(`can't deserialize unregistered class ${e}`);if (r.deserialize) return r.deserialize(t);const n = Object.create(r.prototype);for (const e of Object.keys(t)) "$name" !== e && (n[e] = Xi(t[e]));return n;
            }throw new Error("can't deserialize object of type " + typeof t);
        }const Zi = t => t >= 1536 && t <= 1791,
              Ki = t => t >= 1872 && t <= 1919,
              Yi = t => t >= 2208 && t <= 2303,
              Hi = t => t >= 11904 && t <= 12031,
              Wi = t => t >= 12032 && t <= 12255,
              Ji = t => t >= 12272 && t <= 12287,
              Qi = t => t >= 12288 && t <= 12351,
              ts = t => t >= 12352 && t <= 12447,
              es = t => t >= 12448 && t <= 12543,
              rs = t => t >= 12544 && t <= 12591,
              ns = t => t >= 12704 && t <= 12735,
              is = t => t >= 12736 && t <= 12783,
              ss = t => t >= 12784 && t <= 12799,
              as = t => t >= 12800 && t <= 13055,
              os = t => t >= 13056 && t <= 13311,
              ls = t => t >= 13312 && t <= 19903,
              us = t => t >= 19968 && t <= 40959,
              cs = t => t >= 40960 && t <= 42127,
              hs = t => t >= 42128 && t <= 42191,
              ps = t => t >= 44032 && t <= 55215,
              fs = t => t >= 63744 && t <= 64255,
              ds = t => t >= 64336 && t <= 65023,
              ys = t => t >= 65040 && t <= 65055,
              ms = t => t >= 65072 && t <= 65103,
              gs = t => t >= 65104 && t <= 65135,
              xs = t => t >= 65136 && t <= 65279,
              vs = t => t >= 65280 && t <= 65519;function bs(t) {
            for (const e of t) if (As(e.charCodeAt(0))) return !0;return !1;
        }function ws(t) {
            for (const e of t) if (!_s(e.charCodeAt(0))) return !1;return !0;
        }function _s(t) {
            return !(Zi(t) || Ki(t) || Yi(t) || ds(t) || xs(t));
        }function As(t) {
            return !(746 !== t && 747 !== t && (t < 4352 || !(ns(t) || rs(t) || ms(t) && !(t >= 65097 && t <= 65103) || fs(t) || os(t) || Hi(t) || is(t) || !(!Qi(t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || ls(t) || us(t) || as(t) || (t => t >= 12592 && t <= 12687)(t) || (t => t >= 43360 && t <= 43391)(t) || (t => t >= 55216 && t <= 55295)(t) || (t => t >= 4352 && t <= 4607)(t) || ps(t) || ts(t) || Ji(t) || (t => t >= 12688 && t <= 12703)(t) || Wi(t) || ss(t) || es(t) && 12540 !== t || !(!vs(t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!gs(t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || (t => t >= 5120 && t <= 5759)(t) || (t => t >= 6320 && t <= 6399)(t) || ys(t) || (t => t >= 19904 && t <= 19967)(t) || cs(t) || hs(t))));
        }function Ss(t) {
            return !(As(t) || function (t) {
                return !!((t => t >= 128 && t <= 255)(t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || (t => t >= 8192 && t <= 8303)(t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || (t => t >= 8448 && t <= 8527)(t) || (t => t >= 8528 && t <= 8591)(t) || (t => t >= 8960 && t <= 9215)(t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || (t => t >= 9216 && t <= 9279)(t) && 9251 !== t || (t => t >= 9280 && t <= 9311)(t) || (t => t >= 9312 && t <= 9471)(t) || (t => t >= 9632 && t <= 9727)(t) || (t => t >= 9728 && t <= 9983)(t) && !(t >= 9754 && t <= 9759) || (t => t >= 11008 && t <= 11263)(t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Qi(t) || es(t) || (t => t >= 57344 && t <= 63743)(t) || ms(t) || gs(t) || vs(t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);
            }(t));
        }function ks(t) {
            return t >= 1424 && t <= 2303 || ds(t) || xs(t);
        }function Is(t, e) {
            return !(!e && ks(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || (t => t >= 6016 && t <= 6143)(t));
        }function Ms(t) {
            for (const e of t) if (ks(e.charCodeAt(0))) return !0;return !1;
        }const Ts = "deferred",
              zs = "loading",
              Bs = "loaded";let Es = null,
            Cs = "unavailable",
            Ps = null;const Ds = function (t) {
            t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (Cs = "error"), Es && Es(t);
        };function Vs() {
            Ls.fire(new Zt("pluginStateChange", { pluginStatus: Cs, pluginURL: Ps }));
        }const Ls = new Yt(),
              Fs = function () {
            return Cs;
        },
              Rs = function () {
            if (Cs !== Ts || !Ps) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");Cs = zs, Vs(), Ps && ut({ url: Ps }, t => {
                t ? Ds(t) : (Cs = Bs, Vs());
            });
        },
              js = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Cs === Bs || null != js.applyArabicShaping, isLoading: () => Cs === zs, setState(t) {
                Cs = t.pluginStatus, Ps = t.pluginURL;
            }, isParsed: () => null != js.applyArabicShaping && null != js.processBidirectionalText && null != js.processStyledBidirectionalText, getPluginURL: () => Ps };class Us {
            constructor(t, e) {
                this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
            }isSupportedScript(t) {
                return function (t, e) {
                    for (const r of t) if (!Is(r.charCodeAt(0), e)) return !1;return !0;
                }(t, js.isLoaded());
            }
        }class $s {
            constructor(t, e) {
                this.property = t, this.value = e, this.expression = function (t, e) {
                    if (Vn(t)) return new Yn(t, e);if (Nn(t)) {
                        const r = Kn(t, e);if ("error" === r.result) throw new Error(r.value.map(t => `${t.key}: ${t.message}`).join(", "));return r.value;
                    }{
                        let r = t;return "string" == typeof t && "color" === e.type && (r = Me.parse(t)), { kind: "constant", evaluate: () => r };
                    }
                }(void 0 === e ? t.specification.default : e, t.specification);
            }isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }possiblyEvaluate(t, e, r) {
                return this.property.possiblyEvaluate(this, t, e, r);
            }
        }class Os {
            constructor(t) {
                this.property = t, this.value = new $s(t, void 0);
            }transitioned(t, e) {
                return new Ns(this.property, this.value, e, z({}, t.transition, this.transition), t.now);
            }untransitioned() {
                return new Ns(this.property, this.value, null, {}, 0);
            }
        }class qs {
            constructor(t) {
                this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
            }getValue(t) {
                return j(this._values[t].value.value);
            }setValue(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Os(this._values[t].property)), this._values[t].value = new $s(this._values[t].property, null === e ? void 0 : j(e));
            }getTransition(t) {
                return j(this._values[t].transition);
            }setTransition(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Os(this._values[t].property)), this._values[t].transition = j(e) || void 0;
            }serialize() {
                const t = {};for (const e of Object.keys(this._values)) {
                    const r = this.getValue(e);void 0 !== r && (t[e] = r);const n = this.getTransition(e);void 0 !== n && (t[`${e}-transition`] = n);
                }return t;
            }transitioned(t, e) {
                const r = new Gs(this._properties);for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);return r;
            }untransitioned() {
                const t = new Gs(this._properties);for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();return t;
            }
        }class Ns {
            constructor(t, e, r, n, i) {
                const s = n.delay || 0,
                      a = n.duration || 0;i = i || 0, this.property = t, this.value = e, this.begin = i + s, this.end = this.begin + a, t.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }possiblyEvaluate(t, e, r) {
                const n = t.now || 0,
                      i = this.value.possiblyEvaluate(t, e, r),
                      s = this.prior;if (s) {
                    if (n > this.end) return this.prior = null, i;if (this.value.isDataDriven()) return this.prior = null, i;if (n < this.begin) return s.possiblyEvaluate(t, e, r);{
                        const a = (n - this.begin) / (this.end - this.begin);return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, w(a));
                    }
                }return i;
            }
        }class Gs {
            constructor(t) {
                this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
            }possiblyEvaluate(t, e, r) {
                const n = new Ks(this._properties);for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);return n;
            }hasTransition() {
                for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;return !1;
            }
        }class Xs {
            constructor(t) {
                this._properties = t, this._values = Object.create(t.defaultPropertyValues);
            }getValue(t) {
                return j(this._values[t].value);
            }setValue(t, e) {
                this._values[t] = new $s(this._values[t].property, null === e ? void 0 : j(e));
            }serialize() {
                const t = {};for (const e of Object.keys(this._values)) {
                    const r = this.getValue(e);void 0 !== r && (t[e] = r);
                }return t;
            }possiblyEvaluate(t, e, r) {
                const n = new Ks(this._properties);for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);return n;
            }
        }class Zs {
            constructor(t, e, r) {
                this.property = t, this.value = e, this.parameters = r;
            }isConstant() {
                return "constant" === this.value.kind;
            }constantOr(t) {
                return "constant" === this.value.kind ? this.value.value : t;
            }evaluate(t, e, r, n) {
                return this.property.evaluate(this.value, this.parameters, t, e, r, n);
            }
        }class Ks {
            constructor(t) {
                this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
            }get(t) {
                return this._values[t];
            }
        }class Ys {
            constructor(t) {
                this.specification = t;
            }possiblyEvaluate(t, e) {
                return t.expression.evaluate(e);
            }interpolate(t, e, r) {
                const n = Tr[this.specification.type];return n ? n(t, e, r) : t;
            }
        }class Hs {
            constructor(t, e) {
                this.specification = t, this.overrides = e;
            }possiblyEvaluate(t, e, r, n) {
                return new Zs(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? { kind: "constant", value: t.expression.evaluate(e, null, {}, r, n) } : t.expression, e);
            }interpolate(t, e, r) {
                if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t;if (void 0 === t.value.value || void 0 === e.value.value) return new Zs(this, { kind: "constant", value: void 0 }, t.parameters);const n = Tr[this.specification.type];return n ? new Zs(this, { kind: "constant", value: n(t.value.value, e.value.value, r) }, t.parameters) : t;
            }evaluate(t, e, r, n, i, s) {
                return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, s);
            }
        }class Ws {
            constructor(t) {
                this.specification = t;
            }possiblyEvaluate(t, e, r, n) {
                return !!t.expression.evaluate(e, null, {}, r, n);
            }interpolate() {
                return !1;
            }
        }class Js {
            constructor(t) {
                this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];const e = new Us(0, {});for (const r in t) {
                    const n = t[r];n.specification.overridable && this.overridableProperties.push(r);const i = this.defaultPropertyValues[r] = new $s(n, void 0),
                          s = this.defaultTransitionablePropertyValues[r] = new Os(n);this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);
                }
            }
        }function Qs(t, e) {
            return 256 * (t = S(Math.floor(t), 0, 255)) + S(Math.floor(e), 0, 255);
        }Oi(Hs, "DataDrivenProperty"), Oi(Ys, "DataConstantProperty"), Oi(Ws, "ColorRampProperty");const ta = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };class ea {
            constructor(t, e) {
                this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }class ra {
            constructor() {
                this.isTransferred = !1, this.capacity = -1, this.resize(0);
            }static serialize(t, e) {
                return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
            }static deserialize(t) {
                const e = Object.create(this.prototype);return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;
            }_trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }clear() {
                this.length = 0;
            }resize(t) {
                this.reserve(t), this.length = t;
            }reserve(t) {
                if (t > this.capacity) {
                    this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);const e = this.uint8;this._refreshViews(), e && this.uint8.set(e);
                }
            }_refreshViews() {
                throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }function na(t, e = 1) {
            let r = 0,
                n = 0;return { members: t.map(t => {
                    const i = ta[t.type].BYTES_PER_ELEMENT,
                          s = r = ia(r, Math.max(e, i)),
                          a = t.components || 1;return n = Math.max(n, i), r += i * a, { name: t.name, type: t.type, components: a, offset: s };
                }), size: ia(r, Math.max(n, e)), alignment: e };
        }function ia(t, e) {
            return Math.ceil(t / e) * e;
        }class sa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }emplaceBack(t, e) {
                const r = this.length;return this.resize(r + 1), this.emplace(r, t, e);
            }emplace(t, e, r) {
                const n = 2 * t;return this.int16[n + 0] = e, this.int16[n + 1] = r, t;
            }
        }sa.prototype.bytesPerElement = 4, Oi(sa, "StructArrayLayout2i4");class aa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }emplaceBack(t, e, r) {
                const n = this.length;return this.resize(n + 1), this.emplace(n, t, e, r);
            }emplace(t, e, r, n) {
                const i = 3 * t;return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;
            }
        }aa.prototype.bytesPerElement = 6, Oi(aa, "StructArrayLayout3i6");class oa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n) {
                const i = this.length;return this.resize(i + 1), this.emplace(i, t, e, r, n);
            }emplace(t, e, r, n, i) {
                const s = 4 * t;return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;
            }
        }oa.prototype.bytesPerElement = 8, Oi(oa, "StructArrayLayout4i8");class la extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s, a) {
                const o = this.length;return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
            }emplace(t, e, r, n, i, s, a, o) {
                const l = 6 * t,
                      u = 12 * t,
                      c = 3 * t;return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t;
            }
        }la.prototype.bytesPerElement = 12, Oi(la, "StructArrayLayout2i4ub1f12");class ua extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n) {
                const i = this.length;return this.resize(i + 1), this.emplace(i, t, e, r, n);
            }emplace(t, e, r, n, i) {
                const s = 4 * t;return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;
            }
        }ua.prototype.bytesPerElement = 16, Oi(ua, "StructArrayLayout4f16");class ca extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i) {
                const s = this.length;return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
            }emplace(t, e, r, n, i, s) {
                const a = 6 * t,
                      o = 3 * t;return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t;
            }
        }ca.prototype.bytesPerElement = 12, Oi(ca, "StructArrayLayout4ui1f12");class ha extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n) {
                const i = this.length;return this.resize(i + 1), this.emplace(i, t, e, r, n);
            }emplace(t, e, r, n, i) {
                const s = 4 * t;return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t;
            }
        }ha.prototype.bytesPerElement = 8, Oi(ha, "StructArrayLayout4ui8");class pa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s) {
                const a = this.length;return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);
            }emplace(t, e, r, n, i, s, a) {
                const o = 6 * t;return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;
            }
        }pa.prototype.bytesPerElement = 12, Oi(pa, "StructArrayLayout6i12");class fa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) {
                const p = this.length;return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, a, o, l, u, c, h);
            }emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f = 12 * t;return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = a, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t;
            }
        }fa.prototype.bytesPerElement = 24, Oi(fa, "StructArrayLayout4i4ui4i24");class da extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s) {
                const a = this.length;return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);
            }emplace(t, e, r, n, i, s, a) {
                const o = 10 * t,
                      l = 5 * t;return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t;
            }
        }da.prototype.bytesPerElement = 20, Oi(da, "StructArrayLayout3i3f20");class ya extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }emplaceBack(t) {
                const e = this.length;return this.resize(e + 1), this.emplace(e, t);
            }emplace(t, e) {
                return this.uint32[1 * t + 0] = e, t;
            }
        }ya.prototype.bytesPerElement = 4, Oi(ya, "StructArrayLayout1ul4");class ma extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f = this.length;return this.resize(f + 1), this.emplace(f, t, e, r, n, i, s, a, o, l, u, c, h, p);
            }emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d = 20 * t,
                      y = 10 * t;return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = s, this.float32[y + 3] = a, this.float32[y + 4] = o, this.float32[y + 5] = l, this.float32[y + 6] = u, this.int16[d + 14] = c, this.uint32[y + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t;
            }
        }ma.prototype.bytesPerElement = 40, Oi(ma, "StructArrayLayout5i4f1i1ul2ui40");class ga extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s, a) {
                const o = this.length;return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
            }emplace(t, e, r, n, i, s, a, o) {
                const l = 8 * t;return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t;
            }
        }ga.prototype.bytesPerElement = 16, Oi(ga, "StructArrayLayout3i2i2i16");class xa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i) {
                const s = this.length;return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
            }emplace(t, e, r, n, i, s) {
                const a = 4 * t,
                      o = 8 * t;return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t;
            }
        }xa.prototype.bytesPerElement = 16, Oi(xa, "StructArrayLayout2f1f2i16");class va extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n) {
                const i = this.length;return this.resize(i + 1), this.emplace(i, t, e, r, n);
            }emplace(t, e, r, n, i) {
                const s = 12 * t,
                      a = 3 * t;return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t;
            }
        }va.prototype.bytesPerElement = 12, Oi(va, "StructArrayLayout2ub2f12");class ba extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e, r) {
                const n = this.length;return this.resize(n + 1), this.emplace(n, t, e, r);
            }emplace(t, e, r, n) {
                const i = 3 * t;return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;
            }
        }ba.prototype.bytesPerElement = 12, Oi(ba, "StructArrayLayout3f12");class wa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }emplaceBack(t, e, r) {
                const n = this.length;return this.resize(n + 1), this.emplace(n, t, e, r);
            }emplace(t, e, r, n) {
                const i = 3 * t;return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;
            }
        }wa.prototype.bytesPerElement = 6, Oi(wa, "StructArrayLayout3ui6");class _a extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b) {
                const w = this.length;return this.resize(w + 1), this.emplace(w, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b);
            }emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w) {
                const _ = 30 * t,
                      A = 15 * t,
                      S = 60 * t;return this.int16[_ + 0] = e, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = a, this.uint16[_ + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = f, this.float32[A + 10] = d, this.float32[A + 11] = y, this.uint8[S + 48] = m, this.uint8[S + 49] = g, this.uint8[S + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[S + 58] = w, t;
            }
        }_a.prototype.bytesPerElement = 60, Oi(_a, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");class Aa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z) {
                const B = this.length;return this.resize(B + 1), this.emplace(B, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z);
            }emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z, B) {
                const E = 38 * t,
                      C = 19 * t;return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.float32[C + 2] = i, this.float32[C + 3] = s, this.int16[E + 8] = a, this.int16[E + 9] = o, this.int16[E + 10] = l, this.int16[E + 11] = u, this.int16[E + 12] = c, this.int16[E + 13] = h, this.uint16[E + 14] = p, this.uint16[E + 15] = f, this.uint16[E + 16] = d, this.uint16[E + 17] = y, this.uint16[E + 18] = m, this.uint16[E + 19] = g, this.uint16[E + 20] = x, this.uint16[E + 21] = v, this.uint16[E + 22] = b, this.uint16[E + 23] = w, this.uint16[E + 24] = _, this.uint16[E + 25] = A, this.uint16[E + 26] = S, this.uint16[E + 27] = k, this.uint16[E + 28] = I, this.uint32[C + 15] = M, this.float32[C + 16] = T, this.float32[C + 17] = z, this.float32[C + 18] = B, t;
            }
        }Aa.prototype.bytesPerElement = 76, Oi(Aa, "StructArrayLayout3i2f6i15ui1ul3f76");class Sa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t) {
                const e = this.length;return this.resize(e + 1), this.emplace(e, t);
            }emplace(t, e) {
                return this.float32[1 * t + 0] = e, t;
            }
        }Sa.prototype.bytesPerElement = 4, Oi(Sa, "StructArrayLayout1f4");class ka extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n, i) {
                const s = this.length;return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
            }emplace(t, e, r, n, i, s) {
                const a = 5 * t;return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t;
            }
        }ka.prototype.bytesPerElement = 20, Oi(ka, "StructArrayLayout5f20");class Ia extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }emplaceBack(t, e, r, n) {
                const i = this.length;return this.resize(i + 1), this.emplace(i, t, e, r, n);
            }emplace(t, e, r, n, i) {
                const s = 6 * t;return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;
            }
        }Ia.prototype.bytesPerElement = 12, Oi(Ia, "StructArrayLayout1ul3ui12");class Ma extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }emplaceBack(t, e) {
                const r = this.length;return this.resize(r + 1), this.emplace(r, t, e);
            }emplace(t, e, r) {
                const n = 2 * t;return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;
            }
        }Ma.prototype.bytesPerElement = 4, Oi(Ma, "StructArrayLayout2ui4");class Ta extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }emplaceBack(t) {
                const e = this.length;return this.resize(e + 1), this.emplace(e, t);
            }emplace(t, e) {
                return this.uint16[1 * t + 0] = e, t;
            }
        }Ta.prototype.bytesPerElement = 2, Oi(Ta, "StructArrayLayout1ui2");class za extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }emplaceBack(t, e) {
                const r = this.length;return this.resize(r + 1), this.emplace(r, t, e);
            }emplace(t, e, r) {
                const n = 2 * t;return this.float32[n + 0] = e, this.float32[n + 1] = r, t;
            }
        }za.prototype.bytesPerElement = 8, Oi(za, "StructArrayLayout2f8");class Ba extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }Ba.prototype.size = 40;class Ea extends ma {
            get(t) {
                return new Ba(this, t);
            }
        }Oi(Ea, "CollisionBoxArray");class Ca extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }set placedOrientation(t) {
                this._structArray.uint8[this._pos1 + 49] = t;
            }get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }set hidden(t) {
                this._structArray.uint8[this._pos1 + 50] = t;
            }get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 13] = t;
            }get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }set flipState(t) {
                this._structArray.uint8[this._pos1 + 58] = t;
            }
        }Ca.prototype.size = 60;class Pa extends _a {
            get(t) {
                return new Ca(this, t);
            }
        }Oi(Pa, "PlacedSymbolArray");class Da extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13];
            }get key() {
                return this._structArray.uint16[this._pos2 + 14];
            }get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23];
            }get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27];
            }get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28];
            }get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15];
            }set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 15] = t;
            }get textOffset0() {
                return this._structArray.float32[this._pos4 + 16];
            }get textOffset1() {
                return this._structArray.float32[this._pos4 + 17];
            }get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18];
            }
        }Da.prototype.size = 76;class Va extends Aa {
            get(t) {
                return new Da(this, t);
            }
        }Oi(Va, "SymbolInstanceArray");class La extends Sa {
            getoffsetX(t) {
                return this.float32[1 * t + 0];
            }
        }Oi(La, "GlyphOffsetArray");class Fa extends sa {
            getx(t) {
                return this.int16[2 * t + 0];
            }gety(t) {
                return this.int16[2 * t + 1];
            }
        }Oi(Fa, "SymbolLineVertexArray");class Ra extends ea {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }Ra.prototype.size = 12;class ja extends Ia {
            get(t) {
                return new Ra(this, t);
            }
        }Oi(ja, "FeatureIndexArray");class Ua extends Ma {
            geta_centroid_pos0(t) {
                return this.uint16[2 * t + 0];
            }geta_centroid_pos1(t) {
                return this.uint16[2 * t + 1];
            }
        }Oi(Ua, "FillExtrusionCentroidArray");const $a = na([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]),
              Oa = na([{ name: "a_dash", components: 4, type: "Uint16" }]);var qa = {},
            Na = { get exports() {
                return qa;
            }, set exports(t) {
                qa = t;
            } },
            Ga = {};({ get exports() {
                return Ga;
            }, set exports(t) {
                Ga = t;
            } }).exports = function (t, e) {
            var r, n, i, s, a, o, l, u;for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);switch (l = 0, r) {case 3:
                    l ^= (255 & t.charCodeAt(u + 2)) << 16;case 2:
                    l ^= (255 & t.charCodeAt(u + 1)) << 8;case 1:
                    i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;}return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
        };var Xa = {};({ get exports() {
                return Xa;
            }, set exports(t) {
                Xa = t;
            } }).exports = function (t, e) {
            for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;switch (n) {case 3:
                    i ^= (255 & t.charCodeAt(s + 2)) << 16;case 2:
                    i ^= (255 & t.charCodeAt(s + 1)) << 8;case 1:
                    i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);}return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
        };var Za = Ga,
            Ka = Xa;Na.exports = Za, qa.murmur3 = Za, qa.murmur2 = Ka;class Ya {
            constructor() {
                this.ids = [], this.positions = [], this.indexed = !1;
            }add(t, e, r, n) {
                this.ids.push(Ha(t)), this.positions.push(e, r, n);
            }getPositions(t) {
                const e = Ha(t);let r = 0,
                    n = this.ids.length - 1;for (; r < n;) {
                    const t = r + n >> 1;this.ids[t] >= e ? n = t : r = t + 1;
                }const i = [];for (; this.ids[r] === e;) i.push({ index: this.positions[3 * r], start: this.positions[3 * r + 1], end: this.positions[3 * r + 2] }), r++;return i;
            }static serialize(t, e) {
                const r = new Float64Array(t.ids),
                      n = new Uint32Array(t.positions);return Wa(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), { ids: r, positions: n };
            }static deserialize(t) {
                const e = new Ya();return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;
            }
        }function Ha(t) {
            const e = +t;return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : qa(String(t));
        }function Wa(t, e, r, n) {
            for (; r < n;) {
                const i = t[r + n >> 1];let s = r - 1,
                    a = n + 1;for (;;) {
                    do {
                        s++;
                    } while (t[s] < i);do {
                        a--;
                    } while (t[a] > i);if (s >= a) break;Ja(t, s, a), Ja(e, 3 * s, 3 * a), Ja(e, 3 * s + 1, 3 * a + 1), Ja(e, 3 * s + 2, 3 * a + 2);
                }a - r < n - a ? (Wa(t, e, r, a), r = a + 1) : (Wa(t, e, a + 1, n), n = a);
            }
        }function Ja(t, e, r) {
            const n = t[e];t[e] = t[r], t[r] = n;
        }Oi(Ya, "FeaturePositionMap");class Qa {
            constructor(t) {
                this.gl = t.gl, this.initialized = !1;
            }fetchUniformLocation(t, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e), this.initialized = !0), !!this.location;
            }
        }class to extends Qa {
            constructor(t) {
                super(t), this.current = 0;
            }set(t, e, r) {
                this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }class eo extends Qa {
            constructor(t) {
                super(t), this.current = [0, 0, 0, 0];
            }set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }class ro extends Qa {
            constructor(t) {
                super(t), this.current = Me.transparent;
            }set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }const no = new Float32Array(16),
              io = new Float32Array(9),
              so = new Float32Array(4);function ao(t) {
            return [Qs(255 * t.r, 255 * t.g), Qs(255 * t.b, 255 * t.a)];
        }class oo {
            constructor(t, e, r) {
                this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;
            }setUniform(t, e, r, n, i) {
                e.set(t, i, n.constantOr(this.value));
            }getBinding(t, e) {
                return "color" === this.type ? new ro(t) : new to(t);
            }
        }class lo {
            constructor(t, e) {
                this.uniformNames = e.map(t => `u_${t}`), this.pattern = null, this.pixelRatio = 1;
            }setConstantPatternPositions(t) {
                this.pixelRatio = t.pixelRatio || 1, this.pattern = t.tl.concat(t.br);
            }setUniform(t, e, r, n, i) {
                const s = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null;s && e.set(t, i, s);
            }getBinding(t, e) {
                return "u_pattern" === e || "u_dash" === e ? new eo(t) : new to(t);
            }
        }class uo {
            constructor(t, e, r, n) {
                this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({ name: `a_${t}`, type: "Float32", components: "color" === r ? 2 : 1, offset: 0 })), this.paintVertexArray = new n();
            }populatePaintArray(t, e, r, n, i, s) {
                const a = this.paintVertexArray.length,
                      o = this.expression.evaluate(new Us(0), e, {}, i, n, s);this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);
            }updatePaintArray(t, e, r, n, i) {
                const s = this.expression.evaluate({ zoom: 0 }, r, n, void 0, i);this._setPaintValue(t, e, s);
            }_setPaintValue(t, e, r) {
                if ("color" === this.type) {
                    const n = ao(r);for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);
                } else {
                    for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }class co {
            constructor(t, e, r, n, i, s) {
                this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({ name: `a_${t}`, type: "Float32", components: "color" === r ? 4 : 2, offset: 0 })), this.paintVertexArray = new s();
            }populatePaintArray(t, e, r, n, i, s) {
                const a = this.expression.evaluate(new Us(this.zoom), e, {}, i, n, s),
                      o = this.expression.evaluate(new Us(this.zoom + 1), e, {}, i, n, s),
                      l = this.paintVertexArray.length;this.paintVertexArray.resize(t), this._setPaintValue(l, t, a, o);
            }updatePaintArray(t, e, r, n, i) {
                const s = this.expression.evaluate({ zoom: this.zoom }, r, n, void 0, i),
                      a = this.expression.evaluate({ zoom: this.zoom + 1 }, r, n, void 0, i);this._setPaintValue(t, e, s, a);
            }_setPaintValue(t, e, r, n) {
                if ("color" === this.type) {
                    const i = ao(r),
                          s = ao(n);for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);
                } else {
                    for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }setUniform(t, e, r, n, i) {
                const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
                      a = S(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);e.set(t, i, a);
            }getBinding(t, e) {
                return new to(t);
            }
        }class ho {
            constructor(t, e, r, n, i) {
                this.expression = t, this.layerId = i, this.paintVertexAttributes = ("array" === r ? Oa : $a).members;for (let t = 0; t < e.length; ++t);this.paintVertexArray = new n();
            }populatePaintArray(t, e, r) {
                const n = this.paintVertexArray.length;this.paintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);
            }updatePaintArray(t, e, r, n, i, s) {
                this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);
            }_setPaintValues(t, e, r, n) {
                if (!n || !r) return;const i = n[r];if (!i) return;const { tl: s, br: a, pixelRatio: o } = i;for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1], o);
            }upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }class po {
            constructor(t, e, r = () => !0) {
                this.binders = {}, this._buffers = [];const n = [];for (const i in t.paint._values) {
                    if (!r(i)) continue;const s = t.paint.get(i);if (!(s instanceof Zs && En(s.property.specification))) continue;const a = mo(i, t.type),
                          o = s.value,
                          l = s.property.specification.type,
                          u = s.property.useIntegerZoom,
                          c = "line-dasharray" === i || i.endsWith("pattern"),
                          h = "line-dasharray" === i && "constant" !== t.layout.get("line-cap").value.kind;if ("constant" !== o.kind || h) {
                        if ("source" === o.kind || h || c) {
                            const e = vo(i, l, "source");this.binders[i] = c ? new ho(o, a, l, e, t.id) : new uo(o, a, l, e), n.push(`/a_${i}`);
                        } else {
                            const t = vo(i, l, "composite");this.binders[i] = new co(o, a, l, u, e, t), n.push(`/z_${i}`);
                        }
                    } else this.binders[i] = c ? new lo(o.value, a) : new oo(o.value, a, l), n.push(`/u_${i}`);
                }this.cacheKey = n.sort().join("");
            }getMaxValue(t) {
                const e = this.binders[t];return e instanceof uo || e instanceof co ? e.maxValue : 0;
            }populatePaintArrays(t, e, r, n, i, s) {
                for (const a in this.binders) {
                    const o = this.binders[a];(o instanceof uo || o instanceof co || o instanceof ho) && o.populatePaintArray(t, e, r, n, i, s);
                }
            }setConstantPatternPositions(t) {
                for (const e in this.binders) {
                    const r = this.binders[e];r instanceof lo && r.setConstantPatternPositions(t);
                }
            }updatePaintArrays(t, e, r, n, i, s) {
                let a = !1;for (const o in t) {
                    const l = e.getPositions(o);for (const e of l) {
                        const l = r.feature(e.index);for (const r in this.binders) {
                            const u = this.binders[r];if ((u instanceof uo || u instanceof co || u instanceof ho) && !0 === u.expression.isStateDependent) {
                                const c = n.paint.get(r);u.expression = c.value, u.updatePaintArray(e.start, e.end, l, t[o], i, s), a = !0;
                            }
                        }
                    }
                }return a;
            }defines() {
                const t = [];for (const e in this.binders) {
                    const r = this.binders[e];(r instanceof oo || r instanceof lo) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));
                }return t;
            }getBinderAttributes() {
                const t = [];for (const e in this.binders) {
                    const r = this.binders[e];if (r instanceof uo || r instanceof co || r instanceof ho) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);
                }return t;
            }getBinderUniforms() {
                const t = [];for (const e in this.binders) {
                    const r = this.binders[e];if (r instanceof oo || r instanceof lo || r instanceof co) for (const e of r.uniformNames) t.push(e);
                }return t;
            }getPaintVertexBuffers() {
                return this._buffers;
            }getUniforms(t) {
                const e = [];for (const r in this.binders) {
                    const n = this.binders[r];if (n instanceof oo || n instanceof lo || n instanceof co) for (const i of n.uniformNames) e.push({ name: i, property: r, binding: n.getBinding(t, i) });
                }return e;
            }setUniforms(t, e, r, n, i) {
                for (const { name: e, property: s, binding: a } of r) this.binders[s].setUniform(t, a, i, n.get(s), e);
            }updatePaintBuffers() {
                this._buffers = [];for (const t in this.binders) {
                    const e = this.binders[t];(e instanceof uo || e instanceof co || e instanceof ho) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer);
                }
            }upload(t) {
                for (const e in this.binders) {
                    const r = this.binders[e];(r instanceof uo || r instanceof co || r instanceof ho) && r.upload(t);
                }this.updatePaintBuffers();
            }destroy() {
                for (const t in this.binders) {
                    const e = this.binders[t];(e instanceof uo || e instanceof co || e instanceof ho) && e.destroy();
                }
            }
        }class fo {
            constructor(t, e, r = () => !0) {
                this.programConfigurations = {};for (const n of t) this.programConfigurations[n.id] = new po(n, e, r);this.needsUpload = !1, this._featureMap = new Ya(), this._bufferOffset = 0;
            }populatePaintArrays(t, e, r, n, i, s, a) {
                for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, a);void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
            }updatePaintArrays(t, e, r, n, i) {
                for (const s of r) this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t, this._featureMap, e, s, n, i) || this.needsUpload;
            }get(t) {
                return this.programConfigurations[t];
            }upload(t) {
                if (this.needsUpload) {
                    for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);this.needsUpload = !1;
                }
            }destroy() {
                for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
            }
        }const yo = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };function mo(t, e) {
            return yo[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")];
        }const go = { "line-pattern": { source: ca, composite: ca }, "fill-pattern": { source: ca, composite: ca }, "fill-extrusion-pattern": { source: ca, composite: ca }, "line-dasharray": { source: ha, composite: ha } },
              xo = { color: { source: za, composite: ua }, number: { source: Sa, composite: za } };function vo(t, e, r) {
            const n = go[t];return n && n[r] || xo[e][r];
        }Oi(oo, "ConstantBinder"), Oi(lo, "PatternConstantBinder"), Oi(uo, "SourceExpressionBinder"), Oi(ho, "PatternCompositeBinder"), Oi(co, "CompositeExpressionBinder"), Oi(po, "ProgramConfiguration", { omit: ["_buffers"] }), Oi(fo, "ProgramConfigurationSet");const bo = "-transition";class wo extends Yt {
            constructor(t, e) {
                if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, "custom" !== t.type && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, "background" !== t.type && "sky" !== t.type && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new Xs(e.layout)), e.paint)) {
                    this._transitionablePaint = new qs(e.paint);for (const e in t.paint) this.setPaintProperty(e, t.paint[e], { validate: !1 });for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], { validate: !1 });this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ks(e.paint);
                }
            }getLayoutProperty(t) {
                return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t);
            }setLayoutProperty(t, e, r = {}) {
                null != e && this._validate(Li, `layers.${this.id}.layout.${t}`, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);
            }getPaintProperty(t) {
                return L(t, bo) ? this._transitionablePaint.getTransition(t.slice(0, -bo.length)) : this._transitionablePaint.getValue(t);
            }setPaintProperty(t, e, r = {}) {
                if (null != e && this._validate(Vi, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;if (L(t, bo)) return this._transitionablePaint.setTransition(t.slice(0, -bo.length), e || void 0), !1;{
                    const r = this._transitionablePaint._values[t],
                          n = r.value.isDataDriven(),
                          i = r.value;this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);const s = this._transitionablePaint._values[t].value,
                          a = s.isDataDriven(),
                          o = L(t, "pattern") || "line-dasharray" === t;return a || n || o || this._handleOverridablePaintPropertyUpdate(t, i, s);
                }
            }_handleSpecialPaintPropertyUpdate(t) {}getProgramIds() {
                return null;
            }getProgramConfiguration(t) {
                return null;
            }_handleOverridablePaintPropertyUpdate(t, e, r) {
                return !1;
            }isHidden(t) {
                return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility;
            }updateTransitions(t) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
            }hasTransition() {
                return this._transitioningPaint.hasTransition();
            }recalculate(t, e) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);
            }serialize() {
                const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), R(t, (t, e) => !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length));
            }_validate(t, e, r, n, i = {}) {
                return (!i || !1 !== i.validate) && Ri(this, t.call(Di, { key: e, layerType: this.type, objectKey: r, value: n, styleSpec: Ht, style: { glyphs: !0, sprite: !0 } }));
            }is3D() {
                return !1;
            }isSky() {
                return !1;
            }isTileClipped() {
                return !1;
            }hasOffscreenPass() {
                return !1;
            }resize() {}isStateDependent() {
                for (const t in this.paint._values) {
                    const e = this.paint.get(t);if (e instanceof Zs && En(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
                }return !1;
            }compileFilter() {
                this._filterCompiled || (this._featureFilter = ai(this.filter), this._filterCompiled = !0);
            }invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
        }const _o = na([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              Ao = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);class So {
            constructor(t = []) {
                this.segments = t;
            }prepareSegment(t, e, r, n) {
                let i = this.segments[this.segments.length - 1];return t > So.MAX_VERTEX_ARRAY_LENGTH && $(`Max vertices per segment is ${So.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > So.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = { vertexOffset: e.length, primitiveOffset: r.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }get() {
                return this.segments;
            }destroy() {
                for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();
            }static simpleSegment(t, e, r, n) {
                return new So([{ vertexOffset: t, primitiveOffset: e, vertexLength: r, primitiveLength: n, vaos: {}, sortKey: 0 }]);
            }
        }So.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Oi(So, "SegmentVector");var ko = 8192;class Io {
            constructor(t, e) {
                t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));
            }setNorthEast(t) {
                return this._ne = t instanceof ru ? new ru(t.lng, t.lat) : ru.convert(t), this;
            }setSouthWest(t) {
                return this._sw = t instanceof ru ? new ru(t.lng, t.lat) : ru.convert(t), this;
            }extend(t) {
                const e = this._sw,
                      r = this._ne;let n, i;if (t instanceof ru) n = t, i = t;else {
                    if (!(t instanceof Io)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Io.convert(t)) : this.extend(ru.convert(t)) : "object" == typeof t && null !== t && t.hasOwnProperty("lat") && t.hasOwnProperty("lon") ? this.extend(ru.convert(t)) : this;if (n = t._sw, i = t._ne, !n || !i) return this;
                }return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new ru(n.lng, n.lat), this._ne = new ru(i.lng, i.lat)), this;
            }getCenter() {
                return new ru((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }getSouthWest() {
                return this._sw;
            }getNorthEast() {
                return this._ne;
            }getNorthWest() {
                return new ru(this.getWest(), this.getNorth());
            }getSouthEast() {
                return new ru(this.getEast(), this.getSouth());
            }getWest() {
                return this._sw.lng;
            }getSouth() {
                return this._sw.lat;
            }getEast() {
                return this._ne.lng;
            }getNorth() {
                return this._ne.lat;
            }toArray() {
                return [this._sw.toArray(), this._ne.toArray()];
            }toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }isEmpty() {
                return !(this._sw && this._ne);
            }contains(t) {
                const { lng: e, lat: r } = ru.convert(t);let n = this._sw.lng <= e && e <= this._ne.lng;return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }static convert(t) {
                return !t || t instanceof Io ? t : new Io(t);
            }
        }var Mo = 1e-6,
            To = "undefined" != typeof Float32Array ? Float32Array : Array;function zo() {
            var t = new To(9);return To != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
        }function Bo(t, e, r) {
            var n = e[0],
                i = e[1],
                s = e[2],
                a = e[3],
                o = e[4],
                l = e[5],
                u = e[6],
                c = e[7],
                h = e[8],
                p = r[0],
                f = r[1],
                d = r[2],
                y = r[3],
                m = r[4],
                g = r[5],
                x = r[6],
                v = r[7],
                b = r[8];return t[0] = p * n + f * a + d * u, t[1] = p * i + f * o + d * c, t[2] = p * s + f * l + d * h, t[3] = y * n + m * a + g * u, t[4] = y * i + m * o + g * c, t[5] = y * s + m * l + g * h, t[6] = x * n + v * a + b * u, t[7] = x * i + v * o + b * c, t[8] = x * s + v * l + b * h, t;
        }function Eo(t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
        }function Co(t, e) {
            var r = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                l = e[6],
                u = e[7],
                c = e[8],
                h = e[9],
                p = e[10],
                f = e[11],
                d = e[12],
                y = e[13],
                m = e[14],
                g = e[15],
                x = r * o - n * a,
                v = r * l - i * a,
                b = r * u - s * a,
                w = n * l - i * o,
                _ = n * u - s * o,
                A = i * u - s * l,
                S = c * y - h * d,
                k = c * m - p * d,
                I = c * g - f * d,
                M = h * m - p * y,
                T = h * g - f * y,
                z = p * g - f * m,
                B = x * z - v * T + b * M + w * I - _ * k + A * S;return B ? (t[0] = (o * z - l * T + u * M) * (B = 1 / B), t[1] = (i * T - n * z - s * M) * B, t[2] = (y * A - m * _ + g * w) * B, t[3] = (p * _ - h * A - f * w) * B, t[4] = (l * I - a * z - u * k) * B, t[5] = (r * z - i * I + s * k) * B, t[6] = (m * b - d * A - g * v) * B, t[7] = (c * A - p * b + f * v) * B, t[8] = (a * T - o * I + u * S) * B, t[9] = (n * I - r * T - s * S) * B, t[10] = (d * _ - y * b + g * x) * B, t[11] = (h * b - c * _ - f * x) * B, t[12] = (o * k - a * M - l * S) * B, t[13] = (r * M - n * k + i * S) * B, t[14] = (y * v - d * w - m * x) * B, t[15] = (c * w - h * v + p * x) * B, t) : null;
        }function Po(t, e, r) {
            var n = e[0],
                i = e[1],
                s = e[2],
                a = e[3],
                o = e[4],
                l = e[5],
                u = e[6],
                c = e[7],
                h = e[8],
                p = e[9],
                f = e[10],
                d = e[11],
                y = e[12],
                m = e[13],
                g = e[14],
                x = e[15],
                v = r[0],
                b = r[1],
                w = r[2],
                _ = r[3];return t[0] = v * n + b * o + w * h + _ * y, t[1] = v * i + b * l + w * p + _ * m, t[2] = v * s + b * u + w * f + _ * g, t[3] = v * a + b * c + w * d + _ * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t[5] = v * i + b * l + w * p + _ * m, t[6] = v * s + b * u + w * f + _ * g, t[7] = v * a + b * c + w * d + _ * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t[9] = v * i + b * l + w * p + _ * m, t[10] = v * s + b * u + w * f + _ * g, t[11] = v * a + b * c + w * d + _ * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t[13] = v * i + b * l + w * p + _ * m, t[14] = v * s + b * u + w * f + _ * g, t[15] = v * a + b * c + w * d + _ * x, t;
        }function Do(t, e, r) {
            var n,
                i,
                s,
                a,
                o,
                l,
                u,
                c,
                h,
                p,
                f,
                d,
                y = r[0],
                m = r[1],
                g = r[2];return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12], t[13] = e[1] * y + e[5] * m + e[9] * g + e[13], t[14] = e[2] * y + e[6] * m + e[10] * g + e[14], t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * y + o * m + h * g + e[12], t[13] = i * y + l * m + p * g + e[13], t[14] = s * y + u * m + f * g + e[14], t[15] = a * y + c * m + d * g + e[15]), t;
        }function Vo(t, e, r) {
            var n = r[0],
                i = r[1],
                s = r[2];return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
        }function Lo(t, e, r) {
            var n = Math.sin(r),
                i = Math.cos(r),
                s = e[4],
                a = e[5],
                o = e[6],
                l = e[7],
                u = e[8],
                c = e[9],
                h = e[10],
                p = e[11];return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;
        }function Fo(t, e, r) {
            var n = Math.sin(r),
                i = Math.cos(r),
                s = e[0],
                a = e[1],
                o = e[2],
                l = e[3],
                u = e[8],
                c = e[9],
                h = e[10],
                p = e[11];return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = a * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = a * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t;
        }function Ro(t, e) {
            return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
        }function jo(t, e, r) {
            var n,
                i,
                s,
                a = r[0],
                o = r[1],
                l = r[2],
                u = Math.hypot(a, o, l);return u < Mo ? null : (a *= u = 1 / u, o *= u, l *= u, n = Math.sin(e), i = Math.cos(e), t[0] = a * a * (s = 1 - i) + i, t[1] = o * a * s + l * n, t[2] = l * a * s - o * n, t[3] = 0, t[4] = a * o * s - l * n, t[5] = o * o * s + i, t[6] = l * o * s + a * n, t[7] = 0, t[8] = a * l * s + o * n, t[9] = o * l * s - a * n, t[10] = l * l * s + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
        }Math.hypot || (Math.hypot = function () {
            for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];return Math.sqrt(t);
        });var Uo = Po;function $o() {
            var t = new To(3);return To != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
        }function Oo(t) {
            var e = new To(3);return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
        }function qo(t) {
            return Math.hypot(t[0], t[1], t[2]);
        }function No(t, e, r) {
            var n = new To(3);return n[0] = t, n[1] = e, n[2] = r, n;
        }function Go(t, e, r) {
            return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;
        }function Xo(t, e, r) {
            return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;
        }function Zo(t, e, r) {
            return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;
        }function Ko(t, e, r) {
            return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;
        }function Yo(t, e, r) {
            return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;
        }function Ho(t, e, r) {
            return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;
        }function Wo(t, e, r, n) {
            return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;
        }function Jo(t, e) {
            var r = e[0],
                n = e[1],
                i = e[2],
                s = r * r + n * n + i * i;return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;
        }function Qo(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
        }function tl(t, e, r) {
            var n = e[0],
                i = e[1],
                s = e[2],
                a = r[0],
                o = r[1],
                l = r[2];return t[0] = i * l - s * o, t[1] = s * a - n * l, t[2] = n * o - i * a, t;
        }function el(t, e, r) {
            var n = e[0],
                i = e[1],
                s = e[2],
                a = r[3] * n + r[7] * i + r[11] * s + r[15];return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t;
        }function rl(t, e, r) {
            var n = r[0],
                i = r[1],
                s = r[2],
                a = e[0],
                o = e[1],
                l = e[2],
                u = i * l - s * o,
                c = s * a - n * l,
                h = n * o - i * a,
                p = i * h - s * c,
                f = s * u - n * h,
                d = n * c - i * u,
                y = 2 * r[3];return c *= y, h *= y, f *= 2, d *= 2, t[0] = a + (u *= y) + (p *= 2), t[1] = o + c + f, t[2] = l + h + d, t;
        }var nl,
            il = Xo,
            sl = Zo,
            al = qo;function ol(t, e, r) {
            return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;
        }function ll(t, e) {
            var r = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = r * r + n * n + i * i + s * s;return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = r * a, t[1] = n * a, t[2] = i * a, t[3] = s * a, t;
        }function ul(t, e, r) {
            var n = e[0],
                i = e[1],
                s = e[2],
                a = e[3];return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t;
        }function cl() {
            var t = new To(4);return To != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
        }function hl(t) {
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
        }function pl(t, e, r) {
            r *= .5;var n = e[0],
                i = e[1],
                s = e[2],
                a = e[3],
                o = Math.sin(r),
                l = Math.cos(r);return t[0] = n * l + a * o, t[1] = i * l + s * o, t[2] = s * l - i * o, t[3] = a * l - n * o, t;
        }function fl(t, e, r) {
            r *= .5;var n = e[0],
                i = e[1],
                s = e[2],
                a = e[3],
                o = Math.sin(r),
                l = Math.cos(r);return t[0] = n * l - s * o, t[1] = i * l + a * o, t[2] = s * l + n * o, t[3] = a * l - i * o, t;
        }$o(), nl = new To(4), To != Float32Array && (nl[0] = 0, nl[1] = 0, nl[2] = 0, nl[3] = 0);var dl = ll;$o(), No(1, 0, 0), No(0, 1, 0), cl(), cl(), zo();const yl = na([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]),
              { members: ml } = yl,
              gl = na([{ name: "a_pos_3", components: 3, type: "Int16" }]);var xl = na([{ name: "a_pos", type: "Int16", components: 2 }]);class vl {
            constructor(t, e) {
                this.pos = t, this.dir = e;
            }intersectsPlane(t, e, r) {
                const n = Qo(e, this.dir);if (Math.abs(n) < 1e-6) return !1;const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
            }closestPointOnSphere(t, e, r) {
                if (function (t, e) {
                    var r = t[0],
                        n = t[1],
                        i = t[2],
                        s = e[0],
                        a = e[1],
                        o = e[2];return Math.abs(r - s) <= Mo * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= Mo * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= Mo * Math.max(1, Math.abs(i), Math.abs(o));
                }(this.pos, t) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;const [n, i, s] = this.dir,
                      a = this.pos[0] - t[0],
                      o = this.pos[1] - t[1],
                      l = this.pos[2] - t[2],
                      u = n * n + i * i + s * s,
                      c = 2 * (a * n + o * i + l * s),
                      h = c * c - 4 * u * (a * a + o * o + l * l - e * e);if (h < 0) {
                    const t = Math.max(-c / 2, 0),
                          u = a + n * t,
                          h = o + i * t,
                          p = l + s * t,
                          f = Math.hypot(u, h, p);return r[0] = u * e / f, r[1] = h * e / f, r[2] = p * e / f, !1;
                }{
                    const t = (-c - Math.sqrt(h)) / (2 * u);if (t < 0) {
                        const t = Math.hypot(a, o, l);return r[0] = a * e / t, r[1] = o * e / t, r[2] = l * e / t, !1;
                    }return r[0] = a + n * t, r[1] = o + i * t, r[2] = l + s * t, !0;
                }
            }
        }class bl {
            constructor(t, e, r, n, i) {
                this.TL = t, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;
            }static fromInvProjectionMatrix(t, e, r) {
                const n = [-1, 1, 1],
                      i = [1, 1, 1],
                      s = [1, -1, 1],
                      a = [-1, -1, 1],
                      o = el(n, n, t),
                      l = el(i, i, t),
                      u = el(s, s, t),
                      c = el(a, a, t);return new bl(o, l, u, c, e / r);
            }
        }class wl {
            constructor(t, e) {
                this.points = t, this.planes = e;
            }static fromInvProjectionMatrix(t, e, r, n) {
                const i = Math.pow(2, r),
                      s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(r => {
                    const s = ul([], r, t),
                          a = 1 / s[3] / e * i;return function (t, e, r) {
                        return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t;
                    }(s, s, [a, a, n ? 1 / s[3] : a, a]);
                }),
                      a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {
                    const e = Jo([], tl([], il([], s[t[0]], s[t[1]]), il([], s[t[2]], s[t[1]]))),
                          r = -Qo(e, s[t[1]]);return e.concat(r);
                });return new wl(s, a);
            }
        }class _l {
            static fromPoints(t) {
                const e = [1 / 0, 1 / 0, 1 / 0],
                      r = [-1 / 0, -1 / 0, -1 / 0];for (const n of t) Ko(e, e, n), Yo(r, r, n);return new _l(e, r);
            }static applyTransform(t, e) {
                const r = t.getCorners();for (let t = 0; t < r.length; ++t) el(r[t], r[t], e);return _l.fromPoints(r);
            }constructor(t, e) {
                this.min = t, this.max = e, this.center = Ho([], Go([], this.min, this.max), .5);
            }quadrant(t) {
                const e = [t % 2 == 0, t < 2],
                      r = Oo(this.min),
                      n = Oo(this.max);for (let t = 0; t < e.length; t++) r[t] = e[t] ? this.min[t] : this.center[t], n[t] = e[t] ? this.center[t] : this.max[t];return n[2] = this.max[2], new _l(r, n);
            }distanceX(t) {
                return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
            }distanceY(t) {
                return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
            }distanceZ(t) {
                return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];
            }getCorners() {
                const t = this.min,
                      e = this.max;return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];
            }intersects(t) {
                const e = this.getCorners();let r = !0;for (let n = 0; n < t.planes.length; n++) {
                    const i = t.planes[n];let s = 0;for (let t = 0; t < e.length; t++) s += Qo(i, e[t]) + i[3] >= 0;if (0 === s) return 0;s !== e.length && (r = !1);
                }if (r) return 2;for (let e = 0; e < 3; e++) {
                    let r = Number.MAX_VALUE,
                        n = -Number.MAX_VALUE;for (let i = 0; i < t.points.length; i++) {
                        const s = t.points[i][e] - this.min[e];r = Math.min(r, s), n = Math.max(n, s);
                    }if (n < 0 || r > this.max[e] - this.min[e]) return 0;
                }return 1;
            }
        }const Al = ko / Math.PI / 2,
              Sl = 64,
              kl = [Sl, 32, 16],
              Il = -Al,
              Ml = Al,
              Tl = [new _l([Il, Il, Il], [Ml, Ml, Ml]), new _l([Il, Il, Il], [0, 0, Ml]), new _l([0, Il, Il], [Ml, 0, Ml]), new _l([Il, 0, Il], [0, Ml, Ml]), new _l([0, 0, Il], [Ml, Ml, Ml])];function zl(t) {
            return t * Al / tu;
        }function Bl(t, e, r, n = !0) {
            const i = Ho([], t._camera.position, t.worldSize),
                  s = [e, r, 1, 1];ul(s, s, t.pixelMatrixInverse), ol(s, s, 1 / s[3]);const a = Jo([], il([], s, i)),
                  o = t.globeMatrix,
                  l = [o[12], o[13], o[14]],
                  u = il([], l, i),
                  c = qo(u),
                  h = Jo([], u),
                  p = t.worldSize / (2 * Math.PI),
                  f = Qo(h, a),
                  d = Math.asin(p / c);if (d < Math.acos(f)) {
                if (!n) return null;const t = [],
                      e = [];Ho(t, a, c / f), Jo(e, il(e, t, u)), Jo(a, Go(a, u, Ho(a, e, Math.tan(d) * c)));
            }const y = [];new vl(i, a).closestPointOnSphere(l, p, y);const m = Jo([], Y(o, 0)),
                  g = Jo([], Y(o, 1)),
                  x = Jo([], Y(o, 2)),
                  b = Qo(m, y),
                  w = Qo(g, y),
                  _ = Qo(x, y),
                  A = v(Math.asin(-w / p));let k = v(Math.atan2(b, _));k = t.center.lng + function (t, e) {
                const r = (e - t + 180) % 360 - 180;return r < -180 ? r + 360 : r;
            }(t.center.lng, k);const I = iu(k),
                  M = S(su(A), 0, 1);return new pu(I, M);
        }class El {
            constructor(t, e, r) {
                this.a = il([], t, r), this.b = il([], e, r), this.center = r;const n = Jo([], this.a),
                      i = Jo([], this.b);this.angle = Math.acos(Qo(n, i));
            }
        }function Cl(t, e) {
            if (0 === t.angle) return null;let r;return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {
                const i = Math.sin(r);return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);
            }(t.a[e], t.b[e], t.angle, S(r, 0, 1)) + t.center[e];
        }function Pl(t) {
            if (t.z <= 1) return Tl[t.z + 2 * t.y + t.x];const e = jl(Rl(t));return _l.fromPoints(e);
        }function Dl(t, e, r) {
            return Ho(t, t, 1 - r), Wo(t, t, e, r);
        }function Vl(t, e) {
            const r = Kl(e.zoom);if (0 === r) return Pl(t);const n = Rl(t),
                  i = jl(n),
                  s = iu(n.getWest()) * e.worldSize,
                  a = iu(n.getEast()) * e.worldSize,
                  o = su(n.getNorth()) * e.worldSize,
                  l = su(n.getSouth()) * e.worldSize,
                  u = [s, o, 0],
                  c = [a, o, 0],
                  h = [s, l, 0],
                  p = [a, l, 0],
                  f = Co([], e.globeMatrix);return el(u, u, f), el(c, c, f), el(h, h, f), el(p, p, f), i[0] = Dl(i[0], h, r), i[1] = Dl(i[1], p, r), i[2] = Dl(i[2], c, r), i[3] = Dl(i[3], u, r), _l.fromPoints(i);
        }function Ll(t, e, r) {
            for (const n of t) el(n, n, e), Ho(n, n, r);
        }function Fl(t, e, r) {
            const n = e / t.worldSize,
                  i = t.globeMatrix;if (r.z <= 1) {
                const t = Pl(r).getCorners();return Ll(t, i, n), _l.fromPoints(t);
            }const s = Rl(r),
                  a = jl(s);Ll(a, i, n);const o = Number.MAX_VALUE,
                  l = [-o, -o, -o],
                  u = [o, o, o];if (s.contains(t.center)) {
                for (const t of a) Ko(u, u, t), Yo(l, l, t);l[2] = 0;const e = t.point,
                      r = [e.x * n, e.y * n, 0];return Ko(u, u, r), Yo(l, l, r), new _l(u, l);
            }const c = [i[12] * n, i[13] * n, i[14] * n],
                  h = s.getCenter(),
                  p = S(t.center.lat, -cu, cu),
                  f = S(h.lat, -cu, cu),
                  d = iu(t.center.lng),
                  y = su(p);let m = d - iu(h.lng);const g = y - su(f);m > .5 ? m -= 1 : m < -.5 && (m += 1);let v = 0;Math.abs(m) > Math.abs(g) ? v = m >= 0 ? 1 : 3 : (v = g >= 0 ? 0 : 2, Wo(c, c, [i[4] * n, i[5] * n, i[6] * n], -Math.sin(x(g >= 0 ? s.getSouth() : s.getNorth())) * Al));const b = a[v],
                  w = a[(v + 1) % 4],
                  _ = new El(b, w, c),
                  A = [Cl(_, 0) || b[0], Cl(_, 1) || b[1], Cl(_, 2) || b[2]],
                  k = Kl(t.zoom);if (k > 0) {
                const n = function ({ x: t, y: e, z: r }, n, i, s, a) {
                    const o = 1 / (1 << r);let l = t * o,
                        u = l + o,
                        c = e * o,
                        h = c + o,
                        p = 0;const f = (l + u) / 2 - s;return f > .5 ? p = -1 : f < -.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [[l, h, 0], [u, h, 0], [u, c, 0], [l, c, 0]];
                }(r, e, t._pixelsPerMercatorPixel, d, y);for (let t = 0; t < a.length; t++) Dl(a[t], n[t], k);const i = Go([], n[v], n[(v + 1) % 4]);Ho(i, i, .5), Dl(A, i, k);
            }for (const t of a) Ko(u, u, t), Yo(l, l, t);return u[2] = Math.min(b[2], w[2]), Ko(u, u, A), Yo(l, l, A), new _l(u, l);
        }function Rl({ x: t, y: e, z: r }) {
            const n = 1 / (1 << r),
                  i = new ru(ou(t * n), lu((e + 1) * n)),
                  s = new ru(ou((t + 1) * n), lu(e * n));return new Io(i, s);
        }function jl(t) {
            const e = x(t.getNorth()),
                  r = x(t.getSouth()),
                  n = Math.cos(e),
                  i = Math.cos(r),
                  s = Math.sin(e),
                  a = Math.sin(r),
                  o = t.getWest(),
                  l = t.getEast();return [Ul(i, a, o), Ul(i, a, l), Ul(n, s, l), Ul(n, s, o)];
        }function Ul(t, e, r, n = Al) {
            return r = x(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];
        }function $l(t, e, r) {
            return Ul(Math.cos(x(t)), Math.sin(x(t)), e, r);
        }function Ol(t, e, r, n) {
            const i = 1 << r.z,
                  s = (t / ko + r.x) / i;return $l(lu((e / ko + r.y) / i), ou(s), n);
        }function ql({ min: t, max: e }) {
            return 16383 / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2]);
        }const Nl = new Float64Array(16);function Gl(t) {
            const e = ql(t),
                  r = Ro(Nl, [e, e, e]);return Do(r, r, ((n = [])[0] = -(i = t.min)[0], n[1] = -i[1], n[2] = -i[2], n));var n, i;
        }function Xl(t) {
            const e = (n = t.min, (r = Nl)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r);var r, n;const i = 1 / ql(t);return Vo(e, e, [i, i, i]);
        }function Zl(t, e, r, n, i) {
            const s = function (t) {
                const e = ko / (2 * Math.PI);return t / (2 * Math.PI) / e;
            }(r),
                  a = [t, e, -r / (2 * Math.PI)],
                  o = Eo(new Float64Array(16));return Do(o, o, a), Vo(o, o, [s, s, s]), Lo(o, o, x(-i)), Fo(o, o, x(-n)), o;
        }function Kl(t) {
            return k(5, 6, t);
        }function Yl(t, e) {
            const r = $l(e.lat, e.lng),
                  n = function (t) {
                const e = $l(t._center.lat, t._center.lng);let r = tl([], No(0, 1, 0), e);const n = jo([], -t.angle, e);r = el(r, r, n), jo(n, -t._pitch, r);const i = Jo([], e);return Ho(i, i, zl(t.cameraToCenterDistance / t.pixelsPerMeter)), el(i, i, n), Go([], e, i);
            }(t);return a = (i = Xo([], n, r))[0], o = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], f = (p = Math.sqrt(a * a + o * o + l * l) * Math.sqrt(u * u + c * c + h * h)) && Qo(i, s) / p, Math.acos(Math.min(Math.max(f, -1), 1));var i, s, a, o, l, u, c, h, p, f;
        }function Hl(t, e) {
            return Yl(t, e) > Math.PI / 2 * 1.01;
        }const Wl = x(85),
              Jl = Math.cos(Wl),
              Ql = Math.sin(Wl),
              tu = 6371008.8,
              eu = 2 * Math.PI * tu;class ru {
            constructor(t, e) {
                if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }wrap() {
                return new ru(I(this.lng, -180, 180), this.lat);
            }toArray() {
                return [this.lng, this.lat];
            }toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }distanceTo(t) {
                const e = Math.PI / 180,
                      r = this.lat * e,
                      n = t.lat * e,
                      i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);return tu * Math.acos(Math.min(i, 1));
            }toBounds(t = 0) {
                const e = 360 * t / 40075017,
                      r = e / Math.cos(Math.PI / 180 * this.lat);return new Io(new ru(this.lng - r, this.lat - e), new ru(this.lng + r, this.lat + e));
            }toEcef(t) {
                const e = zl(t);return $l(this.lat, this.lng, Al + e);
            }static convert(t) {
                if (t instanceof ru) return t;if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new ru(Number(t[0]), Number(t[1]));if (!Array.isArray(t) && "object" == typeof t && null !== t) return new ru(Number("lng" in t ? t.lng : t.lon), Number(t.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }function nu(t) {
            return eu * Math.cos(t * Math.PI / 180);
        }function iu(t) {
            return (180 + t) / 360;
        }function su(t) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;
        }function au(t, e) {
            return t / nu(e);
        }function ou(t) {
            return 360 * t - 180;
        }function lu(t) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;
        }function uu(t, e) {
            return t * nu(lu(e));
        }const cu = 85.051129;function hu(t) {
            return 1 / Math.cos(t * Math.PI / 180);
        }class pu {
            constructor(t, e, r = 0) {
                this.x = +t, this.y = +e, this.z = +r;
            }static fromLngLat(t, e = 0) {
                const r = ru.convert(t);return new pu(iu(r.lng), su(r.lat), au(e, r.lat));
            }toLngLat() {
                return new ru(ou(this.x), lu(this.y));
            }toAltitude() {
                return uu(this.z, this.y);
            }meterInMercatorCoordinateUnits() {
                return 1 / eu * hu(lu(this.y));
            }
        }function fu(t, e, r, n, i, s, a, o, l) {
            const u = (e + n) / 2,
                  c = (r + i) / 2,
                  h = new d(u, c);o(h), function (t, e, r, n, i, s) {
                const a = r - i,
                      o = n - s;return Math.abs((n - e) * a - (r - t) * o) / Math.hypot(a, o);
            }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? (fu(t, e, r, u, c, s, h, o, l), fu(t, u, c, n, i, h, a, o, l)) : t.push(a);
        }function du(t, e, r) {
            let n = t[0],
                i = n.x,
                s = n.y;e(n);const a = [n];for (let o = 1; o < t.length; o++) {
                const l = t[o],
                      { x: u, y: c } = l;e(l), fu(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;
            }return a;
        }function yu(t, e, r, n) {
            if (n(e, r)) {
                const i = e.add(r)._mult(.5);yu(t, e, i, n), yu(t, i, r, n);
            } else t.push(r);
        }function mu(t, e) {
            let r = t[0];const n = [r];for (let i = 1; i < t.length; i++) {
                const s = t[i];yu(n, r, s, e), r = s;
            }return n;
        }const gu = Math.pow(2, 14) - 1,
              xu = -gu - 1;function vu(t, e) {
            const r = Math.round(t.x * e),
                  n = Math.round(t.y * e);return t.x = S(r, xu, gu), t.y = S(n, xu, gu), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && $("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t;
        }function bu(t, e, r) {
            const n = t.loadGeometry(),
                  i = t.extent,
                  s = ko / i;if (e && r && r.projection.isReprojectedInTileSpace) {
                const s = 1 << e.z,
                      { scale: a, x: o, y: l, projection: u } = r,
                      c = t => {
                    const r = ou((e.x + t.x / i) / s),
                          n = lu((e.y + t.y / i) / s),
                          c = u.project(r, n);t.x = (c.x * a - o) * i, t.y = (c.y * a - l) * i;
                };for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = du(n[e], c, 1);else {
                    const t = [];for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));n[e] = t;
                }
            }for (const t of n) for (const e of t) vu(e, s);return n;
        }function wu(t, e) {
            return { type: t.type, id: t.id, properties: t.properties, geometry: e ? bu(t) : [] };
        }function _u(t, e, r, n, i) {
            t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }function Au(t, e, r) {
            const n = 16384;t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }class Su {
            constructor(t) {
                this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.segments = new So(), this.programConfigurations = new fo(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);
            }populate(t, e, r, n) {
                const i = this.layers[0],
                      s = [];let a = null;"circle" === i.type && (a = i.layout.get("circle-sort-key"));for (const { feature: e, id: i, index: o, sourceLayerIndex: l } of t) {
                    const t = this.layers[0]._featureFilter.needGeometry,
                          u = wu(e, t);if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u, r)) continue;const c = a ? a.evaluate(u, {}, r) : void 0,
                          h = { id: i, properties: e.properties, type: e.type, sourceLayerIndex: l, index: o, geometry: t ? u.geometry : bu(e, r, n), patterns: {}, sortKey: c };s.push(h);
                }a && s.sort((t, e) => t.sortKey - e.sortKey);let o = null;"globe" === n.projection.name && (this.globeExtVertexArray = new pa(), o = n.projection);for (const n of s) {
                    const { geometry: i, index: s, sourceLayerIndex: a } = n,
                          l = t[s].feature;this.addFeature(n, i, s, e.availableImages, r, o), e.featureIndex.insert(l, i, s, a, this.index);
                }
            }update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _o.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Ao.members))), this.programConfigurations.upload(t), this.uploaded = !0;
            }destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }addFeature(t, e, r, n, i, s) {
                for (const r of e) for (const e of r) {
                    const r = e.x,
                          n = e.y;if (r < 0 || r >= ko || n < 0 || n >= ko) continue;if (s) {
                        const t = s.projectTilePoint(r, n, i),
                              e = s.upVector(i, r, n),
                              a = this.globeExtVertexArray;Au(a, t, e), Au(a, t, e), Au(a, t, e), Au(a, t, e);
                    }const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),
                          o = a.vertexLength;_u(this.layoutVertexArray, r, n, -1, -1), _u(this.layoutVertexArray, r, n, 1, -1), _u(this.layoutVertexArray, r, n, 1, 1), _u(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;
                }this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i);
            }
        }function ku(t, e) {
            for (let r = 0; r < t.length; r++) if (Du(e, t[r])) return !0;for (let r = 0; r < e.length; r++) if (Du(t, e[r])) return !0;return !!zu(t, e);
        }function Iu(t, e, r) {
            return !!Du(t, e) || !!Eu(e, t, r);
        }function Mu(t, e) {
            if (1 === t.length) return Pu(e, t[0]);for (let r = 0; r < e.length; r++) {
                const n = e[r];for (let e = 0; e < n.length; e++) if (Du(t, n[e])) return !0;
            }for (let r = 0; r < t.length; r++) if (Pu(e, t[r])) return !0;for (let r = 0; r < e.length; r++) if (zu(t, e[r])) return !0;return !1;
        }function Tu(t, e, r) {
            if (t.length > 1) {
                if (zu(t, e)) return !0;for (let n = 0; n < e.length; n++) if (Eu(e[n], t, r)) return !0;
            }for (let n = 0; n < t.length; n++) if (Eu(t[n], e, r)) return !0;return !1;
        }function zu(t, e) {
            if (0 === t.length || 0 === e.length) return !1;for (let r = 0; r < t.length - 1; r++) {
                const n = t[r],
                      i = t[r + 1];for (let t = 0; t < e.length - 1; t++) if (Bu(n, i, e[t], e[t + 1])) return !0;
            }return !1;
        }function Bu(t, e, r, n) {
            return O(t, r, n) !== O(e, r, n) && O(t, e, r) !== O(t, e, n);
        }function Eu(t, e, r) {
            const n = r * r;if (1 === e.length) return t.distSqr(e[0]) < n;for (let r = 1; r < e.length; r++) if (Cu(t, e[r - 1], e[r]) < n) return !0;return !1;
        }function Cu(t, e, r) {
            const n = e.distSqr(r);if (0 === n) return t.distSqr(e);const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));
        }function Pu(t, e) {
            let r,
                n,
                i,
                s = !1;for (let a = 0; a < t.length; a++) {
                r = t[a];for (let t = 0, a = r.length - 1; t < r.length; a = t++) n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);
            }return s;
        }function Du(t, e) {
            let r = !1;for (let n = 0, i = t.length - 1; n < t.length; i = n++) {
                const s = t[n],
                      a = t[i];s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);
            }return r;
        }function Vu(t, e, r, n, i) {
            for (const s of t) if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;const s = [new d(e, r), new d(e, i), new d(n, i), new d(n, r)];if (t.length > 2) for (const e of s) if (Du(t, e)) return !0;for (let e = 0; e < t.length - 1; e++) if (Lu(t[e], t[e + 1], s)) return !0;return !1;
        }function Lu(t, e, r) {
            const n = r[0],
                  i = r[2];if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;const s = O(t, e, r[0]);return s !== O(t, e, r[1]) || s !== O(t, e, r[2]) || s !== O(t, e, r[3]);
        }function Fu(t, e, r) {
            const n = e.paint.get(t).value;return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);
        }function Ru(t) {
            return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
        }function ju(t, e, r, n, i) {
            if (!e[0] && !e[1]) return t;const s = d.convert(e)._mult(i);"viewport" === r && s._rotate(-n);const a = [];for (let e = 0; e < t.length; e++) a.push(t[e].sub(s));return a;
        }function Uu(t, e, r, n) {
            const i = d.convert(t)._mult(n);return "viewport" === e && i._rotate(-r), i;
        }Oi(Su, "CircleBucket", { omit: ["layers"] });const $u = new Js({ "circle-sort-key": new Hs(Ht.layout_circle["circle-sort-key"]) });var Ou = { paint: new Js({ "circle-radius": new Hs(Ht.paint_circle["circle-radius"]), "circle-color": new Hs(Ht.paint_circle["circle-color"]), "circle-blur": new Hs(Ht.paint_circle["circle-blur"]), "circle-opacity": new Hs(Ht.paint_circle["circle-opacity"]), "circle-translate": new Ys(Ht.paint_circle["circle-translate"]), "circle-translate-anchor": new Ys(Ht.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ys(Ht.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ys(Ht.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Hs(Ht.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Hs(Ht.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Hs(Ht.paint_circle["circle-stroke-opacity"]) }), layout: $u };function qu(t, e, r, n, i, s, a, o, l) {
            if (s && t.queryGeometry.isAboveHorizon) return !1;s && (l *= t.pixelToTileUnitsFactor);const u = t.tileID.canonical,
                  c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;for (const h of e) for (const e of h) {
                const h = e.add(o),
                      p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0,
                      f = r.projection.projectTilePoint(h.x, h.y, u);if (p > 0) {
                    const t = r.projection.upVector(u, h.x, h.y);f.x += t[0] * c * p, f.y += t[1] * c * p, f.z += t[2] * c * p;
                }const d = s ? h : Nu(f.x, f.y, f.z, n),
                      y = s ? t.tilespaceRays.map(t => Zu(t, p)) : t.queryGeometry.screenGeometry,
                      m = ul([], [f.x, f.y, f.z, 1], n);if (!a && s ? l *= m[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / m[3]), s) {
                    const t = lu((e.y / ko + u.y) / (1 << u.z));l /= r.projection.pixelsPerMeter(t, 1) / au(1, t);
                }if (Iu(y, d, l)) return !0;
            }return !1;
        }function Nu(t, e, r, n) {
            const i = ul([], [t, e, r, 1], n);return new d(i[0] / i[3], i[1] / i[3]);
        }const Gu = No(0, 0, 0),
              Xu = No(0, 0, 1);function Zu(t, e) {
            const r = $o();return Gu[2] = e, t.intersectsPlane(Gu, Xu, r), new d(r[0], r[1]);
        }class Ku extends Su {}function Yu(t, { width: e, height: r }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError("mismatched image size");
            } else i = new Uint8Array(e * r * n);return t.width = e, t.height = r, t.data = i, t;
        }function Hu(t, e, r) {
            const { width: n, height: i } = e;n === t.width && i === t.height || (Wu(t, e, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t.width, n), height: Math.min(t.height, i) }, r), t.width = n, t.height = i, t.data = e.data);
        }function Wu(t, e, r, n, i, s) {
            if (0 === i.width || 0 === i.height) return e;if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy");if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");const a = t.data,
                  o = e.data;for (let l = 0; l < i.height; l++) {
                const u = ((r.y + l) * t.width + r.x) * s,
                      c = ((n.y + l) * e.width + n.x) * s;for (let t = 0; t < i.width * s; t++) o[c + t] = a[u + t];
            }return e;
        }Oi(Ku, "HeatmapBucket", { omit: ["layers"] });class Ju {
            constructor(t, e) {
                Yu(this, t, 1, e);
            }resize(t) {
                Hu(this, new Ju(t), 1);
            }clone() {
                return new Ju({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }static copy(t, e, r, n, i) {
                Wu(t, e, r, n, i, 1);
            }
        }class Qu {
            constructor(t, e) {
                Yu(this, t, 4, e);
            }resize(t) {
                Hu(this, new Qu(t), 4);
            }replace(t, e) {
                e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
            }clone() {
                return new Qu({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }static copy(t, e, r, n, i) {
                Wu(t, e, r, n, i, 4);
            }
        }Oi(Ju, "AlphaImage"), Oi(Qu, "RGBAImage");var tc = { paint: new Js({ "heatmap-radius": new Hs(Ht.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Hs(Ht.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ys(Ht.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ws(Ht.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ys(Ht.paint_heatmap["heatmap-opacity"]) }) };function ec(t) {
            const e = {},
                  r = t.resolution || 256,
                  n = t.clips ? t.clips.length : 1,
                  i = t.image || new Qu({ width: r, height: n }),
                  s = (r, n, s) => {
                e[t.evaluationKey] = s;const a = t.expression.evaluate(e);i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);
            };if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, a = 0; n < r; n++, a += 4) {
                const o = n / (r - 1),
                      { start: l, end: u } = t.clips[e];s(i, a, l * (1 - o) + u * o);
            } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));return i;
        }var rc = { paint: new Js({ "hillshade-illumination-direction": new Ys(Ht.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ys(Ht.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ys(Ht.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ys(Ht.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ys(Ht.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ys(Ht.paint_hillshade["hillshade-accent-color"]) }) };const nc = na([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              { members: ic } = nc;var sc = {};function ac(t, e, r) {
            r = r || 2;var n,
                i,
                s,
                a,
                o,
                l,
                u,
                c = e && e.length,
                h = c ? e[0] * r : t.length,
                p = oc(t, 0, h, r, !0),
                f = [];if (!p || p.next === p.prev) return f;if (c && (p = function (t, e, r, n) {
                var i,
                    s,
                    a,
                    o = [];for (i = 0, s = e.length; i < s; i++) (a = oc(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), o.push(xc(a));for (o.sort(dc), i = 0; i < o.length; i++) r = yc(o[i], r);return r;
            }(t, e, p, r)), t.length > 80 * r) {
                n = s = t[0], i = a = t[1];for (var d = r; d < h; d += r) (o = t[d]) < n && (n = o), (l = t[d + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);u = 0 !== (u = Math.max(s - n, a - i)) ? 32767 / u : 0;
            }return uc(p, f, r, n, i, u, 0), f;
        }function oc(t, e, r, n, i) {
            var s, a;if (i === Ec(t, e, r, n) > 0) for (s = e; s < r; s += n) a = Tc(s, t[s], t[s + 1], a);else for (s = r - n; s >= e; s -= n) a = Tc(s, t[s], t[s + 1], a);return a && _c(a, a.next) && (zc(a), a = a.next), a;
        }function lc(t, e) {
            if (!t) return t;e || (e = t);var r,
                n = t;do {
                if (r = !1, n.steiner || !_c(n, n.next) && 0 !== wc(n.prev, n, n.next)) n = n.next;else {
                    if (zc(n), (n = e = n.prev) === n.next) break;r = !0;
                }
            } while (r || n !== e);return e;
        }function uc(t, e, r, n, i, s, a) {
            if (t) {
                !a && s && function (t, e, r, n) {
                    var i = t;do {
                        0 === i.z && (i.z = gc(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                    } while (i !== t);i.prevZ.nextZ = null, i.prevZ = null, function (t) {
                        var e,
                            r,
                            n,
                            i,
                            s,
                            a,
                            o,
                            l,
                            u = 1;do {
                            for (r = t, t = null, s = null, a = 0; r;) {
                                for (a++, n = r, o = 0, e = 0; e < u && (o++, n = n.nextZ); e++);for (l = u; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;r = n;
                            }s.nextZ = null, u *= 2;
                        } while (a > 1);
                    }(i);
                }(t, n, i, s);for (var o, l, u = t; t.prev !== t.next;) if (o = t.prev, l = t.next, s ? hc(t, n, i, s) : cc(t)) e.push(o.i / r | 0), e.push(t.i / r | 0), e.push(l.i / r | 0), zc(t), t = l.next, u = l.next;else if ((t = l) === u) {
                    a ? 1 === a ? uc(t = pc(lc(t), e, r), e, r, n, i, s, 2) : 2 === a && fc(t, e, r, n, i, s) : uc(lc(t), e, r, n, i, s, 1);break;
                }
            }
        }function cc(t) {
            var e = t.prev,
                r = t,
                n = t.next;if (wc(e, r, n) >= 0) return !1;for (var i = e.x, s = r.x, a = n.x, o = e.y, l = r.y, u = n.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > s ? i > a ? i : a : s > a ? s : a, f = o > l ? o > u ? o : u : l > u ? l : u, d = n.next; d !== e;) {
                if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && vc(i, o, s, l, a, u, d.x, d.y) && wc(d.prev, d, d.next) >= 0) return !1;d = d.next;
            }return !0;
        }function hc(t, e, r, n) {
            var i = t.prev,
                s = t,
                a = t.next;if (wc(i, s, a) >= 0) return !1;for (var o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, y = o > l ? o > u ? o : u : l > u ? l : u, m = c > h ? c > p ? c : p : h > p ? h : p, g = gc(f, d, e, r, n), x = gc(y, m, e, r, n), v = t.prevZ, b = t.nextZ; v && v.z >= g && b && b.z <= x;) {
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && vc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0) return !1;if (v = v.prevZ, b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && vc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0) return !1;b = b.nextZ;
            }for (; v && v.z >= g;) {
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && vc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0) return !1;v = v.prevZ;
            }for (; b && b.z <= x;) {
                if (b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && vc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0) return !1;b = b.nextZ;
            }return !0;
        }function pc(t, e, r) {
            var n = t;do {
                var i = n.prev,
                    s = n.next.next;!_c(i, s) && Ac(i, n, n.next, s) && Ic(i, s) && Ic(s, i) && (e.push(i.i / r | 0), e.push(n.i / r | 0), e.push(s.i / r | 0), zc(n), zc(n.next), n = t = s), n = n.next;
            } while (n !== t);return lc(n);
        }function fc(t, e, r, n, i, s) {
            var a = t;do {
                for (var o = a.next.next; o !== a.prev;) {
                    if (a.i !== o.i && bc(a, o)) {
                        var l = Mc(a, o);return a = lc(a, a.next), l = lc(l, l.next), uc(a, e, r, n, i, s, 0), void uc(l, e, r, n, i, s, 0);
                    }o = o.next;
                }a = a.next;
            } while (a !== t);
        }function dc(t, e) {
            return t.x - e.x;
        }function yc(t, e) {
            var r = function (t, e) {
                var r,
                    n = e,
                    i = t.x,
                    s = t.y,
                    a = -1 / 0;do {
                    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                        var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);if (o <= i && o > a && (a = o, r = n.x < n.next.x ? n : n.next, o === i)) return r;
                    }n = n.next;
                } while (n !== e);if (!r) return null;var l,
                    u = r,
                    c = r.x,
                    h = r.y,
                    p = 1 / 0;n = r;do {
                    i >= n.x && n.x >= c && i !== n.x && vc(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), Ic(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && mc(r, n))) && (r = n, p = l)), n = n.next;
                } while (n !== u);return r;
            }(t, e);if (!r) return e;var n = Mc(r, t);return lc(n, n.next), lc(r, r.next);
        }function mc(t, e) {
            return wc(t.prev, t, e.prev) < 0 && wc(e.next, t, t.next) < 0;
        }function gc(t, e, r, n, i) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }function xc(t) {
            var e = t,
                r = t;do {
                (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
            } while (e !== t);return r;
        }function vc(t, e, r, n, i, s, a, o) {
            return (i - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o);
        }function bc(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
                var r = t;do {
                    if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Ac(r, r.next, t, e)) return !0;r = r.next;
                } while (r !== t);return !1;
            }(t, e) && (Ic(t, e) && Ic(e, t) && function (t, e) {
                var r = t,
                    n = !1,
                    i = (t.x + e.x) / 2,
                    s = (t.y + e.y) / 2;do {
                    r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                } while (r !== t);return n;
            }(t, e) && (wc(t.prev, t, e.prev) || wc(t, e.prev, e)) || _c(t, e) && wc(t.prev, t, t.next) > 0 && wc(e.prev, e, e.next) > 0);
        }function wc(t, e, r) {
            return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);
        }function _c(t, e) {
            return t.x === e.x && t.y === e.y;
        }function Ac(t, e, r, n) {
            var i = kc(wc(t, e, r)),
                s = kc(wc(t, e, n)),
                a = kc(wc(r, n, t)),
                o = kc(wc(r, n, e));return i !== s && a !== o || !(0 !== i || !Sc(t, r, e)) || !(0 !== s || !Sc(t, n, e)) || !(0 !== a || !Sc(r, t, n)) || !(0 !== o || !Sc(r, e, n));
        }function Sc(t, e, r) {
            return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);
        }function kc(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0;
        }function Ic(t, e) {
            return wc(t.prev, t, t.next) < 0 ? wc(t, e, t.next) >= 0 && wc(t, t.prev, e) >= 0 : wc(t, e, t.prev) < 0 || wc(t, t.next, e) < 0;
        }function Mc(t, e) {
            var r = new Bc(t.i, t.x, t.y),
                n = new Bc(e.i, e.x, e.y),
                i = t.next,
                s = e.prev;return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
        }function Tc(t, e, r, n) {
            var i = new Bc(t, e, r);return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }function zc(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }function Bc(t, e, r) {
            this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }function Ec(t, e, r, n) {
            for (var i = 0, s = e, a = r - n; s < r; s += n) i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;return i;
        }function Cc(t, e, r, n, i) {
            Pc(t, e, r || 0, n || t.length - 1, i || Vc);
        }function Pc(t, e, r, n, i) {
            for (; n > r;) {
                if (n - r > 600) {
                    var s = n - r + 1,
                        a = e - r + 1,
                        o = Math.log(s),
                        l = .5 * Math.exp(2 * o / 3),
                        u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);Pc(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);
                }var c = t[e],
                    h = r,
                    p = n;for (Dc(t, r, e), i(t[n], c) > 0 && Dc(t, r, n); h < p;) {
                    for (Dc(t, h, p), h++, p--; i(t[h], c) < 0;) h++;for (; i(t[p], c) > 0;) p--;
                }0 === i(t[r], c) ? Dc(t, r, p) : Dc(t, ++p, n), p <= e && (r = p + 1), e <= p && (n = p - 1);
            }
        }function Dc(t, e, r) {
            var n = t[e];t[e] = t[r], t[r] = n;
        }function Vc(t, e) {
            return t < e ? -1 : t > e ? 1 : 0;
        }function Lc(t, e) {
            const r = t.length;if (r <= 1) return [t];const n = [];let i, s;for (let e = 0; e < r; e++) {
                const r = q(t[e]);0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));
            }if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (Cc(n[t], e, 1, n[t].length - 1, Fc), n[t] = n[t].slice(0, e));return n;
        }function Fc(t, e) {
            return e.area - t.area;
        }function Rc(t, e, r) {
            const n = r.patternDependencies;let i = !1;for (const r of e) {
                const e = r.paint.get(`${t}-pattern`);e.isConstant() || (i = !0);const s = e.constantOr(null);s && (i = !0, n[s] = !0);
            }return i;
        }function jc(t, e, r, n, i) {
            const s = i.patternDependencies;for (const a of e) {
                const e = a.paint.get(`${t}-pattern`).value;if ("constant" !== e.kind) {
                    let t = e.evaluate({ zoom: n }, r, {}, i.availableImages);t = t && t.name ? t.name : t, s[t] = !0, r.patterns[a.id] = t;
                }
            }return r;
        }({ get exports() {
                return sc;
            }, set exports(t) {
                sc = t;
            } }).exports = ac, sc.default = ac, ac.deviation = function (t, e, r, n) {
            var i = e && e.length,
                s = Math.abs(Ec(t, 0, i ? e[0] * r : t.length, r));if (i) for (var a = 0, o = e.length; a < o; a++) s -= Math.abs(Ec(t, e[a] * r, a < o - 1 ? e[a + 1] * r : t.length, r));var l = 0;for (a = 0; a < n.length; a += 3) {
                var u = n[a] * r,
                    c = n[a + 1] * r,
                    h = n[a + 2] * r;l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));
            }return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);
        }, ac.flatten = function (t) {
            for (var e = t[0][0].length, r = { vertices: [], holes: [], dimensions: e }, n = 0, i = 0; i < t.length; i++) {
                for (var s = 0; s < t[i].length; s++) for (var a = 0; a < e; a++) r.vertices.push(t[i][s][a]);i > 0 && r.holes.push(n += t[i - 1].length);
            }return r;
        };class Uc {
            constructor(t) {
                this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.indexArray2 = new Ma(), this.programConfigurations = new fo(t.layers, t.zoom), this.segments = new So(), this.segments2 = new So(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection;
            }populate(t, e, r, n) {
                this.hasPattern = Rc("fill", this.layers, e);const i = this.layers[0].layout.get("fill-sort-key"),
                      s = [];for (const { feature: a, id: o, index: l, sourceLayerIndex: u } of t) {
                    const t = this.layers[0]._featureFilter.needGeometry,
                          c = wu(a, t);if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), c, r)) continue;const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,
                          p = { id: o, properties: a.properties, type: a.type, sourceLayerIndex: u, index: l, geometry: t ? c.geometry : bu(a, r, n), patterns: {}, sortKey: h };s.push(p);
                }i && s.sort((t, e) => t.sortKey - e.sortKey);for (const n of s) {
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;if (this.hasPattern) {
                        const t = jc("fill", this.layers, n, this.zoom, e);this.patternFeatures.push(t);
                    } else this.addFeature(n, i, s, r, {}, e.availableImages);e.featureIndex.insert(t[s].feature, i, s, a, this.index);
                }
            }update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }addFeatures(t, e, r, n, i) {
                for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);
            }isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ic), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
            }destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }addFeature(t, e, r, n, i, s = []) {
                for (const t of Lc(e, 500)) {
                    let e = 0;for (const r of t) e += r.length;const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),
                          n = r.vertexLength,
                          i = [],
                          s = [];for (const e of t) {
                        if (0 === e.length) continue;e !== t[0] && s.push(i.length / 2);const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),
                              n = r.vertexLength;this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);r.vertexLength += e.length, r.primitiveLength += e.length;
                    }const a = sc(i, s);for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(n + a[t], n + a[t + 1], n + a[t + 2]);r.vertexLength += e, r.primitiveLength += a.length / 3;
                }this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }
        }Oi(Uc, "FillBucket", { omit: ["layers", "patternFeatures"] });const $c = new Js({ "fill-sort-key": new Hs(Ht.layout_fill["fill-sort-key"]) });var Oc = { paint: new Js({ "fill-antialias": new Ys(Ht.paint_fill["fill-antialias"]), "fill-opacity": new Hs(Ht.paint_fill["fill-opacity"]), "fill-color": new Hs(Ht.paint_fill["fill-color"]), "fill-outline-color": new Hs(Ht.paint_fill["fill-outline-color"]), "fill-translate": new Ys(Ht.paint_fill["fill-translate"]), "fill-translate-anchor": new Ys(Ht.paint_fill["fill-translate-anchor"]), "fill-pattern": new Hs(Ht.paint_fill["fill-pattern"]) }), layout: $c };const qc = na([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]),
              Nc = na([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]),
              Gc = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]),
              { members: Xc } = qc;var Zc = {},
            Kc = d,
            Yc = Hc;function Hc(t, e, r, n, i) {
            this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(Wc, this, e);
        }function Wc(t, e, r) {
            1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {
                for (var r = t.readVarint() + t.pos; t.pos < r;) {
                    var n = e._keys[t.readVarint()],
                        i = e._values[t.readVarint()];e.properties[n] = i;
                }
            }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);
        }function Jc(t) {
            for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++) n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);return n;
        }Hc.types = ["Unknown", "Point", "LineString", "Polygon"], Hc.prototype.loadGeometry = function () {
            var t = this._pbf;t.pos = this._geometry;for (var e, r = t.readVarint() + t.pos, n = 1, i = 0, s = 0, a = 0, o = []; t.pos < r;) {
                if (i <= 0) {
                    var l = t.readVarint();n = 7 & l, i = l >> 3;
                }if (i--, 1 === n || 2 === n) s += t.readSVarint(), a += t.readSVarint(), 1 === n && (e && o.push(e), e = []), e.push(new Kc(s, a));else {
                    if (7 !== n) throw new Error("unknown command " + n);e && e.push(e[0].clone());
                }
            }return e && o.push(e), o;
        }, Hc.prototype.bbox = function () {
            var t = this._pbf;t.pos = this._geometry;for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {
                if (n <= 0) {
                    var c = t.readVarint();r = 7 & c, n = c >> 3;
                }if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error("unknown command " + r);
            }return [a, l, o, u];
        }, Hc.prototype.toGeoJSON = function (t, e, r) {
            var n,
                i,
                s = this.extent * Math.pow(2, r),
                a = this.extent * t,
                o = this.extent * e,
                l = this.loadGeometry(),
                u = Hc.types[this.type];function c(t) {
                for (var e = 0; e < t.length; e++) {
                    var r = t[e];t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90];
                }
            }switch (this.type) {case 1:
                    var h = [];for (n = 0; n < l.length; n++) h[n] = l[n][0];c(l = h);break;case 2:
                    for (n = 0; n < l.length; n++) c(l[n]);break;case 3:
                    for (l = function (t) {
                        var e = t.length;if (e <= 1) return [t];for (var r, n, i = [], s = 0; s < e; s++) {
                            var a = Jc(t[s]);0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [t[s]]) : r.push(t[s]));
                        }return r && i.push(r), i;
                    }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);}1 === l.length ? l = l[0] : u = "Multi" + u;var p = { type: "Feature", geometry: { type: u, coordinates: l }, properties: this.properties };return "id" in this && (p.id = this.id), p;
        };var Qc = Yc,
            th = eh;function eh(t, e) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(rh, this, e), this.length = this._features.length;
        }function rh(t, e, r) {
            15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {
                for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {
                    var n = t.readVarint() >> 3;e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;
                }return e;
            }(r));
        }eh.prototype.feature = function (t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");this._pbf.pos = this._features[t];var e = this._pbf.readVarint() + this._pbf.pos;return new Qc(this._pbf, e, this.extent, this._keys, this._values);
        };var nh = th;function ih(t, e, r) {
            if (3 === t) {
                var n = new nh(r, r.readVarint() + r.pos);n.length && (e[n.name] = n);
            }
        }var sh = Zc.VectorTile = function (t, e) {
            this.layers = t.readFields(ih, {}, e);
        },
            ah = Zc.VectorTileFeature = Yc;function oh(t, e, r, n) {
            const i = [],
                  s = 0 === n ? (t, e, r, n, i, s) => {
                t.push(new d(s, r + (s - e) / (n - e) * (i - r)));
            } : (t, e, r, n, i, s) => {
                t.push(new d(e + (s - r) / (i - r) * (n - e), s));
            };for (const a of t) {
                const t = [];for (const i of a) {
                    if (i.length <= 2) continue;const a = [];for (let t = 0; t < i.length - 1; t++) {
                        const o = i[t].x,
                              l = i[t].y,
                              u = i[t + 1].x,
                              c = i[t + 1].y,
                              h = 0 === n ? o : l,
                              p = 0 === n ? u : c;h < e ? p > e && s(a, o, l, u, c, e) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t]), p < e && h >= e && s(a, o, l, u, c, e), p > r && h <= r && s(a, o, l, u, c, r);
                    }let o = i[i.length - 1];const l = 0 === n ? o.x : o.y;l >= e && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t.push(a));
                }t.length && i.push(t);
            }return i;
        }Zc.VectorTileLayer = th;const lh = ah.types,
              uh = Math.pow(2, 13);function ch(t, e, r, n, i, s, a, o) {
            t.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * uh) << 1) + i, Math.round(o));
        }function hh(t, e, r) {
            const n = 16384;t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }class ph {
            constructor() {
                this.acc = new d(0, 0), this.polyCount = [];
            }startRing(t) {
                this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d(t.x, t.y), this.max = new d(t.x, t.y));
            }append(t, e) {
                this.currentPolyCount.edges++, this.acc._add(t);const r = this.min,
                      n = this.max;t.x < r.x ? r.x = t.x : t.x > n.x && (n.x = t.x), t.y < r.y ? r.y = t.y : t.y > n.y && (n.y = t.y), ((0 === t.x || t.x === ko) && t.x === e.x) != ((0 === t.y || t.y === ko) && t.y === e.y) && this.processBorderOverlap(t, e), e.x < 0 != t.x < 0 && this.addBorderIntersection(0, Mr(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > ko != t.x > ko && this.addBorderIntersection(1, Mr(e.y, t.y, (ko - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, Mr(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > ko != t.y > ko && this.addBorderIntersection(3, Mr(e.x, t.x, (ko - e.y) / (t.y - e.y)));
            }addBorderIntersection(t, e) {
                this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);const r = this.borders[t];e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
            }processBorderOverlap(t, e) {
                if (t.x === e.x) {
                    if (t.y === e.y) return;const r = 0 === t.x ? 0 : 1;this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);
                } else {
                    const r = 0 === t.y ? 2 : 3;this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);
                }
            }centroid() {
                const t = this.polyCount.reduce((t, e) => t + e.edges, 0);return 0 !== t ? this.acc.div(t)._round() : new d(0, 0);
            }span() {
                return new d(this.max.x - this.min.x, this.max.y - this.min.y);
            }intersectsCount() {
                return this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0);
            }
        }class fh {
            constructor(t) {
                this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t.projection, this.layoutVertexArray = new oa(), this.centroidVertexArray = new Ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t.layers, t.zoom), this.segments = new So(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.enableTerrain = t.enableTerrain;
            }populate(t, e, r, n) {
                this.features = [], this.hasPattern = Rc("fill-extrusion", this.layers, e), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function (t) {
                    const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));return 80150034 * e / (e * e + 1) / ko / (1 << t.z);
                }(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;for (const { feature: i, id: s, index: a, sourceLayerIndex: o } of t) {
                    const t = this.layers[0]._featureFilter.needGeometry,
                          l = wu(i, t);if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), l, r)) continue;const u = { id: s, sourceLayerIndex: o, index: a, geometry: t ? l.geometry : bu(i, r, n), properties: i.properties, type: i.type, patterns: {} },
                          c = this.layoutVertexArray.length;this.hasPattern ? this.features.push(jc("fill-extrusion", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n), e.featureIndex.insert(i, u.geometry, a, o, this.index, c);
                }this.sortBorders();
            }addFeatures(t, e, r, n, i) {
                for (const t of this.features) {
                    const { geometry: s } = t;this.addFeature(t, s, t.index, e, r, n, i);
                }this.sortBorders();
            }update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Xc), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Gc.members, !0))), this.programConfigurations.upload(t), this.uploaded = !0;
            }uploadCentroid(t) {
                0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Nc.members, !0), this.needsCentroidUpdate = !1);
            }destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }addFeature(t, e, r, n, i, s, a) {
                const o = [new d(0, 0), new d(ko, ko)],
                      l = a.projection,
                      u = "globe" === l.name,
                      c = this.enableTerrain && !u ? new ph() : null,
                      h = "Polygon" === lh[t.type];u && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa());const p = Lc(e, 500);for (let t = p.length - 1; t >= 0; t--) {
                    const e = p[t];(0 === e.length || (f = e[0]).every(t => t.x <= 0) || f.every(t => t.x >= ko) || f.every(t => t.y <= 0) || f.every(t => t.y >= ko)) && p.splice(t, 1);
                }var f;let y;if (u) y = wh(p, o, n);else {
                    y = [];for (const t of p) y.push({ polygon: t, bounds: o });
                }const m = h ? this.edgeRadius : 0;for (const { polygon: t, bounds: e } of y) {
                    let r = 0,
                        i = 0;for (const e of t) h && !e[0].equals(e[e.length - 1]) && e.push(e[0]), i += h ? e.length - 1 : e.length;const s = this.segments.prepareSegment((h ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);if (h) {
                        const e = [],
                              i = [];r = s.vertexLength;for (const r of t) {
                            let a, o;r.length && r !== t[0] && i.push(e.length / 2), a = r[1].sub(r[0])._perp()._unit();for (let t = 1; t < r.length; t++) {
                                const i = r[t],
                                      c = r[t === r.length - 1 ? 1 : t + 1];let { x: h, y: p } = i;if (m) {
                                    o = c.sub(i)._perp()._unit();const t = a.add(o)._unit(),
                                          e = m * Math.min(4, 1 / (a.x * t.x + a.y * t.y));h += e * t.x, p += e * t.y, a = o;
                                }ch(this.layoutVertexArray, h, p, 0, 0, 1, 1, 0), s.vertexLength++, e.push(i.x, i.y), u && hh(this.layoutVertexExtArray, l.projectTilePoint(h, p, n), l.upVector(n, h, p));
                            }
                        }const a = sc(e, i);for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(r + a[t], r + a[t + 2], r + a[t + 1]), s.primitiveLength++;
                    }for (const i of t) {
                        c && i.length && c.startRing(i[0]);let t,
                            a,
                            o,
                            p = i.length > 4 && xh(i[i.length - 2], i[0], i[1]),
                            f = m ? yh(i[i.length - 2], i[0], i[1], m) : 0;a = i[1].sub(i[0])._perp()._unit();let d = !0;for (let y = 1, g = 0; y < i.length; y++) {
                            let x = i[y - 1],
                                v = i[y];const b = i[y === i.length - 1 ? 1 : y + 1];if (c && h && c.currentPolyCount.top++, gh(v, x, e)) {
                                m && (a = b.sub(v)._perp()._unit(), d = !d);continue;
                            }c && c.append(v, x);const w = v.sub(x)._perp(),
                                  _ = w.x / (Math.abs(w.x) + Math.abs(w.y)),
                                  A = w.y > 0 ? 1 : 0,
                                  S = x.dist(v);if (g + S > 32768 && (g = 0), m) {
                                o = b.sub(v)._perp()._unit();let t = mh(x, v, b, dh(a, o), m);isNaN(t) && (t = 0);const e = v.sub(x)._unit();x = x.add(e.mult(f))._round(), v = v.add(e.mult(-t))._round(), f = t, a = o;
                            }const k = s.vertexLength,
                                  I = i.length > 4 && xh(x, v, b);let M = vh(g, p, d);if (ch(this.layoutVertexArray, x.x, x.y, _, A, 0, 0, M), ch(this.layoutVertexArray, x.x, x.y, _, A, 0, 1, M), g += S, M = vh(g, I, !d), p = I, ch(this.layoutVertexArray, v.x, v.y, _, A, 0, 0, M), ch(this.layoutVertexArray, v.x, v.y, _, A, 0, 1, M), s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, m) {
                                const n = r + (1 === y ? i.length - 2 : y - 2),
                                      a = 1 === y ? r : n + 1;if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, a, k + 3), s.primitiveLength += 2, void 0 === t && (t = k), !gh(b, i[y], e)) {
                                    const e = y === i.length - 1 ? t : s.vertexLength;this.indexArray.emplaceBack(k + 2, k + 3, e), this.indexArray.emplaceBack(k + 3, e + 1, e), this.indexArray.emplaceBack(k + 3, a, e + 1), s.primitiveLength += 3;
                                }d = !d;
                            }if (u) {
                                const t = this.layoutVertexExtArray,
                                      e = l.projectTilePoint(x.x, x.y, n),
                                      r = l.projectTilePoint(v.x, v.y, n),
                                      i = l.upVector(n, x.x, x.y),
                                      s = l.upVector(n, v.x, v.y);hh(t, e, i), hh(t, e, i), hh(t, r, s), hh(t, r, s);
                            }
                        }h && (r += i.length - 1);
                    }
                }if (c && c.polyCount.length > 0) {
                    if (c.borders) {
                        c.vertexArrayOffset = this.centroidVertexArray.length;const t = c.borders,
                              e = this.featuresOnBorder.push(c) - 1;for (let r = 0; r < 4; r++) t[r][0] !== Number.MAX_VALUE && this.borders[r].push(e);
                    }this.encodeCentroid(c.borders ? void 0 : c.centroid(), c);
                }this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }sortBorders() {
                for (let t = 0; t < 4; t++) this.borders[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);
            }encodeCentroid(t, e, r = !0) {
                let n, i;if (t) {
                    if (0 !== t.y) {
                        const r = e.span()._mult(this.tileToMeter);n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));
                    } else n = Math.ceil(7 * (t.x + 450)), i = 0;
                } else n = 0, i = +r;let s = r ? this.centroidVertexArray.length : e.vertexArrayOffset;for (const t of e.polyCount) {
                    r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);for (let e = 0; e < t.top; e++) this.centroidVertexArray.emplace(s++, n, i);for (let e = 0; e < 2 * t.edges; e++) this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);
                }
            }
        }function dh(t, e) {
            const r = t.add(e)._unit();return t.x * r.x + t.y * r.y;
        }function yh(t, e, r, n) {
            const i = e.sub(t)._perp()._unit(),
                  s = r.sub(e)._perp()._unit();return mh(t, e, r, dh(i, s), n);
        }function mh(t, e, r, n, i) {
            const s = Math.sqrt(1 - n * n);return Math.min(t.dist(e) / 3, e.dist(r) / 3, i * s / n);
        }function gh(t, e, r) {
            return t.x < r[0].x && e.x < r[0].x || t.x > r[1].x && e.x > r[1].x || t.y < r[0].y && e.y < r[0].y || t.y > r[1].y && e.y > r[1].y;
        }function xh(t, e, r) {
            if (t.x < 0 || t.x >= ko || e.x < 0 || e.x >= ko || r.x < 0 || r.x >= ko) return !1;const n = r.sub(e),
                  i = n.perp(),
                  s = t.sub(e);return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0;
        }function vh(t, e, r) {
            const n = e ? 2 | t : -3 & t;return r ? 1 | n : -2 & n;
        }function bh() {
            const t = Math.PI / 32,
                  e = Math.tan(t),
                  r = tu;return r * Math.sqrt(1 + 2 * e * e) - r;
        }function wh(t, e, r) {
            const n = 1 << r.z,
                  i = ou(r.x / n),
                  s = ou((r.x + 1) / n),
                  a = lu(r.y / n),
                  o = lu((r.y + 1) / n);return function (t, e, r, n, i = 0, s) {
                const a = [];if (!t.length || !r || !n) return a;const o = (t, e) => {
                    for (const r of t) a.push({ polygon: r, bounds: e });
                },
                      l = Math.ceil(Math.log2(r)),
                      u = Math.ceil(Math.log2(n)),
                      c = l - u,
                      h = [];for (let t = 0; t < Math.abs(c); t++) h.push(c > 0 ? 0 : 1);for (let t = 0; t < Math.min(l, u); t++) h.push(0), h.push(1);let p = t;if (p = oh(p, e[0].y - i, e[1].y + i, 1), p = oh(p, e[0].x - i, e[1].x + i, 0), !p.length) return a;const f = [];for (h.length ? f.push({ polygons: p, bounds: e, depth: 0 }) : o(p, e); f.length;) {
                    const t = f.pop(),
                          e = t.depth,
                          r = h[e],
                          n = t.bounds[0],
                          a = t.bounds[1],
                          l = 0 === r ? n.x : n.y,
                          u = 0 === r ? a.x : a.y,
                          c = s ? s(r, l, u) : .5 * (l + u),
                          p = oh(t.polygons, l - i, c + i, r),
                          y = oh(t.polygons, c - i, u + i, r);if (p.length) {
                        const t = [n, new d(0 === r ? c : a.x, 1 === r ? c : a.y)];h.length > e + 1 ? f.push({ polygons: p, bounds: t, depth: e + 1 }) : o(p, t);
                    }if (y.length) {
                        const t = [new d(0 === r ? c : n.x, 1 === r ? c : n.y), a];h.length > e + 1 ? f.push({ polygons: y, bounds: t, depth: e + 1 }) : o(y, t);
                    }
                }return a;
            }(t, e, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t, e, i) => {
                if (0 === t) return .5 * (e + i);{
                    const t = lu((r.y + e / ko) / n);return (su(.5 * (lu((r.y + i / ko) / n) + t)) * n - r.y) * ko;
                }
            });
        }Oi(fh, "FillExtrusionBucket", { omit: ["layers", "features"] }), Oi(ph, "PartMetadata");const _h = new Js({ "fill-extrusion-edge-radius": new Ys(Ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });var Ah = { paint: new Js({ "fill-extrusion-opacity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]) }), layout: _h };function Sh(t, e, r) {
            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];
        }class kh {
            constructor(t, e, r) {
                this.z = t, this.x = e, this.y = r, this.key = Th(0, t, t, e, r);
            }equals(t) {
                return this.z === t.z && this.x === t.x && this.y === t.y;
            }url(t, e) {
                const r = function (t, e, r) {
                    var n = Sh(256 * t, 256 * (e = Math.pow(2, r) - e - 1), r),
                        i = Sh(256 * (t + 1), 256 * (e + 1), r);return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
                }(this.x, this.y, this.z),
                      n = function (t, e, r) {
                    let n,
                        i = "";for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);return i;
                }(this.z, this.x, this.y);return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
            }toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }class Ih {
            constructor(t, e) {
                this.wrap = t, this.canonical = e, this.key = Th(t, e.z, e.z, e.x, e.y);
            }
        }class Mh {
            constructor(t, e, r, n, i) {
                this.overscaledZ = t, this.wrap = e, this.canonical = new kh(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : Th(e, t, r, n, i);
            }equals(t) {
                return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
            }scaledTo(t) {
                const e = this.canonical.z - t;return t > this.canonical.z ? new Mh(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Mh(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);
            }calculateScaledKey(t, e = !0) {
                if (this.overscaledZ === t && e) return this.key;if (t > this.canonical.z) return Th(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);{
                    const r = this.canonical.z - t;return Th(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);
                }
            }isChildOf(t) {
                if (t.wrap !== this.wrap) return !1;const e = this.canonical.z - t.canonical.z;return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;
            }children(t) {
                if (this.overscaledZ >= t) return [new Mh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];const e = this.canonical.z + 1,
                      r = 2 * this.canonical.x,
                      n = 2 * this.canonical.y;return [new Mh(e, this.wrap, e, r, n), new Mh(e, this.wrap, e, r + 1, n), new Mh(e, this.wrap, e, r, n + 1), new Mh(e, this.wrap, e, r + 1, n + 1)];
            }isLessThan(t) {
                return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
            }wrapped() {
                return new Mh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }unwrapTo(t) {
                return new Mh(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
            }overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }toUnwrapped() {
                return new Ih(this.wrap, this.canonical);
            }toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }function Th(t, e, r, n, i) {
            const s = 1 << Math.min(r, 22);let a = s * (i % s) + n % s;return t && r < 22 && (a += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);
        }Oi(kh, "CanonicalTileID"), Oi(Mh, "OverscaledTileID", { omit: ["projMatrix"] });class zh extends d {
            constructor(t, e, r) {
                super(t, e), this.z = r;
            }
        }function Bh(t, e) {
            return t.x * e.x + t.y * e.y;
        }function Eh(t, e) {
            if (1 === t.length) {
                let r = 0;const n = e[r++];let i;for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;for (; r < e.length; r++) {
                    const s = e[r],
                          a = t[0],
                          o = i.sub(n),
                          l = s.sub(n),
                          u = a.sub(n),
                          c = Bh(o, o),
                          h = Bh(o, l),
                          p = Bh(l, l),
                          f = Bh(u, o),
                          d = Bh(u, l),
                          y = c * p - h * h,
                          m = (p * f - h * d) / y,
                          g = (c * d - h * f) / y,
                          x = n.z * (1 - m - g) + i.z * m + s.z * g;if (isFinite(x)) return x;
                }return 1 / 0;
            }{
                let t = 1 / 0;for (const r of e) t = Math.min(t, r.z);return t;
            }
        }function Ch(t, e, r, n, i, s, a, o) {
            const l = a * i.getElevationAt(t, e, !0, !0),
                  u = 0 !== s[0],
                  c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function (t, e, r) {
                const n = Math.floor(e[0] / 8),
                      i = Math.floor(e[1] / 8),
                      s = 10 * (e[0] - 8 * n),
                      a = 10 * (e[1] - 8 * i),
                      o = t.getElevationAt(n, i, !0, !0),
                      l = t.getMeterToDEM(r),
                      u = Math.floor(.5 * (s * l - 1)),
                      c = Math.floor(.5 * (a * l - 1)),
                      h = t.tileCoordToPixel(n, i),
                      p = 2 * u + 1,
                      f = 2 * c + 1,
                      d = function (t, e, r, n, i) {
                    return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];
                }(t, h.x - u, h.y - c, p, f),
                      y = Math.abs(d[0] - d[1]),
                      m = Math.abs(d[2] - d[3]),
                      g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]),
                      x = Math.min(.25, .5 * l * (y + m) / p),
                      v = Math.min(.25, .5 * l * g / f);return o + Math.max(x * s, v * a);
            }(i, s, o) : l;return { base: l + (0 === r) ? -1 : r, top: u ? Math.max(c + n, l + r + 2) : l + n };
        }const Ph = na([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4),
              { members: Dh } = Ph,
              Vh = na([{ name: "a_packed", components: 4, type: "Float32" }]),
              { members: Lh } = Vh,
              Fh = ah.types,
              Rh = Math.cos(Math.PI / 180 * 37.5);class jh {
            constructor(t) {
                this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {
                    this.gradients[t.id] = {};
                }), this.layoutVertexArray = new la(), this.layoutVertexArray2 = new ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t.layers, t.zoom), this.segments = new So(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);
            }populate(t, e, r, n) {
                this.hasPattern = Rc("line", this.layers, e);const i = this.layers[0].layout.get("line-sort-key"),
                      s = [];for (const { feature: e, id: a, index: o, sourceLayerIndex: l } of t) {
                    const t = this.layers[0]._featureFilter.needGeometry,
                          u = wu(e, t);if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u, r)) continue;const c = i ? i.evaluate(u, {}, r) : void 0,
                          h = { id: a, properties: e.properties, type: e.type, sourceLayerIndex: l, index: o, geometry: t ? u.geometry : bu(e, r, n), patterns: {}, sortKey: c };s.push(h);
                }i && s.sort((t, e) => t.sortKey - e.sortKey);const { lineAtlas: a, featureIndex: o } = e,
                      l = this.addConstantDashes(a);for (const n of s) {
                    const { geometry: i, index: s, sourceLayerIndex: u } = n;if (l && this.addFeatureDashes(n, a), this.hasPattern) {
                        const t = jc("line", this.layers, n, this.zoom, e);this.patternFeatures.push(t);
                    } else this.addFeature(n, i, s, r, a.positions, e.availableImages);o.insert(t[s].feature, i, s, u, this.index);
                }
            }addConstantDashes(t) {
                let e = !1;for (const r of this.layers) {
                    const n = r.paint.get("line-dasharray").value,
                          i = r.layout.get("line-cap").value;if ("constant" !== n.kind || "constant" !== i.kind) e = !0;else {
                        const e = i.value,
                              r = n.value;if (!r) continue;t.addDash(r, e);
                    }
                }return e;
            }addFeatureDashes(t, e) {
                const r = this.zoom;for (const n of this.layers) {
                    const i = n.paint.get("line-dasharray").value,
                          s = n.layout.get("line-cap").value;if ("constant" === i.kind && "constant" === s.kind) continue;let a, o;if ("constant" === i.kind) {
                        if (a = i.value, !a) continue;
                    } else a = i.evaluate({ zoom: r }, t);o = "constant" === s.kind ? s.value : s.evaluate({ zoom: r }, t), e.addDash(a, o), t.patterns[n.id] = e.getKey(a, o);
                }
            }update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }addFeatures(t, e, r, n, i) {
                for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);
            }isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }upload(t) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Lh)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Dh), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
            }destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }lineFeatureClips(t) {
                if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
            }addFeature(t, e, r, n, i, s) {
                const a = this.layers[0].layout,
                      o = a.get("line-join").evaluate(t, {}),
                      l = a.get("line-cap").evaluate(t, {}),
                      u = a.get("line-miter-limit"),
                      c = a.get("line-round-limit");this.lineClips = this.lineFeatureClips(t);for (const r of e) this.addLine(r, t, o, l, u, c);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }addLine(t, e, r, n, i, s) {
                if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }const a = "Polygon" === Fh[e.type];let o = t.length;for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;let l = 0;for (; l < o - 1 && t[l].equals(t[l + 1]);) l++;if (o < (a ? 3 : 2)) return;"bevel" === r && (i = 1.05);const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
                      c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);let h, p, f, d, y;this.e1 = this.e2 = -1, a && (h = t[o - 2], y = t[l].sub(h)._unit()._perp());for (let e = l; e < o; e++) {
                    if (f = e === o - 1 ? a ? t[l + 1] : void 0 : t[e + 1], f && t[e].equals(f)) continue;y && (d = y), h && (p = h), h = t[e], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;let m = d.add(y);0 === m.x && 0 === m.y || m._unit();const g = d.x * y.x + d.y * y.y,
                          x = m.x * y.x + m.y * y.y,
                          v = 0 !== x ? 1 / x : 1 / 0,
                          b = 2 * Math.sqrt(2 - 2 * x),
                          w = x < Rh && p && f,
                          _ = d.x * y.y - d.y * y.x > 0;if (w && e > l) {
                        const t = h.dist(p);if (t > 2 * u) {
                            const e = h.sub(h.sub(p)._mult(u / t)._round());this.updateDistance(p, e), this.addCurrentVertex(e, d, 0, 0, c), p = e;
                        }
                    }const A = p && f;let S = A ? r : a ? "butt" : n;if (A && "round" === S && (v < s ? S = "miter" : v <= 2 && (S = "fakeround")), "miter" === S && v > i && (S = "bevel"), "bevel" === S && (v > 2 && (S = "flipbevel"), v < i && (S = "miter")), p && this.updateDistance(p, h), "miter" === S) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);else if ("flipbevel" === S) {
                        if (v > 100) m = y.mult(-1);else {
                            const t = v * d.add(y).mag() / d.sub(y).mag();m._perp()._mult(t * (_ ? -1 : 1));
                        }this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);
                    } else if ("bevel" === S || "fakeround" === S) {
                        const t = -Math.sqrt(v * v - 1),
                              e = _ ? t : 0,
                              r = _ ? 0 : t;if (p && this.addCurrentVertex(h, d, e, r, c), "fakeround" === S) {
                            const t = Math.round(180 * b / Math.PI / 20);for (let e = 1; e < t; e++) {
                                let r = e / t;if (.5 !== r) {
                                    const t = r - .5;r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));
                                }const n = y.sub(d)._mult(r)._add(d)._unit()._mult(_ ? -1 : 1);this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);
                            }
                        }f && this.addCurrentVertex(h, y, -e, -r, c);
                    } else if ("butt" === S) this.addCurrentVertex(h, m, 0, 0, c);else if ("square" === S) {
                        const t = p ? 1 : -1;p || this.addCurrentVertex(h, m, t, t, c), this.addCurrentVertex(h, m, 0, 0, c), p && this.addCurrentVertex(h, m, t, t, c);
                    } else "round" === S && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));if (w && e < o - 1) {
                        const t = h.dist(f);if (t > 2 * u) {
                            const e = h.add(f.sub(h)._mult(u / t)._round());this.updateDistance(h, e), this.addCurrentVertex(e, y, 0, 0, c), h = e;
                        }
                    }
                }
            }addCurrentVertex(t, e, r, n, i, s = !1) {
                const a = e.y * n - e.x,
                      o = -e.y - e.x * n;this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a, o, s, !0, -n, i);
            }addHalfVertex({ x: t, y: e }, r, n, i, s, a, o) {
                this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);const l = o.vertexLength++;this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), s ? this.e2 = l : this.e1 = l;
            }updateScaledDistance() {
                if (this.lineClips) {
                    const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t * this.lineClips.start + this.distance;
                } else this.lineSoFar = this.distance;
            }updateDistance(t, e) {
                this.distance += t.dist(e), this.updateScaledDistance();
            }
        }Oi(jh, "LineBucket", { omit: ["layers", "patternFeatures"] });const Uh = new Js({ "line-cap": new Hs(Ht.layout_line["line-cap"]), "line-join": new Hs(Ht.layout_line["line-join"]), "line-miter-limit": new Ys(Ht.layout_line["line-miter-limit"]), "line-round-limit": new Ys(Ht.layout_line["line-round-limit"]), "line-sort-key": new Hs(Ht.layout_line["line-sort-key"]) });var $h = { paint: new Js({ "line-opacity": new Hs(Ht.paint_line["line-opacity"]), "line-color": new Hs(Ht.paint_line["line-color"]), "line-translate": new Ys(Ht.paint_line["line-translate"]), "line-translate-anchor": new Ys(Ht.paint_line["line-translate-anchor"]), "line-width": new Hs(Ht.paint_line["line-width"]), "line-gap-width": new Hs(Ht.paint_line["line-gap-width"]), "line-offset": new Hs(Ht.paint_line["line-offset"]), "line-blur": new Hs(Ht.paint_line["line-blur"]), "line-dasharray": new Hs(Ht.paint_line["line-dasharray"]), "line-pattern": new Hs(Ht.paint_line["line-pattern"]), "line-gradient": new Ws(Ht.paint_line["line-gradient"]), "line-trim-offset": new Ys(Ht.paint_line["line-trim-offset"]) }), layout: Uh };const Oh = new class extends Hs {
            possiblyEvaluate(t, e) {
                return e = new Us(Math.floor(e.zoom), { now: e.now, fadeDuration: e.fadeDuration, transition: e.transition }), super.possiblyEvaluate(t, e);
            }evaluate(t, e, r, n) {
                return e = z({}, e, { zoom: Math.floor(e.zoom) }), super.evaluate(t, e, r, n);
            }
        }($h.paint.properties["line-width"].specification);function qh(t, e) {
            return e > 0 ? e + 2 * t : t;
        }Oh.useIntegerZoom = !0;const Nh = na([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4),
              Gh = na([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4),
              Xh = na([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);na([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);const Zh = na([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]),
              Kh = na([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);const Yh = na([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4),
              Hh = na([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);na([{ name: "triangle", components: 3, type: "Uint16" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), na([{ type: "Float32", name: "offsetX" }]), na([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);var Wh = 24;const Jh = 128;function Qh(t, e) {
            const { expression: r } = e;if ("constant" === r.kind) return { kind: "constant", layoutSize: r.evaluate(new Us(t + 1)) };if ("source" === r.kind) return { kind: "source" };{
                const { zoomStops: e, interpolationType: n } = r;let i = 0;for (; i < e.length && e[i] <= t;) i++;i = Math.max(0, i - 1);let s = i;for (; s < e.length && e[s] < t + 1;) s++;s = Math.min(e.length - 1, s);const a = e[i],
                      o = e[s];return "composite" === r.kind ? { kind: "composite", minZoom: a, maxZoom: o, interpolationType: n } : { kind: "camera", minZoom: a, maxZoom: o, minSize: r.evaluate(new Us(a)), maxSize: r.evaluate(new Us(o)), interpolationType: n };
            }
        }function tp(t, { uSize: e, uSizeT: r }, { lowerSize: n, upperSize: i }) {
            return "source" === t.kind ? n / Jh : "composite" === t.kind ? Mr(n / Jh, i / Jh, r) : e;
        }function ep(t, e) {
            let r = 0,
                n = 0;if ("constant" === t.kind) n = t.layoutSize;else if ("source" !== t.kind) {
                const { interpolationType: i, minZoom: s, maxZoom: a } = t,
                      o = i ? S(Kr.interpolationFactor(i, e, s, a), 0, 1) : 0;"camera" === t.kind ? n = Mr(t.minSize, t.maxSize, o) : r = o;
            }return { uSizeT: r, uSize: n };
        }var rp = Object.freeze({ __proto__: null, getSizeData: Qh, evaluateSizeForFeature: tp, evaluateSizeForZoom: ep, SIZE_PACK_FACTOR: Jh });function np(t, e, r) {
            return t.sections.forEach(t => {
                t.text = function (t, e, r) {
                    const n = e.layout.get("text-transform").evaluate(r, {});return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), js.applyArabicShaping && (t = js.applyArabicShaping(t)), t;
                }(t.text, e, r);
            }), t;
        }const ip = { "!": "ï¸", "#": "ï¼", $: "ï¼", "%": "ï¼", "&": "ï¼", "(": "ï¸µ", ")": "ï¸¶", "*": "ï¼", "+": "ï¼", ",": "ï¸", "-": "ï¸²", ".": "ã»", "/": "ï¼", ":": "ï¸", ";": "ï¸", "<": "ï¸¿", "=": "ï¼", ">": "ï¹", "?": "ï¸", "@": "ï¼ ", "[": "ï¹", "\\": "ï¼¼", "]": "ï¹", "^": "ï¼¾", _: "ï¸³", "`": "ï½", "{": "ï¸·", "|": "â", "}": "ï¸¸", "~": "ï½", "Â¢": "ï¿ ", "Â£": "ï¿¡", "Â¥": "ï¿¥", "Â¦": "ï¿¤", "Â¬": "ï¿¢", "Â¯": "ï¿£", "â": "ï¸²", "â": "ï¸±", "â": "ï¹", "â": "ï¹", "â": "ï¹", "â": "ï¹", "â¦": "ï¸", "â§": "ã»", "â©": "ï¿¦", "ã": "ï¸", "ã": "ï¸", "ã": "ï¸¿", "ã": "ï¹", "ã": "ï¸½", "ã": "ï¸¾", "ã": "ï¹", "ã": "ï¹", "ã": "ï¹", "ã": "ï¹", "ã": "ï¸»", "ã": "ï¸¼", "ã": "ï¸¹", "ã": "ï¸º", "ã": "ï¸", "ã": "ï¸", "ï¼": "ï¸", "ï¼": "ï¸µ", "ï¼": "ï¸¶", "ï¼": "ï¸", "ï¼": "ï¸²", "ï¼": "ã»", "ï¼": "ï¸", "ï¼": "ï¸", "ï¼": "ï¸¿", "ï¼": "ï¹", "ï¼": "ï¸", "ï¼»": "ï¹", "ï¼½": "ï¹", "ï¼¿": "ï¸³", "ï½": "ï¸·", "ï½": "â", "ï½": "ï¸¸", "ï½": "ï¸µ", "ï½ ": "ï¸¶", "ï½¡": "ï¸", "ï½¢": "ï¹", "ï½£": "ï¹" };function sp(t) {
            return "ï¸¶" === t || "ï¹" === t || "ï¸¸" === t || "ï¹" === t || "ï¹" === t || "ï¸¾" === t || "ï¸¼" === t || "ï¸º" === t || "ï¸" === t || "ï¹" === t || "ï¸" === t || "ï¸" === t || "ï¸" === t || "ï½" === t || "ï¿£" === t || "ï¸" === t || "ï¸" === t;
        }function ap(t) {
            return "ï¸µ" === t || "ï¹" === t || "ï¸·" === t || "ï¹" === t || "ï¹" === t || "ï¸½" === t || "ï¸»" === t || "ï¸¹" === t || "ï¸" === t || "ï¸¿" === t;
        }var op = cp,
            lp = function (t, e, r, n, i) {
            var s,
                a,
                o = 8 * i - n - 1,
                l = (1 << o) - 1,
                u = l >> 1,
                c = -7,
                h = r ? i - 1 : 0,
                p = r ? -1 : 1,
                f = t[e + h];for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);if (0 === s) s = 1 - u;else {
                if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);a += Math.pow(2, n), s -= u;
            }return (f ? -1 : 1) * a * Math.pow(2, s - n);
        },
            up = function (t, e, r, n, i, s) {
            var a,
                o,
                l,
                u = 8 * s - i - 1,
                c = (1 << u) - 1,
                h = c >> 1,
                p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                f = n ? 0 : s - 1,
                d = n ? 1 : -1,
                y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8);for (a = a << i | o, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8);t[r + f - d] |= 128 * y;
        };
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */function cp(t) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }cp.Varint = 0, cp.Fixed64 = 1, cp.Bytes = 2, cp.Fixed32 = 5;var hp = 4294967296,
            pp = 1 / hp,
            fp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");function dp(t) {
            return t.type === cp.Bytes ? t.readVarint() + t.pos : t.pos + 1;
        }function yp(t, e, r) {
            return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);
        }function mp(t, e, r) {
            var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));r.realloc(n);for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];
        }function gp(t, e) {
            for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);
        }function xp(t, e) {
            for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);
        }function vp(t, e) {
            for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);
        }function bp(t, e) {
            for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);
        }function wp(t, e) {
            for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);
        }function _p(t, e) {
            for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);
        }function Ap(t, e) {
            for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);
        }function Sp(t, e) {
            for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);
        }function kp(t, e) {
            for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);
        }function Ip(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];
        }function Mp(t, e, r) {
            t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;
        }function Tp(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);
        }function zp(t, e, r) {
            e.glyphs = [], 1 === t && r.readMessage(Bp, e);
        }function Bp(t, e, r) {
            if (3 === t) {
                const { id: t, bitmap: n, width: i, height: s, left: a, top: o, advance: l } = r.readMessage(Ep, {});e.glyphs.push({ id: t, bitmap: new Ju({ width: i + 6, height: s + 6 }, n), metrics: { width: i, height: s, left: a, top: o, advance: l } });
            } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());
        }function Ep(t, e, r) {
            1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());
        }function Cp(t) {
            let e = 0,
                r = 0;for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);t.sort((t, e) => e.h - t.h);const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), r), h: 1 / 0 }];let i = 0,
                s = 0;for (const e of t) for (let t = n.length - 1; t >= 0; t--) {
                const r = n[t];if (!(e.w > r.w || e.h > r.h)) {
                    if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {
                        const e = n.pop();t < n.length && (n[t] = e);
                    } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({ x: r.x + e.w, y: r.y, w: r.w - e.w, h: e.h }), r.y += e.h, r.h -= e.h);break;
                }
            }return { w: i, h: s, fill: e / (i * s) || 0 };
        }cp.prototype = { destroy: function () {
                this.buf = null;
            }, readFields: function (t, e, r) {
                for (r = r || this.length; this.pos < r;) {
                    var n = this.readVarint(),
                        i = n >> 3,
                        s = this.pos;this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);
                }return e;
            }, readMessage: function (t, e) {
                return this.readFields(t, e, this.readVarint() + this.pos);
            }, readFixed32: function () {
                var t = Ip(this.buf, this.pos);return this.pos += 4, t;
            }, readSFixed32: function () {
                var t = Tp(this.buf, this.pos);return this.pos += 4, t;
            }, readFixed64: function () {
                var t = Ip(this.buf, this.pos) + Ip(this.buf, this.pos + 4) * hp;return this.pos += 8, t;
            }, readSFixed64: function () {
                var t = Ip(this.buf, this.pos) + Tp(this.buf, this.pos + 4) * hp;return this.pos += 8, t;
            }, readFloat: function () {
                var t = lp(this.buf, this.pos, !0, 23, 4);return this.pos += 4, t;
            }, readDouble: function () {
                var t = lp(this.buf, this.pos, !0, 52, 8);return this.pos += 8, t;
            }, readVarint: function (t) {
                var e,
                    r,
                    n = this.buf;return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {
                    var n,
                        i,
                        s = r.buf;if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return yp(t, n, e);if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return yp(t, n, e);if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return yp(t, n, e);if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return yp(t, n, e);if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return yp(t, n, e);if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return yp(t, n, e);throw new Error("Expected varint not more than 10 bytes");
                }(e |= (15 & (r = n[this.pos])) << 28, t, this))));
            }, readVarint64: function () {
                return this.readVarint(!0);
            }, readSVarint: function () {
                var t = this.readVarint();return t % 2 == 1 ? (t + 1) / -2 : t / 2;
            }, readBoolean: function () {
                return Boolean(this.readVarint());
            }, readString: function () {
                var t = this.readVarint() + this.pos,
                    e = this.pos;return this.pos = t, t - e >= 12 && fp ? function (t, e, r) {
                    return fp.decode(t.subarray(e, r));
                }(this.buf, e, t) : function (t, e, r) {
                    for (var n = "", i = e; i < r;) {
                        var s,
                            a,
                            o,
                            l = t[i],
                            u = null,
                            c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;if (i + c > r) break;1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
                    }return n;
                }(this.buf, e, t);
            }, readBytes: function () {
                var t = this.readVarint() + this.pos,
                    e = this.buf.subarray(this.pos, t);return this.pos = t, e;
            }, readPackedVarint: function (t, e) {
                if (this.type !== cp.Bytes) return t.push(this.readVarint(e));var r = dp(this);for (t = t || []; this.pos < r;) t.push(this.readVarint(e));return t;
            }, readPackedSVarint: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readSVarint());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readSVarint());return t;
            }, readPackedBoolean: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readBoolean());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readBoolean());return t;
            }, readPackedFloat: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readFloat());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readFloat());return t;
            }, readPackedDouble: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readDouble());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readDouble());return t;
            }, readPackedFixed32: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readFixed32());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readFixed32());return t;
            }, readPackedSFixed32: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readSFixed32());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readSFixed32());return t;
            }, readPackedFixed64: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readFixed64());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readFixed64());return t;
            }, readPackedSFixed64: function (t) {
                if (this.type !== cp.Bytes) return t.push(this.readSFixed64());var e = dp(this);for (t = t || []; this.pos < e;) t.push(this.readSFixed64());return t;
            }, skip: function (t) {
                var e = 7 & t;if (e === cp.Varint) for (; this.buf[this.pos++] > 127;);else if (e === cp.Bytes) this.pos = this.readVarint() + this.pos;else if (e === cp.Fixed32) this.pos += 4;else {
                    if (e !== cp.Fixed64) throw new Error("Unimplemented type: " + e);this.pos += 8;
                }
            }, writeTag: function (t, e) {
                this.writeVarint(t << 3 | e);
            }, realloc: function (t) {
                for (var e = this.length || 16; e < this.pos + t;) e *= 2;if (e !== this.length) {
                    var r = new Uint8Array(e);r.set(this.buf), this.buf = r, this.length = e;
                }
            }, finish: function () {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            }, writeFixed32: function (t) {
                this.realloc(4), Mp(this.buf, t, this.pos), this.pos += 4;
            }, writeSFixed32: function (t) {
                this.realloc(4), Mp(this.buf, t, this.pos), this.pos += 4;
            }, writeFixed64: function (t) {
                this.realloc(8), Mp(this.buf, -1 & t, this.pos), Mp(this.buf, Math.floor(t * pp), this.pos + 4), this.pos += 8;
            }, writeSFixed64: function (t) {
                this.realloc(8), Mp(this.buf, -1 & t, this.pos), Mp(this.buf, Math.floor(t * pp), this.pos + 4), this.pos += 8;
            }, writeVarint: function (t) {
                (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {
                    var r, n;if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10), function (t, e, r) {
                        r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);
                    }(r, 0, e), function (t, e) {
                        var r = (7 & t) << 4;e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));
                    }(n, e);
                }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
            }, writeSVarint: function (t) {
                this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
            }, writeBoolean: function (t) {
                this.writeVarint(Boolean(t));
            }, writeString: function (t) {
                t = String(t), this.realloc(4 * t.length), this.pos++;var e = this.pos;this.pos = function (t, e, r) {
                    for (var n, i, s = 0; s < e.length; s++) {
                        if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;continue;
                            }if (n < 56320) {
                                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;continue;
                            }n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                        } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);
                    }return r;
                }(this.buf, t, this.pos);var r = this.pos - e;r >= 128 && mp(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
            }, writeFloat: function (t) {
                this.realloc(4), up(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;
            }, writeDouble: function (t) {
                this.realloc(8), up(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;
            }, writeBytes: function (t) {
                var e = t.length;this.writeVarint(e), this.realloc(e);for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];
            }, writeRawMessage: function (t, e) {
                this.pos++;var r = this.pos;t(e, this);var n = this.pos - r;n >= 128 && mp(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
            }, writeMessage: function (t, e, r) {
                this.writeTag(t, cp.Bytes), this.writeRawMessage(e, r);
            }, writePackedVarint: function (t, e) {
                e.length && this.writeMessage(t, gp, e);
            }, writePackedSVarint: function (t, e) {
                e.length && this.writeMessage(t, xp, e);
            }, writePackedBoolean: function (t, e) {
                e.length && this.writeMessage(t, wp, e);
            }, writePackedFloat: function (t, e) {
                e.length && this.writeMessage(t, vp, e);
            }, writePackedDouble: function (t, e) {
                e.length && this.writeMessage(t, bp, e);
            }, writePackedFixed32: function (t, e) {
                e.length && this.writeMessage(t, _p, e);
            }, writePackedSFixed32: function (t, e) {
                e.length && this.writeMessage(t, Ap, e);
            }, writePackedFixed64: function (t, e) {
                e.length && this.writeMessage(t, Sp, e);
            }, writePackedSFixed64: function (t, e) {
                e.length && this.writeMessage(t, kp, e);
            }, writeBytesField: function (t, e) {
                this.writeTag(t, cp.Bytes), this.writeBytes(e);
            }, writeFixed32Field: function (t, e) {
                this.writeTag(t, cp.Fixed32), this.writeFixed32(e);
            }, writeSFixed32Field: function (t, e) {
                this.writeTag(t, cp.Fixed32), this.writeSFixed32(e);
            }, writeFixed64Field: function (t, e) {
                this.writeTag(t, cp.Fixed64), this.writeFixed64(e);
            }, writeSFixed64Field: function (t, e) {
                this.writeTag(t, cp.Fixed64), this.writeSFixed64(e);
            }, writeVarintField: function (t, e) {
                this.writeTag(t, cp.Varint), this.writeVarint(e);
            }, writeSVarintField: function (t, e) {
                this.writeTag(t, cp.Varint), this.writeSVarint(e);
            }, writeStringField: function (t, e) {
                this.writeTag(t, cp.Bytes), this.writeString(e);
            }, writeFloatField: function (t, e) {
                this.writeTag(t, cp.Fixed32), this.writeFloat(e);
            }, writeDoubleField: function (t, e) {
                this.writeTag(t, cp.Fixed64), this.writeDouble(e);
            }, writeBooleanField: function (t, e) {
                this.writeVarintField(t, Boolean(e));
            } };class Pp {
            constructor(t, { pixelRatio: e, version: r, stretchX: n, stretchY: i, content: s }) {
                this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;
            }get tl() {
                return [this.paddedRect.x + 1, this.paddedRect.y + 1];
            }get br() {
                return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
            }get displaySize() {
                return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
            }
        }class Dp {
            constructor(t, e) {
                const r = {},
                      n = {};this.haveRenderCallbacks = [];const i = [];this.addImages(t, r, i), this.addImages(e, n, i);const { w: s, h: a } = Cp(i),
                      o = new Qu({ width: s || 1, height: a || 1 });for (const e in t) {
                    const n = t[e],
                          i = r[e].paddedRect;Qu.copy(n.data, o, { x: 0, y: 0 }, { x: i.x + 1, y: i.y + 1 }, n.data);
                }for (const t in e) {
                    const r = e[t],
                          i = n[t].paddedRect,
                          s = i.x + 1,
                          a = i.y + 1,
                          l = r.data.width,
                          u = r.data.height;Qu.copy(r.data, o, { x: 0, y: 0 }, { x: s, y: a }, r.data), Qu.copy(r.data, o, { x: 0, y: u - 1 }, { x: s, y: a - 1 }, { width: l, height: 1 }), Qu.copy(r.data, o, { x: 0, y: 0 }, { x: s, y: a + u }, { width: l, height: 1 }), Qu.copy(r.data, o, { x: l - 1, y: 0 }, { x: s - 1, y: a }, { width: 1, height: u }), Qu.copy(r.data, o, { x: 0, y: 0 }, { x: s + l, y: a }, { width: 1, height: u });
                }this.image = o, this.iconPositions = r, this.patternPositions = n;
            }addImages(t, e, r) {
                for (const n in t) {
                    const i = t[n],
                          s = { x: 0, y: 0, w: i.data.width + 2, h: i.data.height + 2 };r.push(s), e[n] = new Pp(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);
                }
            }patchUpdatedImages(t, e) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e)), t.dispatchRenderCallbacks(this.haveRenderCallbacks);for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);
            }patchUpdatedImage(t, e, r) {
                if (!t || !e) return;if (t.version === e.version) return;t.version = e.version;const [n, i] = t.tl;r.update(e.data, void 0, { x: n, y: i });
            }
        }Oi(Pp, "ImagePosition"), Oi(Dp, "ImageAtlas");const Vp = { horizontal: 1, vertical: 2, horizontalOnly: 3 };class Lp {
            constructor() {
                this.scale = 1, this.fontStack = "", this.imageName = null;
            }static forText(t, e) {
                const r = new Lp();return r.scale = t || 1, r.fontStack = e, r;
            }static forImage(t) {
                const e = new Lp();return e.imageName = t, e;
            }
        }class Fp {
            constructor() {
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }static fromFeature(t, e) {
                const r = new Fp();for (let n = 0; n < t.sections.length; n++) {
                    const i = t.sections[n];i.image ? r.addImageSection(i) : r.addTextSection(i, e);
                }return r;
            }length() {
                return this.text.length;
            }getSection(t) {
                return this.sections[this.sectionIndex[t]];
            }getSections() {
                return this.sections;
            }getSectionIndex(t) {
                return this.sectionIndex[t];
            }getCharCode(t) {
                return this.text.charCodeAt(t);
            }verticalizePunctuation(t) {
                this.text = function (t, e) {
                    let r = "";for (let n = 0; n < t.length; n++) {
                        const i = t.charCodeAt(n + 1) || null,
                              s = t.charCodeAt(n - 1) || null;r += !e && (i && Ss(i) && !ip[t[n + 1]] || s && Ss(s) && !ip[t[n - 1]]) || !ip[t[n]] ? t[n] : ip[t[n]];
                    }return r;
                }(this.text, t);
            }trim() {
                let t = 0;for (let e = 0; e < this.text.length && jp[this.text.charCodeAt(e)]; e++) t++;let e = this.text.length;for (let r = this.text.length - 1; r >= 0 && r >= t && jp[this.text.charCodeAt(r)]; r--) e--;this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);
            }substring(t, e) {
                const r = new Fp();return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;
            }toString() {
                return this.text;
            }getMaxScale() {
                return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);
            }addTextSection(t, e) {
                this.text += t.text, this.sections.push(Lp.forText(t.scale, t.fontStack || e));const r = this.sections.length - 1;for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);
            }addImageSection(t) {
                const e = t.image ? t.image.name : "";if (0 === e.length) return void $("Can't add FormattedSection with an empty image.");const r = this.getNextImageSectionCharCode();r ? (this.text += String.fromCharCode(r), this.sections.push(Lp.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : $("Reached maximum number of images 6401");
            }getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }function Rp(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d) {
            const y = Fp.fromFeature(t, i);h === Vp.vertical && y.verticalizePunctuation(p);let m = [];const g = function (t, e, r, n, i, s) {
                if (!t) return [];const a = [],
                      o = function (t, e, r, n, i, s) {
                    let a = 0;for (let r = 0; r < t.length(); r++) {
                        const o = t.getSection(r);a += $p(t.getCharCode(r), o, n, i, e, s);
                    }return a / Math.max(1, Math.ceil(a / r));
                }(t, e, r, n, i, s),
                      l = t.text.indexOf("â") >= 0;let u = 0;for (let r = 0; r < t.length(); r++) {
                    const h = t.getSection(r),
                          p = t.getCharCode(r);if (jp[p] || (u += $p(p, h, n, i, e, s)), r < t.length() - 1) {
                        const e = !((c = p) < 11904 || !(ns(c) || rs(c) || ms(c) || fs(c) || os(c) || Hi(c) || is(c) || Qi(c) || ls(c) || us(c) || as(c) || vs(c) || ts(c) || Ji(c) || Wi(c) || ss(c) || es(c) || ys(c) || hs(c) || cs(c)));(Up[p] || e || h.imageName) && a.push(Np(r + 1, u, o, a, qp(p, t.getCharCode(r + 1), e && l), !1));
                    }
                }var c;return Gp(Np(t.length(), u, o, a, 0, !0));
            }(y, u, s, e, n, f),
                  { processBidirectionalText: x, processStyledBidirectionalText: v } = js;if (x && 1 === y.sections.length) {
                const t = x(y.toString(), g);for (const e of t) {
                    const t = new Fp();t.text = e, t.sections = y.sections;for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);m.push(t);
                }
            } else if (v) {
                const t = v(y.text, y.sectionIndex, g);for (const e of t) {
                    const t = new Fp();t.text = e[0], t.sectionIndex = e[1], t.sections = y.sections, m.push(t);
                }
            } else m = function (t, e) {
                const r = [],
                      n = t.text;let i = 0;for (const n of e) r.push(t.substring(i, n)), i = n;return i < n.length && r.push(t.substring(i, n.length)), r;
            }(y, g);const b = [],
                  w = { positionedLines: b, text: y.toString(), top: c[1], bottom: c[1], left: c[0], right: c[0], writingMode: h, iconsInText: !1, verticalizable: !1, hasBaseline: !1 };return function (t, e, r, n, i, s, a, o, l, u, c, h) {
                let p = 0,
                    f = 0,
                    d = 0;const y = "right" === o ? 1 : "left" === o ? 0 : .5;let m = !1;for (const t of i) {
                    const r = t.getSections();for (const t of r) {
                        if (t.imageName) continue;const r = e[t.fontStack];if (r && (m = void 0 !== r.ascender && void 0 !== r.descender, !m)) break;
                    }if (!m) break;
                }let g = 0;for (const a of i) {
                    a.trim();const i = a.getMaxScale(),
                          o = (i - 1) * Wh,
                          v = { positionedGlyphs: [], lineOffset: 0 };t.positionedLines[g] = v;const b = v.positionedGlyphs;let w = 0;if (!a.length()) {
                        f += s, ++g;continue;
                    }let _ = 0,
                        A = 0;for (let s = 0; s < a.length(); s++) {
                        const o = a.getSection(s),
                              d = a.getSectionIndex(s),
                              y = a.getCharCode(s);let g = o.scale,
                            v = null,
                            S = null,
                            k = null,
                            I = Wh,
                            M = 0;const T = !(l === Vp.horizontal || !c && !As(y) || c && (jp[y] || (x = y, Zi(x) || Ki(x) || Yi(x) || ds(x) || xs(x))));if (o.imageName) {
                            const e = n[o.imageName];if (!e) continue;k = o.imageName, t.iconsInText = t.iconsInText || !0, S = e.paddedRect;const r = e.displaySize;g = g * Wh / h, v = { width: r[0], height: r[1], left: 1, top: -3, advance: T ? r[1] : r[0], localGlyph: !1 }, M = m ? -v.height * g : i * Wh - 17 - r[1] * g, I = v.advance;const s = (T ? r[0] : r[1]) * g - Wh * i;s > 0 && s > w && (w = s);
                        } else {
                            const t = r[o.fontStack];if (!t) continue;t[y] && (S = t[y]);const n = e[o.fontStack];if (!n) continue;const s = n.glyphs[y];if (!s) continue;if (v = s.metrics, I = 8203 !== y ? Wh : 0, m) {
                                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,
                                      e = void 0 !== n.descender ? Math.abs(n.descender) : 0,
                                      r = (t + e) * g;_ < r && (_ = r, A = (t - e) / 2 * g), M = -t * g;
                            } else M = (i - g) * Wh - 17;
                        }T ? (t.verticalizable = !0, b.push({ glyph: y, imageName: k, x: p, y: f + M, vertical: T, scale: g, localGlyph: v.localGlyph, fontStack: o.fontStack, sectionIndex: d, metrics: v, rect: S }), p += I * g + u) : (b.push({ glyph: y, imageName: k, x: p, y: f + M, vertical: T, scale: g, localGlyph: v.localGlyph, fontStack: o.fontStack, sectionIndex: d, metrics: v, rect: S }), p += v.advance * g + u);
                    }0 !== b.length && (d = Math.max(p - u, d), m ? Zp(b, y, w, A, s * i / 2) : Zp(b, y, w, 0, s / 2)), p = 0;const S = s * i + w;v.lineOffset = Math.max(w, o), f += S, ++g;
                }var x;const v = f,
                      { horizontalAlign: b, verticalAlign: w } = Xp(a);(function (t, e, r, n, i, s) {
                    const a = (e - r) * i,
                          o = -s * n;for (const e of t) for (const t of e.positionedGlyphs) t.x += a, t.y += o;
                })(t.positionedLines, y, b, w, d, v), t.top += -w * v, t.bottom = t.top + v, t.left += -b * d, t.right = t.left + d, t.hasBaseline = m;
            }(w, e, r, n, m, a, o, l, h, u, p, d), !function (t) {
                for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;return !0;
            }(b) && w;
        }const jp = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
              Up = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };function $p(t, e, r, n, i, s) {
            if (e.imageName) {
                const t = n[e.imageName];return t ? t.displaySize[0] * e.scale * Wh / s + i : 0;
            }{
                const n = r[e.fontStack],
                      s = n && n.glyphs[t];return s ? s.metrics.advance * e.scale + i : 0;
            }
        }function Op(t, e, r, n) {
            const i = Math.pow(t - e, 2);return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }function qp(t, e, r) {
            let n = 0;return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;
        }function Np(t, e, r, n, i, s) {
            let a = null,
                o = Op(e, r, i, s);for (const t of n) {
                const n = Op(e - t.x, r, i, s) + t.badness;n <= o && (a = t, o = n);
            }return { index: t, x: e, priorBreak: a, badness: o };
        }function Gp(t) {
            return t ? Gp(t.priorBreak).concat(t.index) : [];
        }function Xp(t) {
            let e = .5,
                r = .5;switch (t) {case "right":case "top-right":case "bottom-right":
                    e = 1;break;case "left":case "top-left":case "bottom-left":
                    e = 0;}switch (t) {case "bottom":case "bottom-right":case "bottom-left":
                    r = 1;break;case "top":case "top-right":case "top-left":
                    r = 0;}return { horizontalAlign: e, verticalAlign: r };
        }function Zp(t, e, r, n, i) {
            if (!(e || r || n || i)) return;const s = t.length - 1,
                  a = t[s],
                  o = (a.x + a.metrics.advance * a.scale) * e;for (let e = 0; e <= s; e++) t[e].x -= o, t[e].y += r + n + i;
        }function Kp(t, e, r) {
            const { horizontalAlign: n, verticalAlign: i } = Xp(r),
                  s = e[0] - t.displaySize[0] * n,
                  a = e[1] - t.displaySize[1] * i;return { image: t, top: a, bottom: a + t.displaySize[1], left: s, right: s + t.displaySize[0] };
        }function Yp(t, e, r, n, i, s) {
            const a = t.image;let o;if (a.content) {
                const t = a.content,
                      e = a.pixelRatio || 1;o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];
            }const l = e.left * s,
                  u = e.right * s;let c, h, p, f;"width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);const d = e.top * s,
                  y = e.bottom * s;return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), { image: a, top: c, right: h, bottom: p, left: f, collisionPadding: o };
        }class Hp extends d {
            constructor(t, e, r, n, i) {
                super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
            }clone() {
                return new Hp(this.x, this.y, this.z, this.angle, this.segment);
            }
        }function Wp(t, e, r, n, i) {
            if (void 0 === e.segment) return !0;let s = e,
                a = e.segment + 1,
                o = 0;for (; o > -r / 2;) {
                if (a--, a < 0) return !1;o -= t[a].dist(s), s = t[a];
            }o += t[a].dist(t[a + 1]), a++;const l = [];let u = 0;for (; o < r / 2;) {
                const e = t[a],
                      r = t[a + 1];if (!r) return !1;let s = t[a - 1].angleTo(e) - e.angleTo(r);for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({ distance: o, angleDelta: s }), u += s; o - l[0].distance > n;) u -= l.shift().angleDelta;if (u > i) return !1;a++, o += e.dist(r);
            }return !0;
        }function Jp(t) {
            let e = 0;for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);return e;
        }function Qp(t, e, r) {
            return t ? .6 * e * r : 0;
        }function tf(t, e) {
            return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);
        }function ef(t, e, r, n, i, s) {
            const a = Qp(r, i, s),
                  o = tf(r, n) * s;let l = 0;const u = Jp(t) / 2;for (let r = 0; r < t.length - 1; r++) {
                const n = t[r],
                      i = t[r + 1],
                      s = n.dist(i);if (l + s > u) {
                    const c = (u - l) / s,
                          h = Mr(n.x, i.x, c),
                          p = Mr(n.y, i.y, c),
                          f = new Hp(h, p, 0, i.angleTo(n), r);return !a || Wp(t, f, o, a, e) ? f : void 0;
                }l += s;
            }
        }function rf(t, e, r, n, i, s, a, o, l) {
            const u = Qp(n, s, a),
                  c = tf(n, i),
                  h = c * a,
                  p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;return e - h < e / 4 && (e = h + e / 4), nf(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);
        }function nf(t, e, r, n, i, s, a, o, l) {
            const u = s / 2,
                  c = Jp(t);let h = 0,
                p = e - r,
                f = [];for (let e = 0; e < t.length - 1; e++) {
                const a = t[e],
                      o = t[e + 1],
                      d = a.dist(o),
                      y = o.angleTo(a);for (; p + r < h + d;) {
                    p += r;const m = (p - h) / d,
                          g = Mr(a.x, o.x, m),
                          x = Mr(a.y, o.y, m);if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new Hp(g, x, 0, y, e);r._round(), n && !Wp(t, r, s, n, i) || f.push(r);
                    }
                }h += d;
            }return o || f.length || a || (f = nf(t, h / 2, r, n, i, s, a, !0, l)), f;
        }function sf(t, e, r, n, i) {
            const s = [];for (let a = 0; a < t.length; a++) {
                const o = t[a];let l;for (let t = 0; t < o.length - 1; t++) {
                    let a = o[t],
                        u = o[t + 1];a.x < e && u.x < e || (a.x < e ? a = new d(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e && (u = new d(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new d(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new d(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new d(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new d(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new d(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new d(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [a], s.push(l)), l.push(u)))));
                }
            }return s;
        }Oi(Hp, "Anchor");const af = 1e20;function of(t, e, r, n, i, s, a, o, l) {
            for (let u = e; u < e + n; u++) lf(t, r * s + u, s, i, a, o, l);for (let u = r; u < r + i; u++) lf(t, u * s + e, 1, n, a, o, l);
        }function lf(t, e, r, n, i, s, a) {
            s[0] = 0, a[0] = -af, a[1] = af, i[0] = t[e];for (let o = 1, l = 0, u = 0; o < n; o++) {
                i[o] = t[e + o * r];const n = o * o;do {
                    const t = s[l];u = (i[o] - i[t] + n - t * t) / (o - t) / 2;
                } while (u <= a[l] && --l > -1);l++, s[l] = o, a[l] = u, a[l + 1] = af;
            }for (let o = 0, l = 0; o < n; o++) {
                for (; a[l + 1] < o;) l++;const n = s[l],
                      u = o - n;t[e + o * r] = i[n] + u * u;
            }
        }const uf = { none: 0, ideographs: 1, all: 2 };class cf {
            constructor(t, e, r) {
                this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
            }setURL(t) {
                this.url = t;
            }getGlyphs(t, e) {
                const r = [];for (const e in t) for (const n of t[e]) r.push({ stack: e, id: n });M(r, ({ stack: t, id: e }, r) => {
                    let n = this.entries[t];n || (n = this.entries[t] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });let i = n.glyphs[e];if (void 0 !== i) return void r(null, { stack: t, id: e, glyph: i });if (i = this._tinySDF(n, t, e), i) return n.glyphs[e] = i, void r(null, { stack: t, id: e, glyph: i });const s = Math.floor(e / 256);if (256 * s > 65535) return void r(new Error("glyphs > 65535 not supported"));if (n.ranges[s]) return void r(null, { stack: t, id: e, glyph: i });let a = n.requests[s];a || (a = n.requests[s] = [], cf.loadGlyphRange(t, s, this.url, this.requestManager, (t, e) => {
                        if (e) {
                            n.ascender = e.ascender, n.descender = e.descender;for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);n.ranges[s] = !0;
                        }for (const r of a) r(t, e);delete n.requests[s];
                    })), a.push((n, i) => {
                        n ? r(n) : i && r(null, { stack: t, id: e, glyph: i.glyphs[e] || null });
                    });
                }, (t, r) => {
                    if (t) e(t);else if (r) {
                        const t = {};for (const { stack: e, id: n, glyph: i } of r) void 0 === t[e] && (t[e] = {}), void 0 === t[e].glyphs && (t[e].glyphs = {}), t[e].glyphs[n] = i && { id: i.id, bitmap: i.bitmap.clone(), metrics: i.metrics }, t[e].ascender = this.entries[e].ascender, t[e].descender = this.entries[e].descender;e(null, t);
                    }
                });
            }_doesCharSupportLocalGlyph(t) {
                return this.localGlyphMode !== uf.none && (this.localGlyphMode === uf.all ? !!this.localFontFamily : !!this.localFontFamily && (us(t) || ps(t) || ts(t) || es(t) || Qi(t)));
            }_tinySDF(t, e, r) {
                const n = this.localFontFamily;if (!n || !this._doesCharSupportLocalGlyph(r)) return;let i = t.tinySDF;if (!i) {
                    let r = "400";/bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), i = t.tinySDF = new cf.TinySDF({ fontFamily: n, fontWeight: r, fontSize: 48, buffer: 6, radius: 16 }), i.fontWeight = r;
                }if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];const s = String.fromCharCode(r),
                      { data: a, width: o, height: l, glyphWidth: u, glyphHeight: c, glyphLeft: h, glyphTop: p, glyphAdvance: f } = i.draw(s);return this.localGlyphs[i.fontWeight][r] = { id: r, bitmap: new Ju({ width: o, height: l }, a), metrics: { width: u / 2, height: c / 2, left: h / 2, top: p / 2 - 27, advance: f / 2, localGlyph: !0 } };
            }
        }function hf(t, e, r, n) {
            const i = [],
                  s = t.image,
                  a = s.pixelRatio,
                  o = s.paddedRect.w - 2,
                  l = s.paddedRect.h - 2,
                  u = t.right - t.left,
                  c = t.bottom - t.top,
                  h = s.stretchX || [[0, o]],
                  p = s.stretchY || [[0, l]],
                  f = (t, e) => t + e[1] - e[0],
                  y = h.reduce(f, 0),
                  m = p.reduce(f, 0),
                  g = o - y,
                  x = l - m;let v = 0,
                b = y,
                w = 0,
                _ = m,
                A = 0,
                S = g,
                k = 0,
                I = x;if (s.content && n) {
                const t = s.content;v = pf(h, 0, t[0]), w = pf(p, 0, t[1]), b = pf(h, t[0], t[2]), _ = pf(p, t[1], t[3]), A = t[0] - v, k = t[1] - w, S = t[2] - t[0] - b, I = t[3] - t[1] - _;
            }const M = (n, i, o, l) => {
                const h = df(n.stretch - v, b, u, t.left),
                      p = yf(n.fixed - A, S, n.stretch, y),
                      f = df(i.stretch - w, _, c, t.top),
                      g = yf(i.fixed - k, I, i.stretch, m),
                      x = df(o.stretch - v, b, u, t.left),
                      M = yf(o.fixed - A, S, o.stretch, y),
                      T = df(l.stretch - w, _, c, t.top),
                      z = yf(l.fixed - k, I, l.stretch, m),
                      B = new d(h, f),
                      E = new d(x, f),
                      C = new d(x, T),
                      P = new d(h, T),
                      D = new d(p / a, g / a),
                      V = new d(M / a, z / a),
                      L = e * Math.PI / 180;if (L) {
                    const t = Math.sin(L),
                          e = Math.cos(L),
                          r = [e, -t, t, e];B._matMult(r), E._matMult(r), P._matMult(r), C._matMult(r);
                }const F = n.stretch + n.fixed,
                      R = i.stretch + i.fixed;return { tl: B, tr: E, bl: P, br: C, tex: { x: s.paddedRect.x + 1 + F, y: s.paddedRect.y + 1 + R, w: o.stretch + o.fixed - F, h: l.stretch + l.fixed - R }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D, pixelOffsetBR: V, minFontScaleX: S / a / u, minFontScaleY: I / a / c, isSDF: r };
            };if (n && (s.stretchX || s.stretchY)) {
                const t = ff(h, g, y),
                      e = ff(p, x, m);for (let r = 0; r < t.length - 1; r++) {
                    const n = t[r],
                          s = t[r + 1];for (let t = 0; t < e.length - 1; t++) i.push(M(n, e[t], s, e[t + 1]));
                }
            } else i.push(M({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o + 1 }, { fixed: 0, stretch: l + 1 }));return i;
        }function pf(t, e, r) {
            let n = 0;for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));return n;
        }function ff(t, e, r) {
            const n = [{ fixed: -1, stretch: 0 }];for (const [e, r] of t) {
                const t = n[n.length - 1];n.push({ fixed: e - t.stretch, stretch: t.stretch }), n.push({ fixed: e - t.stretch, stretch: t.stretch + (r - e) });
            }return n.push({ fixed: e + 1, stretch: r }), n;
        }function df(t, e, r, n) {
            return t / e * r + n;
        }function yf(t, e, r, n) {
            return t - e * r / n;
        }function mf(t, e, r, n) {
            const i = e + t.positionedLines[n].lineOffset;return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;
        }cf.loadGlyphRange = function (t, e, r, n, i) {
            const s = 256 * e,
                  a = s + 255,
                  o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t).replace("{range}", `${s}-${a}`), st.Glyphs);ut(o, (t, e) => {
                if (t) i(t);else if (e) {
                    const t = {},
                          r = function (t) {
                        return new op(t).readFields(zp, {});
                    }(e);for (const e of r.glyphs) t[e.id] = e;i(null, { glyphs: t, ascender: r.ascender, descender: r.descender });
                }
            });
        }, cf.TinySDF = class {
            constructor({ fontSize: t = 24, buffer: e = 3, radius: r = 8, cutoff: n = .25, fontFamily: i = "sans-serif", fontWeight: s = "normal", fontStyle: a = "normal" } = {}) {
                this.buffer = e, this.cutoff = n, this.radius = r;const o = this.size = t + 4 * e,
                      l = this._createCanvas(o),
                      u = this.ctx = l.getContext("2d", { willReadFrequently: !0 });u.font = `${a} ${s} ${t}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
            }_createCanvas(t) {
                const e = document.createElement("canvas");return e.width = e.height = t, e;
            }draw(t) {
                const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: s } = this.ctx.measureText(t),
                      a = Math.ceil(r),
                      o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))),
                      l = Math.min(this.size - this.buffer, a + Math.ceil(n)),
                      u = o + 2 * this.buffer,
                      c = l + 2 * this.buffer,
                      h = Math.max(u * c, 0),
                      p = new Uint8ClampedArray(h),
                      f = { data: p, width: u, height: c, glyphWidth: o, glyphHeight: l, glyphTop: a, glyphLeft: 0, glyphAdvance: e };if (0 === o || 0 === l) return f;const { ctx: d, buffer: y, gridInner: m, gridOuter: g } = this;d.clearRect(y, y, o, l), d.fillText(t, y, y + a);const x = d.getImageData(y, y, o, l);g.fill(af, 0, h), m.fill(0, 0, h);for (let t = 0; t < l; t++) for (let e = 0; e < o; e++) {
                    const r = x.data[4 * (t * o + e) + 3] / 255;if (0 === r) continue;const n = (t + y) * u + e + y;if (1 === r) g[n] = 0, m[n] = af;else {
                        const t = .5 - r;g[n] = t > 0 ? t * t : 0, m[n] = t < 0 ? t * t : 0;
                    }
                }of(g, 0, 0, u, c, u, this.f, this.v, this.z), of(m, y, y, o, l, u, this.f, this.v, this.z);for (let t = 0; t < h; t++) {
                    const e = Math.sqrt(g[t]) - Math.sqrt(m[t]);p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
                }return f;
            }
        };class gf {
            constructor(t = [], e = xf) {
                if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);
            }push(t) {
                this.data.push(t), this.length++, this._up(this.length - 1);
            }pop() {
                if (0 === this.length) return;const t = this.data[0],
                      e = this.data.pop();return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;
            }peek() {
                return this.data[0];
            }_up(t) {
                const { data: e, compare: r } = this,
                      n = e[t];for (; t > 0;) {
                    const i = t - 1 >> 1,
                          s = e[i];if (r(n, s) >= 0) break;e[t] = s, t = i;
                }e[t] = n;
            }_down(t) {
                const { data: e, compare: r } = this,
                      n = this.length >> 1,
                      i = e[t];for (; t < n;) {
                    let n = 1 + (t << 1),
                        s = e[n];const a = n + 1;if (a < this.length && r(e[a], s) < 0 && (n = a, s = e[a]), r(s, i) >= 0) break;e[t] = s, t = n;
                }e[t] = i;
            }
        }function xf(t, e) {
            return t < e ? -1 : t > e ? 1 : 0;
        }function vf(t, e = 1, r = !1) {
            let n = 1 / 0,
                i = 1 / 0,
                s = -1 / 0,
                a = -1 / 0;const o = t[0];for (let t = 0; t < o.length; t++) {
                const e = o[t];(!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > s) && (s = e.x), (!t || e.y > a) && (a = e.y);
            }const l = Math.min(s - n, a - i);let u = l / 2;const c = new gf([], bf);if (0 === l) return new d(n, i);for (let e = n; e < s; e += l) for (let r = i; r < a; r += l) c.push(new wf(e + u, r + u, u, t));let h = function (t) {
                let e = 0,
                    r = 0,
                    n = 0;const i = t[0];for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {
                    const s = i[t],
                          o = i[a],
                          l = s.x * o.y - o.x * s.y;r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;
                }return new wf(r / e, n / e, 0, t);
            }(t),
                p = c.length;for (; c.length;) {
                const n = c.pop();(n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new wf(n.p.x - u, n.p.y - u, u, t)), c.push(new wf(n.p.x + u, n.p.y - u, u, t)), c.push(new wf(n.p.x - u, n.p.y + u, u, t)), c.push(new wf(n.p.x + u, n.p.y + u, u, t)), p += 4);
            }return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }function bf(t, e) {
            return e.max - t.max;
        }function wf(t, e, r, n) {
            this.p = new d(t, e), this.h = r, this.d = function (t, e) {
                let r = !1,
                    n = 1 / 0;for (let i = 0; i < e.length; i++) {
                    const s = e[i];for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {
                        const i = s[e],
                              o = s[a];i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Cu(t, i, o));
                    }
                }return (r ? 1 : -1) * Math.sqrt(n);
            }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
        }const _f = Number.POSITIVE_INFINITY,
              Af = Math.sqrt(2);function Sf(t, [e, r]) {
            let n = 0,
                i = 0;if (r === _f) {
                e < 0 && (e = 0);const r = e / Af;switch (t) {case "top-right":case "top-left":
                        i = r - 7;break;case "bottom-right":case "bottom-left":
                        i = 7 - r;break;case "bottom":
                        i = 7 - e;break;case "top":
                        i = e - 7;}switch (t) {case "top-right":case "bottom-right":
                        n = -r;break;case "top-left":case "bottom-left":
                        n = r;break;case "left":
                        n = e;break;case "right":
                        n = -e;}
            } else {
                switch (e = Math.abs(e), r = Math.abs(r), t) {case "top-right":case "top-left":case "top":
                        i = r - 7;break;case "bottom-right":case "bottom-left":case "bottom":
                        i = 7 - r;}switch (t) {case "top-right":case "bottom-right":case "right":
                        n = -e;break;case "top-left":case "bottom-left":case "left":
                        n = e;}
            }return [n, i];
        }function kf(t, e, r, n, i, s, a, o, l, u) {
            t.createArrays(), t.tilePixelRatio = ko / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;const c = t.layers[0].layout,
                  h = t.layers[0]._unevaluatedLayout._values,
                  p = {};if ("composite" === t.textSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t.textSizeData;p.compositeTextSizes = [h["text-size"].possiblyEvaluate(new Us(e), o), h["text-size"].possiblyEvaluate(new Us(r), o)];
            }if ("composite" === t.iconSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t.iconSizeData;p.compositeIconSizes = [h["icon-size"].possiblyEvaluate(new Us(e), o), h["icon-size"].possiblyEvaluate(new Us(r), o)];
            }p.layoutTextSize = h["text-size"].possiblyEvaluate(new Us(l + 1), o), p.layoutIconSize = h["icon-size"].possiblyEvaluate(new Us(l + 1), o), p.textMaxSize = h["text-size"].possiblyEvaluate(new Us(18), o);const f = "map" === c.get("text-rotation-alignment") && "point" !== c.get("symbol-placement"),
                  d = c.get("text-size");for (const s of t.features) {
                const l = c.get("text-font").evaluate(s, {}, o).join(","),
                      h = d.evaluate(s, {}, o),
                      y = p.layoutTextSize.evaluate(s, {}, o),
                      m = (p.layoutIconSize.evaluate(s, {}, o), { horizontal: {}, vertical: void 0 }),
                      g = s.text;let x,
                    v = [0, 0];if (g) {
                    const n = g.toString(),
                          a = c.get("text-letter-spacing").evaluate(s, {}, o) * Wh,
                          u = c.get("text-line-height").evaluate(s, {}, o) * Wh,
                          p = ws(n) ? a : 0,
                          d = c.get("text-anchor").evaluate(s, {}, o),
                          x = c.get("text-variable-anchor");if (!x) {
                        const t = c.get("text-radial-offset").evaluate(s, {}, o);v = t ? Sf(d, [t * Wh, _f]) : c.get("text-offset").evaluate(s, {}, o).map(t => t * Wh);
                    }let b = f ? "center" : c.get("text-justify").evaluate(s, {}, o);const w = "point" === c.get("symbol-placement"),
                          _ = w ? c.get("text-max-width").evaluate(s, {}, o) * Wh : 1 / 0,
                          A = s => {
                        t.allowVerticalPlacement && bs(n) && (m.vertical = Rp(g, e, r, i, l, _, u, d, s, p, v, Vp.vertical, !0, y, h));
                    };if (!f && x) {
                        const t = "auto" === b ? x.map(t => If(t)) : [b];let n = !1;for (let s = 0; s < t.length; s++) {
                            const a = t[s];if (!m.horizontal[a]) if (n) m.horizontal[a] = m.horizontal[0];else {
                                const t = Rp(g, e, r, i, l, _, u, "center", a, p, v, Vp.horizontal, !1, y, h);t && (m.horizontal[a] = t, n = 1 === t.positionedLines.length);
                            }
                        }A("left");
                    } else {
                        if ("auto" === b && (b = If(d)), w || c.get("text-writing-mode").indexOf("horizontal") >= 0 || !bs(n)) {
                            const t = Rp(g, e, r, i, l, _, u, d, b, p, v, Vp.horizontal, !1, y, h);t && (m.horizontal[b] = t);
                        }A(w ? "left" : b);
                    }
                }let b = !1;if (s.icon && s.icon.name) {
                    const e = n[s.icon.name];e && (x = Kp(i[s.icon.name], c.get("icon-offset").evaluate(s, {}, o), c.get("icon-anchor").evaluate(s, {}, o)), b = e.sdf, void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && $("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e.pixelRatio !== t.pixelRatio || 0 !== c.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0));
                }const w = Bf(m.horizontal) || m.vertical;t.iconsInText || (t.iconsInText = !!w && w.iconsInText), (w || x) && Mf(t, s, m, x, n, p, y, 0, v, b, a, o, u);
            }s && t.generateCollisionDebugBuffers(l, t.collisionBoxArray);
        }function If(t) {
            switch (t) {case "right":case "top-right":case "bottom-right":
                    return "right";case "left":case "top-left":case "bottom-left":
                    return "left";}return "center";
        }function Mf(t, e, r, n, i, s, a, o, l, u, c, h, p) {
            let f = s.textMaxSize.evaluate(e, {}, h);void 0 === f && (f = a);const d = t.layers[0].layout,
                  y = d.get("icon-offset").evaluate(e, {}, h),
                  m = Bf(r.horizontal) || r.vertical,
                  g = "globe" === p.name,
                  v = a / 24,
                  b = t.tilePixelRatio * f / 24,
                  w = (z = t.overscaling, t.zoom > 18 && z > 2 && (z >>= 1), Math.max(ko / (512 * z), 1) * d.get("symbol-spacing")),
                  _ = d.get("text-padding") * t.tilePixelRatio,
                  A = d.get("icon-padding") * t.tilePixelRatio,
                  S = x(d.get("text-max-angle")),
                  k = "map" === d.get("text-rotation-alignment") && "point" !== d.get("symbol-placement"),
                  I = "map" === d.get("icon-rotation-alignment") && "point" !== d.get("symbol-placement"),
                  M = d.get("symbol-placement"),
                  T = w / 2;var z;const B = d.get("icon-text-fit");let E;n && "none" !== B && (t.allowVerticalPlacement && r.vertical && (E = Yp(n, r.vertical, B, d.get("icon-text-fit-padding"), y, v)), m && (n = Yp(n, m, B, d.get("icon-text-fit-padding"), y, v)));const C = (a, o, f) => {
                if (o.x < 0 || o.x >= ko || o.y < 0 || o.y >= ko) return;let d = null;if (g) {
                    const { x: t, y: e, z: r } = p.projectTilePoint(o.x, o.y, f);d = { anchor: new Hp(t, e, r, 0, void 0), up: p.upVector(f, o.x, o.y) };
                }!function (t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S) {
                    const k = t.addToLineVertexArray(e, n);let I,
                        M,
                        T,
                        z,
                        B,
                        E,
                        C,
                        P = 0,
                        D = 0,
                        V = 0,
                        L = 0,
                        F = -1,
                        R = -1;const j = {};let U = qa("");const O = r ? r.anchor : e;let q = 0,
                        N = 0;if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [q, N] = l.layout.get("text-offset").evaluate(b, {}, S).map(t => t * Wh) : (q = l.layout.get("text-radial-offset").evaluate(b, {}, S) * Wh, N = _f), t.allowVerticalPlacement && i.vertical) {
                        const t = i.vertical;if (d) E = Cf(t), o && (C = Cf(o));else {
                            const r = l.layout.get("text-rotate").evaluate(b, {}, S) + 90;T = Ef(u, O, e, c, h, p, t, f, r, y), o && (z = Ef(u, O, e, c, h, p, o, g, r));
                        }
                    }if (s) {
                        const n = l.layout.get("icon-rotate").evaluate(b, {}, S),
                              i = "none" !== l.layout.get("icon-text-fit"),
                              a = hf(s, n, _, i),
                              f = o ? hf(o, n, _, i) : void 0;M = Ef(u, O, e, c, h, p, s, g, n), P = 4 * a.length;const d = t.iconSizeData;let y = null;"source" === d.kind ? (y = [Jh * l.layout.get("icon-size").evaluate(b, {}, S)], y[0] > Tf && $(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d.kind && (y = [Jh * w.compositeIconSizes[0].evaluate(b, {}, S), Jh * w.compositeIconSizes[1].evaluate(b, {}, S)], (y[0] > Tf || y[1] > Tf) && $(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t.addSymbols(t.icon, a, y, v, x, b, !1, r, e, k.lineStartIndex, k.lineLength, -1, A, S), F = t.icon.placedSymbolArray.length - 1, f && (D = 4 * f.length, t.addSymbols(t.icon, f, y, v, x, b, Vp.vertical, r, e, k.lineStartIndex, k.lineLength, -1, A, S), R = t.icon.placedSymbolArray.length - 1);
                    }for (const n in i.horizontal) {
                        const s = i.horizontal[n];I || (U = qa(s.text), d ? B = Cf(s) : I = Ef(u, O, e, c, h, p, s, f, l.layout.get("text-rotate").evaluate(b, {}, S), y));const o = 1 === s.positionedLines.length;if (V += zf(t, r, e, s, a, l, d, b, y, k, i.vertical ? Vp.horizontal : Vp.horizontalOnly, o ? Object.keys(i.horizontal) : [n], j, F, w, A, S), o) break;
                    }i.vertical && (L += zf(t, r, e, i.vertical, a, l, d, b, y, k, Vp.vertical, ["vertical"], j, R, w, A, S));let G = -1;const X = (t, e) => t ? Math.max(t, e) : e;G = X(B, G), G = X(E, G), G = X(C, G);const Z = G > -1 ? 1 : 0;t.glyphOffsetArray.length >= hd.MAX_GLYPHS && $("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(O.x, O.y, O.z, e.x, e.y, j.right >= 0 ? j.right : -1, j.center >= 0 ? j.center : -1, j.left >= 0 ? j.left : -1, j.vertical >= 0 ? j.vertical : -1, F, R, U, void 0 !== I ? I : t.collisionBoxArray.length, void 0 !== I ? I + 1 : t.collisionBoxArray.length, void 0 !== T ? T : t.collisionBoxArray.length, void 0 !== T ? T + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, z || t.collisionBoxArray.length, z ? z + 1 : t.collisionBoxArray.length, c, V, L, P, D, Z, 0, q, N, G);
                }(t, o, d, a, r, n, i, E, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, _, k, l, 0, A, I, y, e, s, u, c, h);
            };if ("line" === M) for (const i of sf(e.geometry, 0, 0, ko, ko)) {
                const e = rf(i, w, S, r.vertical || m, n, 24, b, t.overscaling, ko);for (const r of e) {
                    const e = m;e && Pf(t, e.text, T, r) || C(i, r, h);
                }
            } else if ("line-center" === M) {
                for (const t of e.geometry) if (t.length > 1) {
                    const e = ef(t, S, r.vertical || m, n, 24, b);e && C(t, e, h);
                }
            } else if ("Polygon" === e.type) for (const t of Lc(e.geometry, 0)) {
                const e = vf(t, 16);C(t[0], new Hp(e.x, e.y, 0, 0, void 0), h);
            } else if ("LineString" === e.type) for (const t of e.geometry) C(t, new Hp(t[0].x, t[0].y, 0, 0, void 0), h);else if ("Point" === e.type) for (const t of e.geometry) for (const e of t) C([e], new Hp(e.x, e.y, 0, 0, void 0), h);
        }const Tf = 32640;function zf(t, e, r, n, i, s, a, o, l, u, c, h, p, f, y, m, g) {
            const x = function (t, e, r, n, i, s, a, o) {
                const l = [];if (0 === e.positionedLines.length) return l;const u = n.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180,
                      c = function (t) {
                    const e = t[0],
                          r = t[1],
                          n = e * r;return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];
                }(r);let h = Math.abs(e.top - e.bottom);for (const t of e.positionedLines) h -= t.lineOffset;const p = e.positionedLines.length,
                      f = h / p;let y = e.top - r[1];for (let t = 0; t < p; ++t) {
                    const n = e.positionedLines[t];y = mf(e, f, y, t);for (const t of n.positionedGlyphs) {
                        if (!t.rect) continue;const n = t.rect || {};let s = 4,
                            h = !0,
                            p = 1,
                            f = 0;if (t.imageName) {
                            const e = a[t.imageName];if (!e) continue;if (e.sdf) {
                                $("SDF images are not supported in formatted text and will be ignored.");continue;
                            }h = !1, p = e.pixelRatio, s = 1 / p;
                        }const m = (i || o) && t.vertical,
                              g = t.metrics.advance * t.scale / 2,
                              x = t.metrics,
                              v = t.rect;if (null === v) continue;o && e.verticalizable && (f = t.imageName ? g - t.metrics.width * t.scale / 2 : 0);const b = i ? [t.x + g, t.y] : [0, 0];let w = [0, 0],
                            _ = [0, 0],
                            A = !1;i || (m ? (_ = [t.x + g + c[0], t.y + c[1] - f], A = !0) : w = [t.x + g + r[0], t.y + r[1] - f]);const S = v.w * t.scale / (p * (t.localGlyph ? 2 : 1)),
                              k = v.h * t.scale / (p * (t.localGlyph ? 2 : 1));let I, M, T, z;if (m) {
                            const e = t.y - y,
                                  r = new d(-g, g - e),
                                  n = -Math.PI / 2,
                                  i = new d(..._);I = new d(-g + w[0], w[1]), I._rotateAround(n, r)._add(i), I.x += -e + g, I.y -= (x.left - s) * t.scale;const a = t.imageName ? x.advance * t.scale : Wh * t.scale,
                                  o = String.fromCharCode(t.glyph);sp(o) ? I.x += (1 - s) * t.scale : ap(o) ? I.x += a - x.height * t.scale + (-s - 1) * t.scale : I.x += t.imageName || x.width + 2 * s === v.w && x.height + 2 * s === v.h ? (a - k) / 2 : (a - (x.height + 2 * s) * t.scale) / 2, M = new d(I.x, I.y - S), T = new d(I.x + k, I.y), z = new d(I.x + k, I.y - S);
                        } else {
                            const e = (x.left - s) * t.scale - g + w[0],
                                  r = (-x.top - s) * t.scale + w[1],
                                  n = e + S,
                                  i = r + k;I = new d(e, r), M = new d(n, r), T = new d(e, i), z = new d(n, i);
                        }if (u) {
                            let t;t = i ? new d(0, 0) : A ? new d(c[0], c[1]) : new d(r[0], r[1]), I._rotateAround(u, t), M._rotateAround(u, t), T._rotateAround(u, t), z._rotateAround(u, t);
                        }const B = new d(0, 0),
                              E = new d(0, 0);l.push({ tl: I, tr: M, bl: T, br: z, tex: n, writingMode: e.writingMode, glyphOffset: b, sectionIndex: t.sectionIndex, isSDF: h, pixelOffsetTL: B, pixelOffsetBR: E, minFontScaleX: 0, minFontScaleY: 0 });
                    }
                }return l;
            }(0, n, l, s, a, o, i, t.allowVerticalPlacement),
                  v = t.textSizeData;let b = null;"source" === v.kind ? (b = [Jh * s.layout.get("text-size").evaluate(o, {}, g)], b[0] > Tf && $(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v.kind && (b = [Jh * y.compositeTextSizes[0].evaluate(o, {}, g), Jh * y.compositeTextSizes[1].evaluate(o, {}, g)], (b[0] > Tf || b[1] > Tf) && $(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t.addSymbols(t.text, x, b, l, a, o, c, e, r, u.lineStartIndex, u.lineLength, f, m, g);for (const e of h) p[e] = t.text.placedSymbolArray.length - 1;return 4 * x.length;
        }function Bf(t) {
            for (const e in t) return t[e];return null;
        }function Ef(t, e, r, n, i, s, a, o, l, u) {
            let c = a.top,
                h = a.bottom,
                p = a.left,
                f = a.right;const y = a.collisionPadding;if (y && (p -= y[0], c -= y[1], f += y[2], h += y[3]), l) {
                const t = new d(p, c),
                      e = new d(f, c),
                      r = new d(p, h),
                      n = new d(f, h),
                      i = x(l);let s = new d(0, 0);u && (s = new d(u[0], u[1])), t._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t.x, e.x, r.x, n.x), f = Math.max(t.x, e.x, r.x, n.x), c = Math.min(t.y, e.y, r.y, n.y), h = Math.max(t.y, e.y, r.y, n.y);
            }return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, f, h, o, n, i, s), t.length - 1;
        }function Cf(t) {
            t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);const e = t.bottom - t.top;return e > 0 ? Math.max(10, e) : null;
        }function Pf(t, e, r, n) {
            const i = t.compareText;if (e in i) {
                const t = i[e];for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;
            } else i[e] = [];return i[e].push(n), !1;
        }function Df(t, e) {
            const r = t.fovAboveCenter,
                  n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,
                  i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),
                  s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01)),
                  a = Math.sin(t._pitch) * s + i;return Math.min(1.01 * a, i * (1 / t._horizonShift));
        }function Vf(t, e) {
            if (!e.isReprojectedInTileSpace) return { scale: 1 << t.z, x: t.x, y: t.y, x2: t.x + 1, y2: t.y + 1, projection: e };const r = Math.pow(2, -t.z),
                  n = t.x * r,
                  i = (t.x + 1) * r,
                  s = t.y * r,
                  a = (t.y + 1) * r,
                  o = ou(n),
                  l = ou(i),
                  u = lu(s),
                  c = lu(a),
                  h = e.project(o, u),
                  p = e.project(l, u),
                  f = e.project(l, c),
                  d = e.project(o, c);let y = Math.min(h.x, p.x, f.x, d.x),
                m = Math.min(h.y, p.y, f.y, d.y),
                g = Math.max(h.x, p.x, f.x, d.x),
                x = Math.max(h.y, p.y, f.y, d.y);const v = r / 16;function b(t, r, n, i, s, a) {
                const o = (n + s) / 2,
                      l = (i + a) / 2,
                      u = e.project(ou(o), lu(l)),
                      c = Math.max(0, y - u.x, m - u.y, u.x - g, u.y - x);y = Math.min(y, u.x), g = Math.max(g, u.x), m = Math.min(m, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, o, l), b(u, r, o, l, s, a));
            }b(h, p, n, s, i, s), b(p, f, i, s, i, a), b(f, d, i, a, n, a), b(d, h, n, a, n, s), y -= v, m -= v, g += v, x += v;const w = 1 / Math.max(g - y, x - m);return { scale: w, x: y * w, y: m * w, x2: g * w, y2: x * w, projection: e };
        }const Lf = Eo(new Float32Array(16));class Ff {
            constructor(t) {
                this.spec = t, this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
            }project(t, e) {
                return { x: 0, y: 0, z: 0 };
            }unproject(t, e) {
                return new ru(0, 0);
            }projectTilePoint(t, e, r) {
                return { x: t, y: e, z: 0 };
            }locationPoint(t, e, r = !0) {
                return t._coordinatePoint(t.locationCoordinate(e), r);
            }pixelsPerMeter(t, e) {
                return au(1, t) * e;
            }pixelSpaceConversion(t, e, r) {
                return 1;
            }farthestPixelDistance(t) {
                return Df(t, t.pixelsPerMeter);
            }pointCoordinate(t, e, r, n) {
                const i = t.horizonLineFromTop(!1),
                      s = new d(e, Math.max(i, r));return t.rayIntersectionCoordinate(t.pointRayIntersection(s, n));
            }pointCoordinate3D(t, e, r) {
                const n = new d(e, r);if (t.elevation) return t.elevation.pointCoordinate(n);{
                    const e = this.pointCoordinate(t, n.x, n.y, 0);return [e.x, e.y, e.z];
                }
            }isPointAboveHorizon(t, e) {
                if (t.elevation) return !this.pointCoordinate3D(t, e.x, e.y);const r = t.horizonLineFromTop();return e.y < r;
            }createInversionMatrix(t, e) {
                return Lf;
            }createTileMatrix(t, e, r) {
                let n, i, s;const a = r.canonical,
                      o = Eo(new Float64Array(16));if (this.isReprojectedInTileSpace) {
                    const l = Vf(a, this);n = 1, i = l.x + r.wrap * l.scale, s = l.y, Vo(o, o, [n / l.scale, n / l.scale, t.pixelsPerMeter / e]);
                } else n = e / t.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;return Do(o, o, [i, s, 0]), Vo(o, o, [n / ko, n / ko, 1]), o;
            }upVector(t, e, r) {
                return [0, 0, 1];
            }upVectorScale(t, e, r) {
                return { metersToTile: 1 };
            }
        }class Rf extends Ff {
            constructor(t) {
                super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];const [e, r] = this.parallels = t.parallels || [29.5, 45.5],
                      n = Math.sin(x(e));this.n = (n + Math.sin(x(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
            }project(t, e) {
                const { n: r, c: n, r0: i } = this,
                      s = x(t - this.center[0]),
                      a = x(e),
                      o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;return { x: o * Math.sin(s * r), y: o * Math.cos(s * r) - i, z: 0 };
            }unproject(t, e) {
                const { n: r, c: n, r0: i } = this,
                      s = i + e;let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));const o = x(this.center[0]) * r;a = I(a, -Math.PI - o, Math.PI - o);const l = S(v(a / r) + this.center[0], -180, 180),
                      u = Math.asin(S((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),
                      c = S(v(u), -cu, cu);return new ru(l, c);
            }
        }const jf = 1.340264,
              Uf = -.081106,
              $f = 893e-6,
              Of = .003796,
              qf = Math.sqrt(3) / 2;class Nf extends Ff {
            project(t, e) {
                e = e / 180 * Math.PI, t = t / 180 * Math.PI;const r = Math.asin(qf * Math.sin(e)),
                      n = r * r,
                      i = n * n * n;return { x: .5 * (t * Math.cos(r) / (qf * (jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n))) / Math.PI + .5), y: 1 - .5 * (r * (jf + Uf * n + i * ($f + Of * n)) / Math.PI + 1), z: 0 };
            }unproject(t, e) {
                t = (2 * t - .5) * Math.PI;let r = e = (2 * (1 - e) - 1) * Math.PI,
                    n = r * r,
                    i = n * n * n;for (let t, s, a, o = 0; o < 12 && (s = r * (jf + Uf * n + i * ($f + Of * n)) - e, a = jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n), t = s / a, r = S(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++o);const s = qf * t * (jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n)) / Math.cos(r),
                      a = Math.asin(Math.sin(r) / qf),
                      o = S(180 * s / Math.PI, -180, 180),
                      l = S(180 * a / Math.PI, -cu, cu);return new ru(o, l);
            }
        }class Gf extends Ff {
            constructor(t) {
                super(t), this.wrap = !0, this.supportsWorldCopies = !0;
            }project(t, e) {
                return { x: .5 + t / 360, y: .5 - e / 360, z: 0 };
            }unproject(t, e) {
                const r = 360 * (t - .5),
                      n = S(360 * (.5 - e), -cu, cu);return new ru(r, n);
            }
        }const Xf = Math.PI / 2;function Zf(t) {
            return Math.tan((Xf + t) / 2);
        }class Kf extends Ff {
            constructor(t) {
                super(t), this.center = t.center || [0, 30];const [e, r] = this.parallels = t.parallels || [30, 30];let n = x(e),
                    i = x(r);this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);const s = Math.cos(n),
                      a = Zf(n);this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Zf(i) / a), this.f = s * Math.pow(Zf(n), this.n) / this.n;
            }project(t, e) {
                e = x(e), this.southernCenter && (e = -e), t = x(t - this.center[0]);const r = 1e-6,
                      { n: n, f: i } = this;i > 0 ? e < -Xf + r && (e = -Xf + r) : e > Xf - r && (e = Xf - r);const s = i / Math.pow(Zf(e), n);let a = s * Math.sin(n * t),
                    o = i - s * Math.cos(n * t);return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), { x: a, y: this.southernCenter ? o : 1 - o, z: 0 };
            }unproject(t, e) {
                t = (2 * t - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;const { n: r, f: n } = this,
                      i = n - e,
                      s = Math.sign(i),
                      a = Math.sign(r) * Math.sqrt(t * t + i * i);let o = Math.atan2(t, Math.abs(i)) * s;i * r < 0 && (o -= Math.PI * Math.sign(t) * s);const l = S(v(o / r) + this.center[0], -180, 180),
                      u = S(v(2 * Math.atan(Math.pow(n / a, 1 / r)) - Xf), -cu, cu);return new ru(l, this.southernCenter ? -u : u);
            }
        }class Yf extends Ff {
            constructor(t) {
                super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }project(t, e) {
                return { x: iu(t), y: su(e), z: 0 };
            }unproject(t, e) {
                const r = ou(t),
                      n = lu(e);return new ru(r, n);
            }
        }const Hf = x(cu);class Wf extends Ff {
            project(t, e) {
                const r = (e = x(e)) * e,
                      n = r * r;return { x: .5 * ((t = x(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5), y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1), z: 0 };
            }unproject(t, e) {
                t = (2 * t - .5) * Math.PI;let r = e = (2 * (1 - e) - 1) * Math.PI,
                    n = 25,
                    i = 0,
                    s = r * r;do {
                    s = r * r;const t = s * s;i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))), r = S(r - i, -Hf, Hf);
                } while (Math.abs(i) > 1e-6 && --n > 0);s = r * r;const a = S(v(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180),
                      o = v(r);return new ru(a, o);
            }
        }const Jf = x(cu);class Qf extends Ff {
            project(t, e) {
                e = x(e), t = x(t);const r = Math.cos(e),
                      n = 2 / Math.PI,
                      i = Math.acos(r * Math.cos(t / 2)),
                      s = Math.sin(i) / i,
                      a = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0,
                      o = .5 * (e + Math.sin(e) / s) || 0;return { x: .5 * (a / Math.PI + .5), y: 1 - .5 * (o / Math.PI + 1), z: 0 };
            }unproject(t, e) {
                let r = t = (2 * t - .5) * Math.PI,
                    n = e = (2 * (1 - e) - 1) * Math.PI,
                    i = 25;const s = 1e-6;let a = 0,
                    o = 0;do {
                    const i = Math.cos(n),
                          s = Math.sin(n),
                          l = 2 * s * i,
                          u = s * s,
                          c = i * i,
                          h = Math.cos(r / 2),
                          p = Math.sin(r / 2),
                          f = 2 * h * p,
                          d = p * p,
                          y = 1 - c * h * h,
                          m = y ? 1 / y : 0,
                          g = y ? Math.acos(i * h) * Math.sqrt(1 / y) : 0,
                          x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t,
                          v = .5 * (g * s + n) - e,
                          b = .5 * m * (c * d + g * i * h * u) + 1 / Math.PI,
                          w = m * (f * l / 4 - g * s * p),
                          _ = .125 * m * (l * p - g * s * c * f),
                          A = .5 * m * (u * h + g * d * i) + .5,
                          k = w * _ - A * b;a = (v * w - x * A) / k, o = (x * _ - v * b) / k, r = S(r - a, -Math.PI, Math.PI), n = S(n - o, -Jf, Jf);
                } while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);return new ru(v(r), v(n));
            }
        }class td extends Ff {
            constructor(t) {
                super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(x(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }project(t, e) {
                const { scale: r, cosPhi: n } = this;return { x: x(t) * n * r + .5, y: -Math.sin(x(e)) / n * r + .5, z: 0 };
            }unproject(t, e) {
                const { scale: r, cosPhi: n } = this,
                      i = -(e - .5) / r,
                      s = S(v((t - .5) / r) / n, -180, 180),
                      a = Math.asin(S(i * n, -1, 1)),
                      o = S(v(a), -cu, cu);return new ru(s, o);
            }
        }class ed extends Yf {
            constructor(t) {
                super(t), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
            }projectTilePoint(t, e, r) {
                const n = Ol(t, e, r);return el(n, n, Gl(Pl(r))), { x: n[0], y: n[1], z: n[2] };
            }locationPoint(t, e) {
                const r = $l(e.lat, e.lng),
                      n = Jo([], r),
                      i = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;Wo(r, r, n, au(1, 0) * ko * i);const s = Eo(new Float64Array(16));return Po(s, t.pixelMatrix, t.globeMatrix), el(r, r, s), new d(r[0], r[1]);
            }pixelsPerMeter(t, e) {
                return au(1, 0) * e;
            }pixelSpaceConversion(t, e, r) {
                const n = au(1, t) * e,
                      i = Mr(au(1, 45) * e, n, r);return this.pixelsPerMeter(t, e) / i;
            }createTileMatrix(t, e, r) {
                const n = Xl(Pl(r.canonical));return Po(new Float64Array(16), t.globeMatrix, n);
            }createInversionMatrix(t, e) {
                const { center: r } = t,
                      n = Gl(Pl(e));return Fo(n, n, x(r.lng)), Lo(n, n, x(r.lat)), Vo(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]), Float32Array.from(n);
            }pointCoordinate(t, e, r, n) {
                return Bl(t, e, r, !0) || new pu(0, 0);
            }pointCoordinate3D(t, e, r) {
                const n = this.pointCoordinate(t, e, r, 0);return [n.x, n.y, n.z];
            }isPointAboveHorizon(t, e) {
                return !Bl(t, e.x, e.y, !1);
            }farthestPixelDistance(t) {
                const e = function (t, e) {
                    const r = t.cameraToCenterDistance,
                          n = t._centerAltitude * e,
                          i = t._camera,
                          s = t._camera.forward(),
                          a = Go([], Ho([], s, -r), [0, 0, n]),
                          o = t.worldSize / (2 * Math.PI),
                          l = [0, 0, -o],
                          u = t.width / t.height,
                          c = Math.tan(t.fovAboveCenter),
                          h = Ho([], i.up(), c),
                          p = Ho([], i.right(), c * u),
                          f = Jo([], Go([], Go([], s, h), p)),
                          d = [];let y;if (new vl(a, f).closestPointOnSphere(l, o, d)) {
                        const e = Go([], d, l),
                              r = il([], e, a);y = Math.cos(t.fovAboveCenter) * qo(r);
                    } else {
                        const t = il([], a, l),
                              e = il([], l, a);Jo(e, e);const r = qo(t) - o;y = Math.sqrt(r * (r + 2 * o));const n = Math.acos(y / (o + r)) - Math.acos(Qo(s, e));y *= Math.cos(n);
                    }return 1.01 * y;
                }(t, this.pixelsPerMeter(t.center.lat, t.worldSize)),
                      r = Kl(t.zoom);if (r > 0) {
                    const n = Df(t, au(1, t.center.lat) * t.worldSize),
                          i = t.worldSize / (2 * Math.PI),
                          s = Math.max(t.width, t.height) / t.worldSize * Math.PI;return Mr(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10));
                }return e;
            }upVector(t, e, r) {
                return Ol(e, r, t, 1);
            }upVectorScale(t) {
                return { metersToTile: zl(ql(Pl(t))) };
            }
        }function rd(t) {
            const e = t.parallels,
                  r = !!e && Math.abs(e[0] + e[1]) < .01;switch (t.name) {case "mercator":
                    return new Yf(t);case "equirectangular":
                    return new Gf(t);case "naturalEarth":
                    return new Wf(t);case "equalEarth":
                    return new Nf(t);case "winkelTripel":
                    return new Qf(t);case "albers":
                    return r ? new td(t) : new Rf(t);case "lambertConformalConic":
                    return r ? new td(t) : new Kf(t);case "globe":
                    return new ed(t);}throw new Error(`Invalid projection name: ${t.name}`);
        }const nd = ah.types,
              id = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];function sd(t, e, r, n, i, s, a, o, l, u, c, h, p) {
            const f = o ? Math.min(Tf, Math.round(o[0])) : 0,
                  d = o ? Math.min(Tf, Math.round(o[1])) : 0;t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);
        }function ad(t, e, r, n, i, s, a) {
            t.emplaceBack(e, r, n, i, s, a);
        }function od(t, e, r, n, i) {
            t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i);
        }function ld(t) {
            for (const e of t.sections) if (Ms(e.text)) return !0;return !1;
        }class ud {
            constructor(t) {
                this.layoutVertexArray = new fa(), this.indexArray = new wa(), this.programConfigurations = t, this.segments = new So(), this.dynamicLayoutVertexArray = new ua(), this.opacityVertexArray = new ya(), this.placedSymbolArray = new Pa(), this.globeExtVertexArray = new da();
            }isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }upload(t, e, r, n) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Nh.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Xh.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, id, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Gh.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));
            }destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
        }Oi(ud, "SymbolBuffers");class cd {
            constructor(t, e, r) {
                this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new So(), this.collisionVertexArray = new va(), this.collisionVertexArrayExt = new ba();
            }upload(t) {
                this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Zh.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, Kh.members, !0);
            }destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }Oi(cd, "CollisionBuffers");class hd {
            constructor(t) {
                this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Eo([]), this.placementViewportMatrix = Eo([]);const e = this.layers[0]._unevaluatedLayout._values;this.textSizeData = Qh(this.zoom, e["text-size"]), this.iconSizeData = Qh(this.zoom, e["icon-size"]);const r = this.layers[0].layout,
                      n = r.get("symbol-sort-key"),
                      i = r.get("symbol-z-order");this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map(t => Vp[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID, this.projection = t.projection;
            }createArrays() {
                this.text = new ud(new fo(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new ud(new fo(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new La(), this.lineVertexArray = new Fa(), this.symbolInstances = new Va();
            }calculateGlyphDependencies(t, e, r, n, i) {
                for (let r = 0; r < t.length; r++) if (e[t.charCodeAt(r)] = !0, n && i) {
                    const n = ip[t.charAt(r)];n && (e[n.charCodeAt(0)] = !0);
                }
            }populate(t, e, r, n) {
                const i = this.layers[0],
                      s = i.layout,
                      a = "globe" === this.projection.name,
                      o = s.get("text-font"),
                      l = s.get("text-field"),
                      u = s.get("icon-image"),
                      c = ("constant" !== l.value.kind || l.value.value instanceof Be && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0),
                      h = "constant" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0,
                      p = s.get("symbol-sort-key");if (this.features = [], !c && !h) return;const f = e.iconDependencies,
                      d = e.glyphDependencies,
                      y = e.availableImages,
                      m = new Us(this.zoom);for (const { feature: e, id: l, index: u, sourceLayerIndex: g } of t) {
                    const t = i._featureFilter.needGeometry,
                          x = wu(e, t);if (!i._featureFilter.filter(m, x, r)) continue;if (t || (x.geometry = bu(e, r, n)), a && 1 !== e.type && r.z <= 5) {
                        const t = x.geometry,
                              e = .98078528056,
                              n = (t, n) => Qo(Ol(t.x, t.y, r, 1), Ol(n.x, n.y, r, 1)) < e;for (let e = 0; e < t.length; e++) t[e] = mu(t[e], n);
                    }let v, b;if (c) {
                        const t = i.getValueAndResolveTokens("text-field", x, r, y),
                              e = Be.factory(t);ld(e) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Fs() || this.hasRTLText && js.isParsed()) && (v = np(e, i, x));
                    }if (h) {
                        const t = i.getValueAndResolveTokens("icon-image", x, r, y);b = t instanceof Ee ? t : Ee.fromString(t);
                    }if (!v && !b) continue;const w = this.sortFeaturesByKey ? p.evaluate(x, {}, r) : void 0;if (this.features.push({ id: l, text: v, icon: b, index: u, sourceLayerIndex: g, geometry: x.geometry, properties: e.properties, type: nd[e.type], sortKey: w }), b && (f[b.name] = !0), v) {
                        const t = o.evaluate(x, {}, r).join(","),
                              e = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Vp.vertical) >= 0;for (const r of v.sections) if (r.image) f[r.image.name] = !0;else {
                            const n = bs(v.toString()),
                                  i = r.fontStack || t,
                                  s = d[i] = d[i] || {};this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);
                        }
                    }
                }"line" === s.get("symbol-placement") && (this.features = function (t) {
                    const e = {},
                          r = {},
                          n = [];let i = 0;function s(e) {
                        n.push(t[e]), i++;
                    }function a(t, e, i) {
                        const s = r[t];return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
                    }function o(t, r, i) {
                        const s = e[r];return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
                    }function l(t, e, r) {
                        const n = r ? e[0][e[0].length - 1] : e[0][0];return `${t}:${n.x}:${n.y}`;
                    }for (let u = 0; u < t.length; u++) {
                        const c = t[u],
                              h = c.geometry,
                              p = c.text ? c.text.toString() : null;if (!p) {
                            s(u);continue;
                        }const f = l(p, h),
                              d = l(p, h, !0);if (f in r && d in e && r[f] !== e[d]) {
                            const t = o(f, d, h),
                                  i = a(f, d, n[t].geometry);delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;
                        } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);
                    }return n.filter(t => t.geometry);
                }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);
            }update(t, e, r, n) {
                this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r, n));
            }isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }upload(t) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
            }destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }getProjection() {
                return this.projectionInstance || (this.projectionInstance = rd(this.projection)), this.projectionInstance;
            }destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }addToLineVertexArray(t, e) {
                const r = this.lineVertexArray.length;if (void 0 !== t.segment) for (const { x: t, y: r } of e) this.lineVertexArray.emplaceBack(t, r);return { lineStartIndex: r, lineLength: this.lineVertexArray.length - r };
            }addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d = t.indexArray,
                      y = t.layoutVertexArray,
                      m = t.globeExtVertexArray,
                      g = t.segments.prepareSegment(4 * e.length, y, d, this.canOverlap ? s.sortKey : void 0),
                      x = this.glyphOffsetArray.length,
                      v = g.vertexLength,
                      b = this.allowVerticalPlacement && a === Vp.vertical ? Math.PI / 2 : 0,
                      w = s.text && s.text.sections;for (let n = 0; n < e.length; n++) {
                    const { tl: i, tr: a, bl: u, br: c, tex: h, pixelOffsetTL: x, pixelOffsetBR: v, minFontScaleX: _, minFontScaleY: A, glyphOffset: S, isSDF: k, sectionIndex: I } = e[n],
                          M = g.vertexLength,
                          T = S[1];if (sd(y, l.x, l.y, i.x, T + i.y, h.x, h.y, r, k, x.x, x.y, _, A), sd(y, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, k, v.x, x.y, _, A), sd(y, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, k, x.x, v.y, _, A), sd(y, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, k, v.x, v.y, _, A), o) {
                        const { x: e, y: r, z: n } = o.anchor,
                              [i, s, a] = o.up;ad(m, e, r, n, i, s, a), ad(m, e, r, n, i, s, a), ad(m, e, r, n, i, s, a), ad(m, e, r, n, i, s, a), od(t.dynamicLayoutVertexArray, e, r, n, b);
                    } else od(t.dynamicLayoutVertexArray, l.x, l.y, l.z, b);d.emplaceBack(M, M + 1, M + 2), d.emplaceBack(M + 1, M + 2, M + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S[0]), n !== e.length - 1 && I === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, f, w && w[I]);
                }const _ = o ? o.anchor : l;t.placedSymbolArray.emplaceBack(_.x, _.y, _.z, l.x, l.y, x, this.glyphOffsetArray.length - x, v, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
            }_commitLayoutVertex(t, e, r, n, i, s, a) {
                t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));
            }_addCollisionDebugVertices(t, e, r, n, i, s, a) {
                const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),
                      l = o.vertexLength,
                      u = a.tileAnchorX,
                      c = a.tileAnchorY;for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0);r.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding), r.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x1, t.y2)), o.vertexLength += 4;const h = r.indexArray;h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;
            }_addTextDebugCollisionBoxes(t, e, r, n, i, s) {
                for (let a = n; a < i; a++) {
                    const n = r.get(a),
                          i = this.getSymbolInstanceTextSize(t, s, e, a);this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }_addIconDebugCollisionBoxes(t, e, r, n, i, s) {
                for (let a = n; a < i; a++) {
                    const n = r.get(a),
                          i = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }generateCollisionDebugBuffers(t, e) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new cd(ga, Yh.members, Ma), this.iconCollisionBox = new cd(ga, Yh.members, Ma);const r = ep(this.iconSizeData, t),
                      n = ep(this.textSizeData, t);for (let i = 0; i < this.symbolInstances.length; i++) {
                    const s = this.symbolInstances.get(i);this._addTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
            }getSymbolInstanceTextSize(t, e, r, n) {
                const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),
                      s = tp(this.textSizeData, t, i) / Wh;return this.tilePixelRatio * s;
            }getSymbolInstanceIconSize(t, e, r) {
                const n = this.icon.placedSymbolArray.get(r),
                      i = tp(this.iconSizeData, t, n);return this.tilePixelRatio * i;
            }_commitDebugCollisionVertexUpdate(t, e, r) {
                t.emplaceBack(e, -r, -r), t.emplaceBack(e, r, -r), t.emplaceBack(e, r, r), t.emplaceBack(e, -r, r);
            }_updateTextDebugCollisionBoxes(t, e, r, n, i, s) {
                for (let a = n; a < i; a++) {
                    const n = r.get(a),
                          i = this.getSymbolInstanceTextSize(t, s, e, a);this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }_updateIconDebugCollisionBoxes(t, e, r, n, i, s) {
                for (let a = n; a < i; a++) {
                    const n = r.get(a),
                          i = this.getSymbolInstanceIconSize(t, e, s);this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }updateCollisionDebugBuffers(t, e) {
                if (!this.hasDebugData()) return;this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();const r = ep(this.iconSizeData, t),
                      n = ep(this.textSizeData, t);for (let i = 0; i < this.symbolInstances.length; i++) {
                    const s = this.symbolInstances.get(i);this._updateTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s.placedIconSymbolIndex);
                }this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }_deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {
                const u = {};if (e < r) {
                    const { x1: r, y1: n, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t.get(e);u.textBox = { x1: r, y1: n, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p }, u.textFeatureIndex = f;
                }if (n < i) {
                    const { x1: e, y1: r, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t.get(n);u.verticalTextBox = { x1: e, y1: r, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p }, u.verticalTextFeatureIndex = f;
                }if (s < a) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t.get(s);u.iconBox = { x1: e, y1: r, x2: n, y2: i, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p }, u.iconFeatureIndex = f;
                }if (o < l) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t.get(o);u.verticalIconBox = { x1: e, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p }, u.verticalIconFeatureIndex = f;
                }return u;
            }deserializeCollisionBoxes(t) {
                this.collisionArrays = [];for (let e = 0; e < this.symbolInstances.length; e++) {
                    const r = this.symbolInstances.get(e);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }hasTextData() {
                return this.text.segments.get().length > 0;
            }hasIconData() {
                return this.icon.segments.get().length > 0;
            }hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }addIndicesForPlacedSymbol(t, e) {
                const r = t.placedSymbolArray.get(e),
                      n = r.vertexStartIndex + 4 * r.numGlyphs;for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);
            }getSortedSymbolIndexes(t) {
                if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;const e = Math.sin(t),
                      r = Math.cos(t),
                      n = [],
                      i = [],
                      s = [];for (let t = 0; t < this.symbolInstances.length; ++t) {
                    s.push(t);const a = this.symbolInstances.get(t);n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);
                }return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;
            }addToSortKeyRanges(t, e) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: e, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
            }sortFeatures(t) {
                if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];for (const t of this.symbolInstanceIndexes) {
                        const e = this.symbolInstances.get(t);this.featureSortOrder.push(e.featureIndex);const { rightJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: i, verticalPlacedTextSymbolIndex: s, placedIconSymbolIndex: a, verticalPlacedIconSymbolIndex: o } = e;r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);
                    }this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }Oi(hd, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), hd.MAX_GLYPHS = 65535, hd.addDynamicAttributes = od;const pd = new Js({ "symbol-placement": new Ys(Ht.layout_symbol["symbol-placement"]), "symbol-spacing": new Ys(Ht.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ys(Ht.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Hs(Ht.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ys(Ht.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ys(Ht.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Ys(Ht.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ys(Ht.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ys(Ht.layout_symbol["icon-rotation-alignment"]), "icon-size": new Hs(Ht.layout_symbol["icon-size"]), "icon-text-fit": new Ys(Ht.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ys(Ht.layout_symbol["icon-text-fit-padding"]), "icon-image": new Hs(Ht.layout_symbol["icon-image"]), "icon-rotate": new Hs(Ht.layout_symbol["icon-rotate"]), "icon-padding": new Ys(Ht.layout_symbol["icon-padding"]), "icon-keep-upright": new Ys(Ht.layout_symbol["icon-keep-upright"]), "icon-offset": new Hs(Ht.layout_symbol["icon-offset"]), "icon-anchor": new Hs(Ht.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ys(Ht.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ys(Ht.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ys(Ht.layout_symbol["text-rotation-alignment"]), "text-field": new Hs(Ht.layout_symbol["text-field"]), "text-font": new Hs(Ht.layout_symbol["text-font"]), "text-size": new Hs(Ht.layout_symbol["text-size"]), "text-max-width": new Hs(Ht.layout_symbol["text-max-width"]), "text-line-height": new Hs(Ht.layout_symbol["text-line-height"]), "text-letter-spacing": new Hs(Ht.layout_symbol["text-letter-spacing"]), "text-justify": new Hs(Ht.layout_symbol["text-justify"]), "text-radial-offset": new Hs(Ht.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ys(Ht.layout_symbol["text-variable-anchor"]), "text-anchor": new Hs(Ht.layout_symbol["text-anchor"]), "text-max-angle": new Ys(Ht.layout_symbol["text-max-angle"]), "text-writing-mode": new Ys(Ht.layout_symbol["text-writing-mode"]), "text-rotate": new Hs(Ht.layout_symbol["text-rotate"]), "text-padding": new Ys(Ht.layout_symbol["text-padding"]), "text-keep-upright": new Ys(Ht.layout_symbol["text-keep-upright"]), "text-transform": new Hs(Ht.layout_symbol["text-transform"]), "text-offset": new Hs(Ht.layout_symbol["text-offset"]), "text-allow-overlap": new Ys(Ht.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Ys(Ht.layout_symbol["text-ignore-placement"]), "text-optional": new Ys(Ht.layout_symbol["text-optional"]) });var fd = { paint: new Js({ "icon-opacity": new Hs(Ht.paint_symbol["icon-opacity"]), "icon-color": new Hs(Ht.paint_symbol["icon-color"]), "icon-halo-color": new Hs(Ht.paint_symbol["icon-halo-color"]), "icon-halo-width": new Hs(Ht.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Hs(Ht.paint_symbol["icon-halo-blur"]), "icon-translate": new Ys(Ht.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ys(Ht.paint_symbol["icon-translate-anchor"]), "text-opacity": new Hs(Ht.paint_symbol["text-opacity"]), "text-color": new Hs(Ht.paint_symbol["text-color"], { runtimeType: le, getOverride: t => t.textColor, hasOverride: t => !!t.textColor }), "text-halo-color": new Hs(Ht.paint_symbol["text-halo-color"]), "text-halo-width": new Hs(Ht.paint_symbol["text-halo-width"]), "text-halo-blur": new Hs(Ht.paint_symbol["text-halo-blur"]), "text-translate": new Ys(Ht.paint_symbol["text-translate"]), "text-translate-anchor": new Ys(Ht.paint_symbol["text-translate-anchor"]) }), layout: pd };class dd {
            constructor(t) {
                this.type = t.property.overrides ? t.property.overrides.runtimeType : ie, this.defaultValue = t;
            }evaluate(t) {
                if (t.formattedSection) {
                    const e = this.defaultValue.property.overrides;if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);
                }return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
            }eachChild(t) {
                this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
            }outputDefined() {
                return !1;
            }serialize() {
                return null;
            }
        }Oi(dd, "FormatSectionOverride", { omit: ["defaultValue"] });class yd extends wo {
            constructor(t) {
                super(t, fd);
            }recalculate(t, e) {
                super.recalculate(t, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));const r = this.layout.get("text-writing-mode");if (r) {
                    const t = [];for (const e of r) t.indexOf(e) < 0 && t.push(e);this.layout._values["text-writing-mode"] = t;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];this._setPaintOverrides();
            }getValueAndResolveTokens(t, e, r, n) {
                const i = this.layout.get(t).evaluate(e, {}, r, n),
                      s = this._unevaluatedLayout._values[t];return s.isDataDriven() || Nn(s.value) || !i ? i : function (t, e) {
                    return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : "");
                }(e.properties, i);
            }createBucket(t) {
                return new hd(t);
            }queryRadius() {
                return 0;
            }queryIntersectsFeature() {
                return !1;
            }_setPaintOverrides() {
                for (const t of fd.paint.overridableProperties) {
                    if (!yd.hasPaintOverride(this.layout, t)) continue;const e = this.paint.get(t),
                          r = new dd(e),
                          n = new qn(r, e.property.specification);let i = null;i = "constant" === e.value.kind || "source" === e.value.kind ? new Xn("source", n) : new Zn("composite", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new Zs(e.property, i, e.parameters);
                }
            }_handleOverridablePaintPropertyUpdate(t, e, r) {
                return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && yd.hasPaintOverride(this.layout, t);
            }static hasPaintOverride(t, e) {
                const r = t.get("text-field"),
                      n = fd.paint.properties[e];let i = !1;const s = t => {
                    for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);
                };if ("constant" === r.value.kind && r.value.value instanceof Be) s(r.value.value.sections);else if ("source" === r.value.kind) {
                    const t = e => {
                        i || (e instanceof Fe && De(e.value) === pe ? s(e.value.sections) : e instanceof Oe ? s(e.sections) : e.eachChild(t));
                    },
                          e = r.value;e._styleExpression && t(e._styleExpression.expression);
                }return i;
            }getProgramConfiguration(t) {
                return new po(this, t);
            }
        }var md = { paint: new Js({ "background-color": new Ys(Ht.paint_background["background-color"]), "background-pattern": new Ys(Ht.paint_background["background-pattern"]), "background-opacity": new Ys(Ht.paint_background["background-opacity"]) }) },
            gd = { paint: new Js({ "raster-opacity": new Ys(Ht.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ys(Ht.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ys(Ht.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ys(Ht.paint_raster["raster-brightness-max"]), "raster-saturation": new Ys(Ht.paint_raster["raster-saturation"]), "raster-contrast": new Ys(Ht.paint_raster["raster-contrast"]), "raster-resampling": new Ys(Ht.paint_raster["raster-resampling"]), "raster-fade-duration": new Ys(Ht.paint_raster["raster-fade-duration"]) }) };class xd extends wo {
            constructor(t) {
                super(t, {}), this.implementation = t;
            }is3D() {
                return "3d" === this.implementation.renderingMode;
            }hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }isLayerDraped() {
                return void 0 !== this.implementation.renderToTile;
            }shouldRedrape() {
                return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }recalculate() {}updateTransitions() {}hasTransition() {
                return !1;
            }serialize() {}onAdd(t) {
                this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);
            }onRemove(t) {
                this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);
            }
        }var vd = { paint: new Js({ "sky-type": new Ys(Ht.paint_sky["sky-type"]), "sky-atmosphere-sun": new Ys(Ht.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Ys(Ht.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Ys(Ht.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Ys(Ht.paint_sky["sky-gradient-radius"]), "sky-gradient": new Ws(Ht.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Ys(Ht.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Ys(Ht.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Ys(Ht.paint_sky["sky-opacity"]) }) };function bd(t, e, r) {
            const n = [0, 0, 1],
                  i = hl([]);return fl(i, i, r ? -x(t) + Math.PI : x(t)), pl(i, i, -x(e)), rl(n, n, i), Jo(n, n);
        }const wd = { circle: class extends wo {
                constructor(t) {
                    super(t, Ou);
                }createBucket(t) {
                    return new Su(t);
                }queryRadius(t) {
                    const e = t;return Fu("circle-radius", this, e) + Fu("circle-stroke-width", this, e) + Ru(this.paint.get("circle-translate"));
                }queryIntersectsFeature(t, e, r, n, i, s, a, o) {
                    const l = Uu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t.pixelToTileUnitsFactor),
                          u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);return qu(t, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
                }getProgramIds() {
                    return ["circle"];
                }getProgramConfiguration(t) {
                    return new po(this, t);
                }
            }, heatmap: class extends wo {
                createBucket(t) {
                    return new Ku(t);
                }constructor(t) {
                    super(t, tc), this._updateColorRamp();
                }_handleSpecialPaintPropertyUpdate(t) {
                    "heatmap-color" === t && this._updateColorRamp();
                }_updateColorRamp() {
                    this.colorRamp = ec({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
                }resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }queryRadius(t) {
                    return Fu("heatmap-radius", this, t);
                }queryIntersectsFeature(t, e, r, n, i, s, a, o) {
                    const l = this.paint.get("heatmap-radius").evaluate(e, r);return qu(t, n, s, a, o, !0, !0, new d(0, 0), l);
                }hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }getProgramIds() {
                    return ["heatmap", "heatmapTexture"];
                }getProgramConfiguration(t) {
                    return new po(this, t);
                }
            }, hillshade: class extends wo {
                constructor(t) {
                    super(t, rc);
                }hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }getProgramIds() {
                    return ["hillshade", "hillshadePrepare"];
                }
            }, fill: class extends wo {
                constructor(t) {
                    super(t, Oc);
                }getProgramIds() {
                    const t = this.paint.get("fill-pattern"),
                          e = t && t.constantOr(1),
                          r = [e ? "fillPattern" : "fill"];return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
                }getProgramConfiguration(t) {
                    return new po(this, t);
                }recalculate(t, e) {
                    super.recalculate(t, e);const r = this.paint._values["fill-outline-color"];"constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }createBucket(t) {
                    return new Uc(t);
                }queryRadius() {
                    return Ru(this.paint.get("fill-translate"));
                }queryIntersectsFeature(t, e, r, n, i, s) {
                    return !t.queryGeometry.isAboveHorizon && Mu(ju(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), n);
                }isTileClipped() {
                    return !0;
                }
            }, "fill-extrusion": class extends wo {
                constructor(t) {
                    super(t, Ah);
                }createBucket(t) {
                    return new fh(t);
                }queryRadius() {
                    return Ru(this.paint.get("fill-extrusion-translate"));
                }is3D() {
                    return !0;
                }getProgramIds() {
                    return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
                }getProgramConfiguration(t) {
                    return new po(this, t);
                }queryIntersectsFeature(t, e, r, n, i, s, a, o, l) {
                    const u = Uu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, t.pixelToTileUnitsFactor),
                          c = this.paint.get("fill-extrusion-height").evaluate(e, r),
                          h = this.paint.get("fill-extrusion-base").evaluate(e, r),
                          p = [0, 0],
                          f = o && s.elevation,
                          y = s.elevation ? s.elevation.exaggeration() : 1,
                          m = t.tile.getBucket(this);if (f && m instanceof fh) {
                        const t = m.centroidVertexArray,
                              e = l + 1;e < t.length && (p[0] = t.geta_centroid_pos0(e), p[1] = t.geta_centroid_pos1(e));
                    }if (0 === p[0] && 1 === p[1]) return !1;"globe" === s.projection.name && (n = wh([n], [new d(0, 0), new d(ko, ko)], t.tileID.canonical).map(t => t.polygon).flat());const g = f ? o : null,
                          [x, v] = function (t, e, r, n, i, s, a, o, l, u, c) {
                        return "globe" === t.projection.name ? function (t, e, r, n, i, s, a, o, l, u, c) {
                            const h = [],
                                  p = [],
                                  f = t.projection.upVectorScale(c, t.center.lat, t.worldSize).metersToTile,
                                  d = [0, 0, 0, 1],
                                  y = [0, 0, 0, 1],
                                  m = (t, e, r, n) => {
                                t[0] = e, t[1] = r, t[2] = n, t[3] = 1;
                            },
                                  g = bh();r > 0 && (r += g), n += g;for (const g of e) {
                                const e = [],
                                      x = [];for (const h of g) {
                                    const p = h.x + i.x,
                                          g = h.y + i.y,
                                          v = t.projection.projectTilePoint(p, g, c),
                                          b = t.projection.upVector(c, h.x, h.y);let w = r,
                                        _ = n;if (a) {
                                        const t = Ch(p, g, r, n, a, o, l, u);w += t.base, _ += t.top;
                                    }0 !== r ? m(d, v.x + b[0] * f * w, v.y + b[1] * f * w, v.z + b[2] * f * w) : m(d, v.x, v.y, v.z), m(y, v.x + b[0] * f * _, v.y + b[1] * f * _, v.z + b[2] * f * _), el(d, d, s), el(y, y, s), e.push(new zh(d[0], d[1], d[2])), x.push(new zh(y[0], y[1], y[2]));
                                }h.push(e), p.push(x);
                            }return [h, p];
                        }(t, e, r, n, i, s, a, o, l, u, c) : a ? function (t, e, r, n, i, s, a, o, l) {
                            const u = [],
                                  c = [],
                                  h = [0, 0, 0, 1];for (const p of t) {
                                const t = [],
                                      f = [];for (const u of p) {
                                    const c = u.x + n.x,
                                          p = u.y + n.y,
                                          d = Ch(c, p, e, r, s, a, o, l);h[0] = c, h[1] = p, h[2] = d.base, h[3] = 1, ul(h, h, i), h[3] = Math.max(h[3], 1e-5);const y = new zh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);h[0] = c, h[1] = p, h[2] = d.top, h[3] = 1, ul(h, h, i), h[3] = Math.max(h[3], 1e-5);const m = new zh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);t.push(y), f.push(m);
                                }u.push(t), c.push(f);
                            }return [u, c];
                        }(e, r, n, i, s, a, o, l, u) : function (t, e, r, n, i) {
                            const s = [],
                                  a = [],
                                  o = i[8] * e,
                                  l = i[9] * e,
                                  u = i[10] * e,
                                  c = i[11] * e,
                                  h = i[8] * r,
                                  p = i[9] * r,
                                  f = i[10] * r,
                                  d = i[11] * r;for (const e of t) {
                                const t = [],
                                      r = [];for (const s of e) {
                                    const e = s.x + n.x,
                                          a = s.y + n.y,
                                          y = i[0] * e + i[4] * a + i[12],
                                          m = i[1] * e + i[5] * a + i[13],
                                          g = i[2] * e + i[6] * a + i[14],
                                          x = i[3] * e + i[7] * a + i[15],
                                          v = y + o,
                                          b = m + l,
                                          w = g + u,
                                          _ = Math.max(x + c, 1e-5),
                                          A = y + h,
                                          S = m + p,
                                          k = g + f,
                                          I = Math.max(x + d, 1e-5);t.push(new zh(v / _, b / _, w / _)), r.push(new zh(A / I, S / I, k / I));
                                }s.push(t), a.push(r);
                            }return [s, a];
                        }(e, r, n, i, s);
                    }(s, n, h, c, u, a, g, p, y, s.center.lat, t.tileID.canonical),
                          b = t.queryGeometry;return function (t, e, r) {
                        let n = 1 / 0;Mu(r, e) && (n = Eh(r, e[0]));for (let i = 0; i < e.length; i++) {
                            const s = e[i],
                                  a = t[i];for (let t = 0; t < s.length - 1; t++) {
                                const e = s[t],
                                      i = [e, s[t + 1], a[t + 1], a[t], e];ku(r, i) && (n = Math.min(n, Eh(r, i)));
                            }
                        }return n !== 1 / 0 && n;
                    }(x, v, b.isPointQuery() ? b.screenBounds : b.screenGeometry);
                }
            }, line: class extends wo {
                constructor(t) {
                    super(t, $h), this.gradientVersion = 0;
                }_handleSpecialPaintPropertyUpdate(t) {
                    if ("line-gradient" === t) {
                        const t = this._transitionablePaint._values["line-gradient"].value.expression;this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof Ir, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }widthExpression() {
                    return this._transitionablePaint._values["line-width"].value.expression;
                }recalculate(t, e) {
                    super.recalculate(t, e), this.paint._values["line-floorwidth"] = Oh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
                }createBucket(t) {
                    return new jh(t);
                }getProgramIds() {
                    return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
                }getProgramConfiguration(t) {
                    return new po(this, t);
                }queryRadius(t) {
                    const e = t,
                          r = qh(Fu("line-width", this, e), Fu("line-gap-width", this, e)),
                          n = Fu("line-offset", this, e);return r / 2 + Math.abs(n) + Ru(this.paint.get("line-translate"));
                }queryIntersectsFeature(t, e, r, n, i, s) {
                    if (t.queryGeometry.isAboveHorizon) return !1;const a = ju(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t.pixelToTileUnitsFactor),
                          o = t.pixelToTileUnitsFactor / 2 * qh(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)),
                          l = this.paint.get("line-offset").evaluate(e, r);return l && (n = function (t, e) {
                        const r = [],
                              n = new d(0, 0);for (let i = 0; i < t.length; i++) {
                            const s = t[i],
                                  a = [];for (let t = 0; t < s.length; t++) {
                                const r = s[t - 1],
                                      i = s[t],
                                      o = s[t + 1],
                                      l = 0 === t ? n : i.sub(r)._unit()._perp(),
                                      u = t === s.length - 1 ? n : o.sub(i)._unit()._perp(),
                                      c = l._add(u)._unit();c._mult(1 / (c.x * u.x + c.y * u.y)), a.push(c._mult(e)._add(i));
                            }r.push(a);
                        }return r;
                    }(n, l * t.pixelToTileUnitsFactor)), function (t, e, r) {
                        for (let n = 0; n < e.length; n++) {
                            const i = e[n];if (t.length >= 3) for (let e = 0; e < i.length; e++) if (Du(t, i[e])) return !0;if (Tu(t, i, r)) return !0;
                        }return !1;
                    }(a, n, o);
                }isTileClipped() {
                    return !0;
                }
            }, symbol: yd, background: class extends wo {
                constructor(t) {
                    super(t, md);
                }getProgramIds() {
                    return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
                }
            }, raster: class extends wo {
                constructor(t) {
                    super(t, gd);
                }getProgramIds() {
                    return ["raster"];
                }
            }, sky: class extends wo {
                constructor(t) {
                    super(t, vd), this._updateColorRamp();
                }_handleSpecialPaintPropertyUpdate(t) {
                    "sky-gradient" === t ? this._updateColorRamp() : "sky-atmosphere-sun" !== t && "sky-atmosphere-halo-color" !== t && "sky-atmosphere-color" !== t && "sky-atmosphere-sun-intensity" !== t || (this._skyboxInvalidated = !0);
                }_updateColorRamp() {
                    this.colorRamp = ec({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }needsSkyboxCapture(t) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = t.style.light.properties.get("position");return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
                    }return !1;
                }getCenter(t, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun"),
                              n = !r,
                              i = t.style.light,
                              s = i.properties.get("position");return n && "viewport" === i.properties.get("anchor") && $("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? bd(s.azimuthal, 90 - s.polar, e) : bd(r[0], 90 - r[1], e);
                    }const r = this.paint.get("sky-gradient-center");return bd(r[0], 90 - r[1], e);
                }is3D() {
                    return !1;
                }isSky() {
                    return !0;
                }markSkyboxValid(t) {
                    this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get("position");
                }hasOffscreenPass() {
                    return !0;
                }getProgramIds() {
                    const t = this.paint.get("sky-type");return "atmosphere" === t ? ["skyboxCapture", "skybox"] : "gradient" === t ? ["skyboxGradient"] : null;
                }
            } };class _d {
            constructor(t, e, r, n) {
                this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);
            }update(t, r, n) {
                const { width: i, height: s } = t,
                      { context: a } = this,
                      { gl: o } = a,
                      { HTMLImageElement: l, HTMLCanvasElement: u, HTMLVideoElement: c, ImageData: h, ImageBitmap: p } = e;if (o.bindTexture(o.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!r || !1 !== r.premultiply)), n || this.size && this.size[0] === i && this.size[1] === s) {
                    const { x: e, y: r } = n || { x: 0, y: 0 };t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e, r, o.RGBA, o.UNSIGNED_BYTE, t) : o.texSubImage2D(o.TEXTURE_2D, 0, e, r, i, s, o.RGBA, o.UNSIGNED_BYTE, t.data);
                } else this.size = [i, s], t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t) : o.texImage2D(o.TEXTURE_2D, 0, this.format, i, s, 0, this.format, o.UNSIGNED_BYTE, t.data);this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o.generateMipmap(o.TEXTURE_2D);
            }bind(t, e) {
                const { context: r } = this,
                      { gl: n } = r;n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);
            }isSizePowerOfTwo() {
                return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }destroy() {
                const { gl: t } = this.context;t.deleteTexture(this.texture), this.texture = null;
            }
        }class Ad {
            constructor(t) {
                this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                    this._triggered = !1, this._callback();
                });
            }trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
                    this._triggered = !1, this._callback();
                }, 0));
            }remove() {
                this._channel = void 0, this._callback = () => {};
            }
        }class Sd {
            constructor() {
                this.tasks = {}, this.taskQueue = [], V(["process"], this), this.invoker = new Ad(this.process), this.nextId = 0;
            }add(t, e) {
                const r = this.nextId++,
                      n = function ({ type: t, isSymbolTile: e, zoom: r }) {
                    return r = r || 0, "message" === t ? 0 : "maybePrepare" !== t || e ? "parseTile" !== t || e ? "parseTile" === t && e ? 300 - r : "maybePrepare" === t && e ? 400 - r : 500 : 200 - r : 100 - r;
                }(e);if (0 === n) {
                    N();try {
                        t();
                    } finally {}return { cancel: () => {} };
                }return this.tasks[r] = { fn: t, metadata: e, priority: n, id: r }, this.taskQueue.push(r), this.invoker.trigger(), { cancel: () => {
                        delete this.tasks[r];
                    } };
            }process() {
                N();try {
                    if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;const t = this.pick();if (null === t) return;const e = this.tasks[t];if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;e.fn();
                } finally {}
            }pick() {
                let t = null,
                    e = 1 / 0;for (let r = 0; r < this.taskQueue.length; r++) {
                    const n = this.tasks[this.taskQueue[r]];n.priority < e && (e = n.priority, t = r);
                }if (null === t) return null;const r = this.taskQueue[t];return this.taskQueue.splice(t, 1), r;
            }remove() {
                this.invoker.remove();
            }
        }class kd {
            constructor(t) {
                this._stringToNumber = {}, this._numberToString = [];for (let e = 0; e < t.length; e++) {
                    const r = t[e];this._stringToNumber[r] = e, this._numberToString[e] = r;
                }
            }encode(t) {
                return this._stringToNumber[t];
            }decode(t) {
                return this._numberToString[t];
            }
        }const Id = ["tile", "layer", "source", "sourceLayer", "state"];class Md {
            constructor(t, e, r, n, i) {
                this.type = "Feature", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;
            }get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }set geometry(t) {
                this._geometry = t;
            }toJSON() {
                const t = { type: "Feature", geometry: this.geometry, properties: this.properties };void 0 !== this.id && (t.id = this.id);for (const e of Id) void 0 !== this[e] && (t[e] = this[e]);return t;
            }
        }const Td = 32,
              zd = 33,
              Bd = new Uint16Array(8184);for (let t = 0; t < 2046; t++) {
            let e = t + 2,
                r = 0,
                n = 0,
                i = 0,
                s = 0,
                a = 0,
                o = 0;for (1 & e ? i = s = a = Td : r = n = o = Td; (e >>= 1) > 1;) {
                const t = r + i >> 1,
                      l = n + s >> 1;1 & e ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t, o = l;
            }const l = 4 * t;Bd[l + 0] = r, Bd[l + 1] = n, Bd[l + 2] = i, Bd[l + 3] = s;
        }const Ed = new Uint16Array(2178),
              Cd = new Uint8Array(1089),
              Pd = new Uint16Array(1089);function Dd(t) {
            return 0 === t ? -.03125 : 32 === t ? .03125 : 0;
        }var Vd = na([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);const Ld = { type: 2, extent: ko, loadGeometry: () => [[new d(0, 0), new d(8193, 0), new d(8193, 8193), new d(0, 8193), new d(0, 0)]] };class Fd {
            constructor(t, e, r, n, i) {
                this.tileID = t, this.uid = E(), this.uses = 0, this.tileSize = e, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = "loading", n && n.transform && (this.projection = n.transform.projection);
            }registerFadeDuration(t) {
                const e = t + this.timeAdded;e < Nt.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);
            }wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }get tileTransform() {
                return this._tileTransform || (this._tileTransform = Vf(this.tileID.canonical, this.projection)), this._tileTransform;
            }loadVectorData(t, e, r) {
                if (this.unloadVectorData(), this.state = "loaded", t) {
                    t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {
                        const r = {};if (!e) return r;for (const n of t) {
                            const t = n.layerIds.map(t => e.getLayer(t)).filter(Boolean);if (0 !== t.length) {
                                n.layers = t, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map(e => t.filter(t => t.id === e)[0]));for (const e of t) r[e.id] = n;
                            }
                        }return r;
                    }(t.buckets, e.style), this.hasSymbolBuckets = !1;for (const t in this.buckets) {
                        const e = this.buckets[t];if (e instanceof hd) {
                            if (this.hasSymbolBuckets = !0, !r) break;e.justReloaded = !0;
                        }
                    }if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {
                        const e = this.buckets[t];if (e instanceof hd && e.hasRTLText) {
                            this.hasRTLText = !0, js.isLoading() || js.isLoaded() || "deferred" !== Fs() || Rs();break;
                        }
                    }this.queryPadding = 0;for (const t in this.buckets) {
                        const r = this.buckets[t];this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(r));
                    }t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas);
                } else this.collisionBoxArray = new Ea();
            }unloadVectorData() {
                if (this.hasData()) {
                    for (const t in this.buckets) this.buckets[t].destroy();this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }getBucket(t) {
                return this.buckets[t.id];
            }upload(t) {
                for (const e in this.buckets) {
                    const r = this.buckets[e];r.uploadPending() && r.upload(t);
                }const e = t.gl;this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _d(t, this.imageAtlas.image, e.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new _d(t, this.glyphAtlasImage, e.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new _d(t, this.lineAtlas.image, e.ALPHA), this.lineAtlas.uploaded = !0);
            }prepare(t) {
                this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
            }queryRenderedFeatures(t, e, r, n, i, s, a, o) {
                return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n, pixelPosMatrix: a, transform: s, params: i, tileTransform: this.tileTransform }, t, e, r) : {};
            }querySourceFeatures(t, e) {
                const r = this.latestFeatureIndex;if (!r || !r.rawTileData) return;const n = r.loadVTLayers(),
                      i = e ? e.sourceLayer : "",
                      s = n._geojsonTileLayer || n[i];if (!s) return;const a = ai(e && e.filter),
                      { z: o, x: l, y: u } = this.tileID.canonical,
                      c = { z: o, x: l, y: u };for (let e = 0; e < s.length; e++) {
                    const n = s.feature(e);if (a.needGeometry) {
                        const t = wu(n, !0);if (!a.filter(new Us(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;
                    } else if (!a.filter(new Us(this.tileID.overscaledZ), n)) continue;const h = r.getId(n, i),
                          p = new Md(n, o, l, u, h);p.tile = c, t.push(p);
                }
            }hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }setExpiryData(t) {
                const e = this.expirationTime;if (t.cacheControl) {
                    const e = G(t.cacheControl);e["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"]);
                } else t.expires && (this.expirationTime = new Date(t.expires).getTime());if (this.expirationTime) {
                    const t = Date.now();let r = !1;if (this.expirationTime > t) r = !1;else if (e) {
                        if (this.expirationTime < e) r = !0;else {
                            const n = this.expirationTime - e;n ? this.expirationTime = t + Math.max(n, 3e4) : r = !0;
                        }
                    } else r = !0;r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
            }setFeatureState(t, e) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e) return;const r = this.latestFeatureIndex.loadVTLayers(),
                      n = e.style.listImages();for (const i in this.buckets) {
                    if (!e.style.hasLayer(i)) continue;const s = this.buckets[i],
                          a = s.layers[0].sourceLayer || "_geojsonTileLayer",
                          o = r[a],
                          l = t[a];if (!o || !l || 0 === Object.keys(l).length) continue;if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), s instanceof jh || s instanceof Uc) {
                        const t = e.style._getSourceCache(s.layers[0].source);e._terrain && e._terrain.enabled && t && s.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID);
                    }const u = e && e.style && e.style.getLayer(i);u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));
                }
            }holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nt.now();
            }clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }setHoldDuration(t) {
                this.symbolFadeHoldUntil = Nt.now() + t;
            }setTexture(t, e) {
                const r = e.context,
                      n = r.gl;this.texture = this.texture || e.getTileTexture(t.width), this.texture ? this.texture.update(t, { useMipmap: !0 }) : (this.texture = new _d(r, t, n.RGBA, { useMipmap: !0 }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r.extTextureFilterAnisotropicMax));
            }setDependencies(t, e) {
                const r = {};for (const t of e) r[t] = !0;this.dependencies[t] = r;
            }hasDependency(t, e) {
                for (const r of t) {
                    const t = this.dependencies[r];if (t) for (const r of e) if (t[r]) return !0;
                }return !1;
            }clearQueryDebugViz() {}_makeDebugTileBoundsBuffers(t, e) {
                if (!e || "mercator" === e.name || this._tileDebugBuffer) return;const r = bu(Ld, this.tileID.canonical, this.tileTransform)[0],
                      n = new sa(),
                      i = new Ta();for (let t = 0; t < r.length; t++) {
                    const { x: e, y: s } = r[t];n.emplaceBack(e, s), i.emplaceBack(t);
                }i.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(i), this._tileDebugBuffer = t.createVertexBuffer(n, xl.members), this._tileDebugSegments = So.simpleSegment(0, 0, n.length, i.length);
            }_makeTileBoundsBuffers(t, e) {
                if (this._tileBoundsBuffer || !e || "mercator" === e.name) return;const r = bu(Ld, this.tileID.canonical, this.tileTransform)[0];let n, i;if (this.isRaster) {
                    const t = function (t, e) {
                        const r = Vf(t, e),
                              n = Math.pow(2, t.z);for (let i = 0; i < zd; i++) for (let s = 0; s < zd; s++) {
                            const a = ou((t.x + (s + Dd(s)) / Td) / n),
                                  o = lu((t.y + (i + Dd(i)) / Td) / n),
                                  l = e.project(a, o),
                                  u = i * zd + s;Ed[2 * u + 0] = Math.round((l.x * r.scale - r.x) * ko), Ed[2 * u + 1] = Math.round((l.y * r.scale - r.y) * ko);
                        }Cd.fill(0), Pd.fill(0);for (let t = 2045; t >= 0; t--) {
                            const e = 4 * t,
                                  r = Bd[e + 0],
                                  n = Bd[e + 1],
                                  i = Bd[e + 2],
                                  s = Bd[e + 3],
                                  a = r + i >> 1,
                                  o = n + s >> 1,
                                  l = a + o - n,
                                  u = o + r - a,
                                  c = n * zd + r,
                                  h = s * zd + i,
                                  p = o * zd + a,
                                  f = Math.hypot((Ed[2 * c + 0] + Ed[2 * h + 0]) / 2 - Ed[2 * p + 0], (Ed[2 * c + 1] + Ed[2 * h + 1]) / 2 - Ed[2 * p + 1]) >= 16;if (Cd[p] = Cd[p] || (f ? 1 : 0), t < 1022) {
                                const t = (n + u >> 1) * zd + (r + l >> 1),
                                      e = (s + u >> 1) * zd + (i + l >> 1);Cd[p] = Cd[p] || Cd[t] || Cd[e];
                            }
                        }const i = new oa(),
                              s = new wa();let a = 0;function o(t, e) {
                            const r = e * zd + t;return 0 === Pd[r] && (i.emplaceBack(Ed[2 * r + 0], Ed[2 * r + 1], t * ko / Td, e * ko / Td), Pd[r] = ++a), Pd[r] - 1;
                        }function l(t, e, r, n, i, a) {
                            const u = t + r >> 1,
                                  c = e + n >> 1;if (Math.abs(t - i) + Math.abs(e - a) > 1 && Cd[c * zd + u]) l(i, a, t, e, u, c), l(r, n, i, a, u, c);else {
                                const l = o(t, e),
                                      u = o(r, n),
                                      c = o(i, a);s.emplaceBack(l, u, c);
                            }
                        }return l(0, 0, Td, Td, Td, 0), l(Td, Td, 0, 0, 0, Td), { vertices: i, indices: s };
                    }(this.tileID.canonical, e);n = t.vertices, i = t.indices;
                } else {
                    n = new oa(), i = new wa();for (const { x: t, y: e } of r) n.emplaceBack(t, e, 0, 0);const t = sc(n.int16, void 0, 4);for (let e = 0; e < t.length; e += 3) i.emplaceBack(t[e], t[e + 1], t[e + 2]);
                }this._tileBoundsBuffer = t.createVertexBuffer(n, Vd.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(i), this._tileBoundsSegments = So.simpleSegment(0, 0, n.length, i.length);
            }_makeGlobeTileDebugBuffers(t, e) {
                const r = e.projection;if (!r || "globe" !== r.name || e.freezeTileCoverage) return;const n = this.tileID.canonical,
                      i = Gl(Vl(n, e)),
                      s = Kl(e.zoom);let a;s > 0 && (a = Co(new Float64Array(16), e.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, n, e, i, a, s), this._makeGlobeTileDebugTextBuffer(t, n, e, i, a, s);
            }_globePoint(t, e, r, n, i, s, a) {
                let o = Ol(t, e, r);if (s) {
                    const i = 1 << r.z,
                          l = iu(n.center.lng),
                          u = su(n.center.lat),
                          c = (r.x + .5) / i - l;let h = 0;c > .5 ? h = -1 : c < -.5 && (h = 1);let p = (t / ko + r.x) / i + h,
                        f = (e / ko + r.y) / i;p = (p - l) * n._pixelsPerMercatorPixel + l, f = (f - u) * n._pixelsPerMercatorPixel + u;const d = [p * n.worldSize, f * n.worldSize, 0];el(d, d, s), o = Dl(o, d, a);
                }return el(o, o, i);
            }_makeGlobeTileDebugBorderBuffer(t, e, r, n, i, s) {
                const a = new sa(),
                      o = new Ta(),
                      l = new aa(),
                      u = (t, u, c, h, p) => {
                    const f = (c - t) / (p - 1),
                          d = (h - u) / (p - 1),
                          y = a.length;for (let c = 0; c < p; c++) {
                        const h = t + c * f,
                              p = u + c * d;a.emplaceBack(h, p);const m = this._globePoint(h, p, e, r, n, i, s);l.emplaceBack(m[0], m[1], m[2]), o.emplaceBack(y + c);
                    }
                },
                      c = ko;u(0, 0, c, 0, 16), u(c, 0, c, c, 16), u(c, c, 0, c, 16), u(0, c, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(o), this._tileDebugBuffer = t.createVertexBuffer(a, xl.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(l, gl.members), this._tileDebugSegments = So.simpleSegment(0, 0, a.length, o.length);
            }_makeGlobeTileDebugTextBuffer(t, e, r, n, i, s) {
                const a = new sa(),
                      o = new wa(),
                      l = new aa(),
                      u = 25;o.reserve(32), a.reserve(u), l.reserve(u);const c = (t, e) => u * t + e;for (let t = 0; t < u; t++) {
                    const o = 2048 * t;for (let t = 0; t < u; t++) {
                        const u = 2048 * t;a.emplaceBack(u, o);const c = this._globePoint(u, o, e, r, n, i, s);l.emplaceBack(c[0], c[1], c[2]);
                    }
                }for (let t = 0; t < 4; t++) for (let e = 0; e < 4; e++) {
                    const r = c(t, e),
                          n = c(t, e + 1),
                          i = c(t + 1, e),
                          s = c(t + 1, e + 1);o.emplaceBack(r, n, i), o.emplaceBack(i, n, s);
                }this._tileDebugTextIndexBuffer = t.createIndexBuffer(o), this._tileDebugTextBuffer = t.createVertexBuffer(a, xl.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(l, gl.members), this._tileDebugTextSegments = So.simpleSegment(0, 0, u, 32);
            }
        }class Rd {
            constructor() {
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }updateState(t, e, r) {
                const n = String(e);if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, z(this.stateChanges[t][n], r), null === this.deletedStates[t]) {
                    this.deletedStates[t] = {};for (const e in this.state[t]) e !== n && (this.deletedStates[t][e] = null);
                } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) {
                    this.deletedStates[t][n] = {};for (const e in this.state[t][n]) r[e] || (this.deletedStates[t][n][e] = null);
                } else for (const e in r) this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][e] && delete this.deletedStates[t][n][e];
            }removeFeatureState(t, e, r) {
                if (null === this.deletedStates[t]) return;const n = String(e);if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {
                    if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) this.deletedStates[t][n][r] = null;else this.deletedStates[t][n] = null;
                } else this.deletedStates[t] = null;
            }getState(t, e) {
                const r = String(e),
                      n = z({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);if (null === this.deletedStates[t]) return {};if (this.deletedStates[t]) {
                    const r = this.deletedStates[t][e];if (null === r) return {};for (const t in r) delete n[t];
                }return n;
            }initializeTileState(t, e) {
                t.setFeatureState(this.state, e);
            }coalesceChanges(t, e) {
                const r = {};for (const t in this.stateChanges) {
                    this.state[t] = this.state[t] || {};const e = {};for (const r in this.stateChanges[t]) this.state[t][r] || (this.state[t][r] = {}), z(this.state[t][r], this.stateChanges[t][r]), e[r] = this.state[t][r];r[t] = e;
                }for (const t in this.deletedStates) {
                    this.state[t] = this.state[t] || {};const e = {};if (null === this.deletedStates[t]) for (const r in this.state[t]) e[r] = {}, this.state[t][r] = {};else for (const r in this.deletedStates[t]) {
                        if (null === this.deletedStates[t][r]) this.state[t][r] = {};else if (this.state[t][r]) for (const e of Object.keys(this.deletedStates[t][r])) delete this.state[t][r][e];e[r] = this.state[t][r];
                    }r[t] = r[t] || {}, z(r[t], e);
                }if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const n in t) t[n].setFeatureState(r, e);
            }
        }class jd {
            constructor(t) {
                this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];
            }getElevation(t, e) {
                const r = this.toIdx(t, e);return { min: this.minimums[r], max: this.maximums[r] };
            }isLeaf(t, e) {
                return this.leaves[this.toIdx(t, e)];
            }toIdx(t, e) {
                return e * this.size + t;
            }
        }function Ud(t, e, r, n) {
            let i = 0,
                s = Number.MAX_VALUE;for (let a = 0; a < 3; a++) if (Math.abs(n[a]) < 1e-15) {
                if (r[a] < t[a] || r[a] > e[a]) return null;
            } else {
                const o = 1 / n[a];let l = (t[a] - r[a]) * o,
                    u = (e[a] - r[a]) * o;if (l > u) {
                    const t = l;l = u, u = t;
                }if (l > i && (i = l), u < s && (s = u), i > s) return null;
            }return i;
        }function $d(t, e, r, n, i, s, a, o, l, u, c) {
            const h = n - t,
                  p = i - e,
                  f = s - r,
                  d = a - t,
                  y = o - e,
                  m = l - r,
                  g = c[1] * m - c[2] * y,
                  x = c[2] * d - c[0] * m,
                  v = c[0] * y - c[1] * d,
                  b = h * g + p * x + f * v;if (Math.abs(b) < 1e-15) return null;const w = 1 / b,
                  _ = u[0] - t,
                  A = u[1] - e,
                  S = u[2] - r,
                  k = (_ * g + A * x + S * v) * w;if (k < 0 || k > 1) return null;const I = A * f - S * p,
                  M = S * h - _ * f,
                  T = _ * p - A * h,
                  z = (c[0] * I + c[1] * M + c[2] * T) * w;return z < 0 || k + z > 1 ? null : (d * I + y * M + m * T) * w;
        }function Od(t, e, r) {
            return (t - e) / (r - e);
        }function qd(t, e, r, n, i, s, a, o, l) {
            const u = 1 << r,
                  c = s - n,
                  h = a - i,
                  p = (t + 1) / u * c + n,
                  f = (e + 0) / u * h + i,
                  d = (e + 1) / u * h + i;o[0] = (t + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;
        }class Nd {
            constructor(t) {
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;const e = function (t) {
                    const e = Math.ceil(Math.log2(t.dim / 8)),
                          r = [];let n = Math.ceil(Math.pow(2, e));const i = 1 / n,
                          s = (t, e, r, n, i) => {
                        const s = n ? 1 : 0,
                              a = (t + 1) * r - s,
                              o = e * r,
                              l = (e + 1) * r - s;i[0] = t * r, i[1] = o, i[2] = a, i[3] = l;
                    };let a = new jd(n);const o = [];for (let e = 0; e < n * n; e++) {
                        s(e % n, Math.floor(e / n), i, !1, o);const r = Xd(o[0], o[1], t),
                              l = Xd(o[2], o[1], t),
                              u = Xd(o[2], o[3], t),
                              c = Xd(o[0], o[3], t);a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);
                    }for (r.push(a), n /= 2; n >= 1; n /= 2) {
                        const t = r[r.length - 1];a = new jd(n);for (let e = 0; e < n * n; e++) {
                            s(e % n, Math.floor(e / n), 2, !0, o);const r = t.getElevation(o[0], o[1]),
                                  i = t.getElevation(o[2], o[1]),
                                  l = t.getElevation(o[2], o[3]),
                                  u = t.getElevation(o[0], o[3]),
                                  c = t.isLeaf(o[0], o[1]),
                                  h = t.isLeaf(o[2], o[1]),
                                  p = t.isLeaf(o[2], o[3]),
                                  f = t.isLeaf(o[0], o[3]),
                                  d = Math.min(r.min, i.min, l.min, u.min),
                                  y = Math.max(r.max, i.max, l.max, u.max),
                                  m = c && h && p && f;a.maximums.push(y), a.minimums.push(d), a.leaves.push(y - d <= 5 && m ? 1 : 0);
                        }r.push(a);
                    }return r;
                }(this.dem),
                      r = e.length - 1,
                      n = e[r];this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);
            }raycastRoot(t, e, r, n, i, s, a = 1) {
                return Ud([t, e, -100], [r, n, this.maximums[0] * a], i, s);
            }raycast(t, e, r, n, i, s, a = 1) {
                if (!this.nodeCount) return null;const o = this.raycastRoot(t, e, r, n, i, s, a);if (null == o) return null;const l = [],
                      u = [],
                      c = [],
                      h = [],
                      p = [{ idx: 0, t: o, nodex: 0, nodey: 0, depth: 0 }];for (; p.length > 0;) {
                    const { idx: o, t: f, nodex: d, nodey: y, depth: m } = p.pop();if (this.leaves[o]) {
                        qd(d, y, m, t, e, r, n, c, h);const o = 1 << m,
                              l = (d + 0) / o,
                              u = (d + 1) / o,
                              p = (y + 0) / o,
                              g = (y + 1) / o,
                              x = Xd(l, p, this.dem) * a,
                              v = Xd(u, p, this.dem) * a,
                              b = Xd(u, g, this.dem) * a,
                              w = Xd(l, g, this.dem) * a,
                              _ = $d(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),
                              A = $d(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s),
                              S = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);if (S !== Number.MAX_VALUE) return S;{
                            const t = Wo([], i, s, f);if (Gd(x, v, w, b, Od(t[0], c[0], h[0]), Od(t[1], c[1], h[1])) >= t[2]) return f;
                        }continue;
                    }let g = 0;for (let p = 0; p < this._siblingOffset.length; p++) {
                        qd((d << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;const f = Ud(c, h, i, s);if (null != f) {
                            const t = f;l[p] = t;let e = !1;for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);e || (u[g] = p), g++;
                        }
                    }for (let t = 0; t < g; t++) {
                        const e = u[t];p.push({ idx: this.childOffsets[o] + e, t: l[e], nodex: (d << 1) + this._siblingOffset[e][0], nodey: (y << 1) + this._siblingOffset[e][1], depth: m + 1 });
                    }
                }return null;
            }_addNode(t, e, r) {
                return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }_construct(t, e, r, n, i) {
                if (1 === t[n].isLeaf(e, r)) return;this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);const s = n - 1,
                      a = t[s];let o = 0,
                    l = 0;for (let t = 0; t < this._siblingOffset.length; t++) {
                    const n = 2 * e + this._siblingOffset[t][0],
                          i = 2 * r + this._siblingOffset[t][1],
                          s = a.getElevation(n, i),
                          u = a.isLeaf(n, i),
                          c = this._addNode(s.min, s.max, u);u && (o |= 1 << t), l || (l = c);
                }for (let n = 0; n < this._siblingOffset.length; n++) o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
            }
        }function Gd(t, e, r, n, i, s) {
            return Mr(Mr(t, r, s), Mr(e, n, s), i);
        }function Xd(t, e, r) {
            const n = r.dim,
                  i = S(t * n - .5, 0, n - 1),
                  s = S(e * n - .5, 0, n - 1),
                  a = Math.floor(i),
                  o = Math.floor(s),
                  l = Math.min(a + 1, n - 1),
                  u = Math.min(o + 1, n - 1);return Gd(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);
        }const Zd = { mapbox: [6553.6, 25.6, .1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };class Kd {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }constructor(t, e, r, n = !1, i = !1) {
                if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square");if (r && "mapbox" !== r && "terrarium" !== r) return $(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);this.stride = e.height;const s = this.dim = e.height - 2,
                      a = new Uint32Array(e.data.buffer);if (this.pixels = new Uint8Array(e.data.buffer), this.encoding = r || "mapbox", this.borderReady = n, !n) {
                    for (let t = 0; t < s; t++) a[this._idx(-1, t)] = a[this._idx(0, t)], a[this._idx(s, t)] = a[this._idx(s - 1, t)], a[this._idx(t, -1)] = a[this._idx(t, 0)], a[this._idx(t, s)] = a[this._idx(t, s - 1)];a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(s, -1)] = a[this._idx(s - 1, 0)], a[this._idx(-1, s)] = a[this._idx(0, s - 1)], a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)], i && this._buildQuadTree();
                }
            }_buildQuadTree() {
                this._tree = new Nd(this);
            }get(t, e, r = !1) {
                r && (t = S(t, -1, this.dim), e = S(e, -1, this.dim));const n = 4 * this._idx(t, e);return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]);
            }static getUnpackVector(t) {
                return Zd[t];
            }get unpackVector() {
                return Zd[this.encoding];
            }_idx(t, e) {
                if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");return (e + 1) * this.stride + (t + 1);
            }_unpackMapbox(t, e, r) {
                return (256 * t * 256 + 256 * e + r) / 10 - 1e4;
            }_unpackTerrarium(t, e, r) {
                return 256 * t + e + r / 256 - 32768;
            }static pack(t, e) {
                const r = [0, 0, 0, 0],
                      n = Kd.getUnpackVector(e);let i = Math.floor((t + n[3]) / n[2]);return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
            }getPixels() {
                return new Qu({ width: this.stride, height: this.stride }, this.pixels);
            }backfillBorder(t, e, r) {
                if (this.dim !== t.dim) throw new Error("dem dimension mismatch");let n = e * this.dim,
                    i = e * this.dim + this.dim,
                    s = r * this.dim,
                    a = r * this.dim + this.dim;switch (e) {case -1:
                        n = i - 1;break;case 1:
                        i = n + 1;}switch (r) {case -1:
                        s = a - 1;break;case 1:
                        a = s + 1;}const o = -e * this.dim,
                      l = -r * this.dim;for (let e = s; e < a; e++) for (let r = n; r < i; r++) {
                    const n = 4 * this._idx(r, e),
                          i = 4 * this._idx(r + o, e + l);this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];
                }
            }onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }Oi(Kd, "DEMData"), Oi(Nd, "DemMinMaxQuadTree", { omit: ["dem"] });class Yd {
            constructor(t, e) {
                this.max = t, this.onRemove = e, this.reset();
            }reset() {
                for (const t in this.data) for (const e of this.data[t]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);return this.data = {}, this.order = [], this;
            }add(t, e, r) {
                const n = t.wrapped().key;void 0 === this.data[n] && (this.data[n] = []);const i = { value: e, timeout: void 0 };if (void 0 !== r && (i.timeout = setTimeout(() => {
                    this.remove(t, i);
                }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {
                    const t = this._getAndRemoveByKey(this.order[0]);t && this.onRemove(t);
                }return this;
            }has(t) {
                return t.wrapped().key in this.data;
            }getAndRemove(t) {
                return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
            }_getAndRemoveByKey(t) {
                const e = this.data[t].shift();return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;
            }getByKey(t) {
                const e = this.data[t];return e ? e[0].value : null;
            }get(t) {
                return this.has(t) ? this.data[t.wrapped().key][0].value : null;
            }remove(t, e) {
                if (!this.has(t)) return this;const r = t.wrapped().key,
                      n = void 0 === e ? 0 : this.data[r].indexOf(e),
                      i = this.data[r][n];return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;
            }setMaxSize(t) {
                for (this.max = t; this.order.length > this.max;) {
                    const t = this._getAndRemoveByKey(this.order[0]);t && this.onRemove(t);
                }return this;
            }filter(t) {
                const e = [];for (const r in this.data) for (const n of this.data[r]) t(n.value) || e.push(n);for (const t of e) this.remove(t.value.tileID, t);
            }
        }class Hd {
            constructor(t, e, r) {
                this.func = t, this.mask = e, this.range = r;
            }
        }Hd.ReadOnly = !1, Hd.ReadWrite = !0, Hd.disabled = new Hd(519, Hd.ReadOnly, [0, 1]);const Wd = 7680;class Jd {
            constructor(t, e, r, n, i, s) {
                this.test = t, this.ref = e, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;
            }
        }Jd.disabled = new Jd({ func: 519, mask: 0 }, 0, 0, Wd, Wd, Wd);class Qd {
            constructor(t, e, r) {
                this.blendFunction = t, this.blendColor = e, this.mask = r;
            }
        }Qd.Replace = [1, 0], Qd.disabled = new Qd(Qd.Replace, Me.transparent, [!1, !1, !1, !1]), Qd.unblended = new Qd(Qd.Replace, Me.transparent, [!0, !0, !0, !0]), Qd.alphaBlended = new Qd([1, 771], Me.transparent, [!0, !0, !0, !0]);const ty = 1029,
              ey = 2305;class ry {
            constructor(t, e, r) {
                this.enable = t, this.mode = e, this.frontFace = r;
            }
        }ry.disabled = new ry(!1, ty, ey), ry.backCCW = new ry(!0, ty, ey), ry.backCW = new ry(!0, ty, 2304), ry.frontCW = new ry(!0, 1028, 2304), ry.frontCCW = new ry(!0, 1028, ey);class ny extends Yt {
            constructor(t, e, r) {
                super(), this.id = t, this._onlySymbols = r, e.on("data", t => {
                    "source" === t.dataType && "metadata" === t.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t.dataType && "content" === t.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), e.on("error", () => {
                    this._sourceErrored = !0;
                }), this._source = e, this._tiles = {}, this._cache = new Yd(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e.minTileCacheSize, this._maxTileCacheSize = e.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Rd(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }onAdd(t) {
                this.map = t, this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize;
            }loaded() {
                if (this._sourceErrored) return !0;if (!this._sourceLoaded) return !1;if (!this._source.loaded()) return !1;for (const t in this._tiles) {
                    const e = this._tiles[t];if ("loaded" !== e.state && "errored" !== e.state) return !1;
                }return !0;
            }getSource() {
                return this._source;
            }pause() {
                this._paused = !0;
            }resume() {
                if (!this._paused) return;const t = this._shouldReloadOnResume;this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);
            }_loadTile(t, e) {
                return t.isSymbolTile = this._onlySymbols, this._source.loadTile(t, e);
            }_unloadTile(t) {
                if (this._source.unloadTile) return this._source.unloadTile(t, () => {});
            }_abortTile(t) {
                if (this._source.abortTile) return this._source.abortTile(t, () => {});
            }serialize() {
                return this._source.serialize();
            }prepare(t) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);for (const e in this._tiles) {
                    const r = this._tiles[e];r.upload(t), r.prepare(this.map.style.imageManager);
                }
            }getIds() {
                return T(this._tiles).map(t => t.tileID).sort(iy).map(t => t.key);
            }getRenderableIds(t) {
                const e = [];for (const r in this._tiles) this._isIdRenderable(+r, t) && e.push(this._tiles[r]);return t ? e.sort((t, e) => {
                    const r = t.tileID,
                          n = e.tileID,
                          i = new d(r.canonical.x, r.canonical.y)._rotate(this.transform.angle),
                          s = new d(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);return r.overscaledZ - n.overscaledZ || s.y - i.y || s.x - i.x;
                }).map(t => t.tileID.key) : e.map(t => t.tileID).sort(iy).map(t => t.key);
            }hasRenderableParent(t) {
                const e = this.findLoadedParent(t, 0);return !!e && this._isIdRenderable(e.tileID.key);
            }_isIdRenderable(t, e) {
                return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());
            }reload() {
                if (this._paused) this._shouldReloadOnResume = !0;else {
                    this._cache.reset();for (const t in this._tiles) "errored" !== this._tiles[t].state && this._reloadTile(+t, "reloading");
                }
            }_reloadTile(t, e) {
                const r = this._tiles[t];r && ("loading" !== r.state && (r.state = e), this._loadTile(r, this._tileLoaded.bind(this, r, t, e)));
            }_tileLoaded(t, e, r, n) {
                if (n) {
                    if (t.state = "errored", 404 !== n.status) this._source.fire(new Kt(n, { tile: t }));else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const t = this.map.painter.terrain;this.update(this.transform, t.getScaledDemTileSize(), !0), t.resetTileLookupCache(this.id);
                    } else this.update(this.transform);
                } else t.timeAdded = Nt.now(), "expired" === r && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t), "raster-dem" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new Zt("data", { dataType: "source", tile: t, coord: t.tileID, sourceCacheId: this.id }));
            }_backfillDEM(t) {
                const e = this.getRenderableIds();for (let n = 0; n < e.length; n++) {
                    const i = e[n];if (t.neighboringTiles && t.neighboringTiles[i]) {
                        const e = this.getTileByID(i);r(t, e), r(e, t);
                    }
                }function r(t, e) {
                    if (!t.dem || t.dem.borderReady) return;t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0;let r = e.tileID.canonical.x - t.tileID.canonical.x;const n = e.tileID.canonical.y - t.tileID.canonical.y,
                          i = Math.pow(2, t.tileID.canonical.z),
                          s = e.tileID.key;0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, r, n), t.neighboringTiles && t.neighboringTiles[s] && (t.neighboringTiles[s].backfilled = !0)));
                }
            }getTile(t) {
                return this.getTileByID(t.key);
            }getTileByID(t) {
                return this._tiles[t];
            }_retainLoadedChildren(t, e, r, n) {
                for (const i in this._tiles) {
                    let s = this._tiles[i];if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > r) continue;let a = s.tileID;for (; s && s.tileID.overscaledZ > e + 1;) {
                        const t = s.tileID.scaledTo(s.tileID.overscaledZ - 1);s = this._tiles[t.key], s && s.hasData() && (a = t);
                    }let o = a;for (; o.overscaledZ > e;) if (o = o.scaledTo(o.overscaledZ - 1), t[o.key]) {
                        n[a.key] = a;break;
                    }
                }
            }findLoadedParent(t, e) {
                if (t.key in this._loadedParentTiles) {
                    const r = this._loadedParentTiles[t.key];return r && r.tileID.overscaledZ >= e ? r : null;
                }for (let r = t.overscaledZ - 1; r >= e; r--) {
                    const e = t.scaledTo(r),
                          n = this._getLoadedTile(e);if (n) return n;
                }
            }_getLoadedTile(t) {
                const e = this._tiles[t.key];return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
            }updateCacheSize(t, e) {
                e = e || this._source.tileSize;const r = Math.ceil(t.width / e) + 1,
                      n = Math.ceil(t.height / e) + 1,
                      i = Math.floor(r * n * 5),
                      s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i,
                      a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;this._cache.setMaxSize(a);
            }handleWrapJump(t) {
                const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);if (this._prevLng = t, e) {
                    const t = {};for (const r in this._tiles) {
                        const n = this._tiles[r];n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), t[n.tileID.key] = n;
                    }this._tiles = t;for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];for (const t in this._tiles) this._setTileReloadTimer(+t, this._tiles[t]);
                }
            }update(t, e, r) {
                if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;if (this.usedForTerrain && !r) return;let n;this.updateCacheSize(t, e), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new Mh(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y)) : (n = t.coveringTiles({ tileSize: e || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n = n.filter(t => this._source.hasTile(t)))) : n = [];const i = this._updateRetainedTiles(n);if (sy(this._source.type) && 0 !== n.length) {
                    const t = {},
                          e = {},
                          r = Object.keys(i);for (const n of r) {
                        const r = i[n],
                              s = this._tiles[n];if (!s || s.fadeEndTime && s.fadeEndTime <= Nt.now()) continue;const a = this.findLoadedParent(r, Math.max(r.overscaledZ - ny.maxOverzooming, this._source.minzoom));a && (this._addTile(a.tileID), t[a.tileID.key] = a.tileID), e[n] = r;
                    }const s = n[n.length - 1].overscaledZ;for (const t in this._tiles) {
                        const r = this._tiles[t];if (i[t] || !r.hasData()) continue;let n = r.tileID;for (; n.overscaledZ > s;) {
                            n = n.scaledTo(n.overscaledZ - 1);const s = this._tiles[n.key];if (s && s.hasData() && e[n.key]) {
                                i[t] = r.tileID;break;
                            }
                        }
                    }for (const e in t) i[e] || (this._coveredTiles[e] = !0, i[e] = t[e]);
                }for (const t in i) this._tiles[t].clearFadeHold();const s = function (t, e) {
                    const r = [];for (const n in t) n in e || r.push(n);return r;
                }(this._tiles, i);for (const t of s) {
                    const e = this._tiles[t];e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t);
                }this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }releaseSymbolFadeTiles() {
                for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);
            }_updateRetainedTiles(t) {
                const e = {};if (0 === t.length) return e;const r = {},
                      n = t.reduce((t, e) => Math.min(t, e.overscaledZ), 1 / 0),
                      i = t[0].overscaledZ,
                      s = Math.max(i - ny.maxOverzooming, this._source.minzoom),
                      a = Math.max(i + ny.maxUnderzooming, this._source.minzoom),
                      o = {};for (const r of t) {
                    const t = this._addTile(r);e[r.key] = r, t.hasData() || n < this._source.maxzoom && (o[r.key] = r);
                }this._retainLoadedChildren(o, n, a, e);for (const n of t) {
                    let t = this._tiles[n.key];if (t.hasData()) continue;if (n.canonical.z >= this._source.maxzoom) {
                        const t = n.children(this._source.maxzoom)[0],
                              r = this.getTile(t);if (r && r.hasData()) {
                            e[t.key] = t;continue;
                        }
                    } else {
                        const t = n.children(this._source.maxzoom);if (e[t[0].key] && e[t[1].key] && e[t[2].key] && e[t[3].key]) continue;
                    }let i = t.wasRequested();for (let a = n.overscaledZ - 1; a >= s; --a) {
                        const s = n.scaledTo(a);if (r[s.key]) break;if (r[s.key] = !0, t = this.getTile(s), !t && i && (t = this._addTile(s)), t && (e[s.key] = s, i = t.wasRequested(), t.hasData())) break;
                    }
                }return e;
            }_updateLoadedParentTileCache() {
                this._loadedParentTiles = {};for (const t in this._tiles) {
                    const e = [];let r,
                        n = this._tiles[t].tileID;for (; n.overscaledZ > 0;) {
                        if (n.key in this._loadedParentTiles) {
                            r = this._loadedParentTiles[n.key];break;
                        }e.push(n.key);const t = n.scaledTo(n.overscaledZ - 1);if (r = this._getLoadedTile(t), r) break;n = t;
                    }for (const t of e) this._loadedParentTiles[t] = r;
                }
            }_addTile(t) {
                let e = this._tiles[t.key];if (e) return e;e = this._cache.getAndRemove(t), e && (this._setTileReloadTimer(t.key, e), e.tileID = t, this._state.initializeTileState(e, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, e)));const r = Boolean(e);if (!r) {
                    const r = this.map ? this.map.painter : null;e = new Fd(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state));
                }return e ? (e.uses++, this._tiles[t.key] = e, r || this._source.fire(new Zt("dataloading", { tile: e, coord: e.tileID, dataType: "source" })), e) : null;
            }_setTileReloadTimer(t, e) {
                t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);const r = e.getExpiryTimeout();r && (this._timers[t] = setTimeout(() => {
                    this._reloadTile(t, "expired"), delete this._timers[t];
                }, r));
            }_removeTile(t) {
                const e = this._tiles[t];e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));
            }clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;for (const t in this._tiles) this._removeTile(+t);this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }tilesIn(t, e, r) {
                const n = [],
                      i = this.transform;if (!i) return n;const s = "globe" === i.projection.name,
                      a = iu(i.center.lng);for (const o in this._tiles) {
                    const l = this._tiles[o];if (r && l.clearQueryDebugViz(), l.holdingForFade()) continue;let u;if (s) {
                        const t = l.tileID.canonical;if (0 === t.z) {
                            const e = [Math.abs(S(a, ...ay(t, -1)) - a), Math.abs(S(a, ...ay(t, 1)) - a)];u = [0, 2 * e.indexOf(Math.min(...e)) - 1];
                        } else {
                            const e = [Math.abs(S(a, ...ay(t, -1)) - a), Math.abs(S(a, ...ay(t, 0)) - a), Math.abs(S(a, ...ay(t, 1)) - a)];u = [e.indexOf(Math.min(...e)) - 1];
                        }
                    } else u = [0];for (const r of u) {
                        const s = t.containsTile(l, i, e, r);s && n.push(s);
                    }
                }return n;
            }getVisibleCoordinates(t) {
                const e = this.getRenderableIds(t).map(t => this._tiles[t].tileID);for (const t of e) t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());return e;
            }hasTransition() {
                if (this._source.hasTransition()) return !0;if (sy(this._source.type)) for (const t in this._tiles) {
                    const e = this._tiles[t];if (void 0 !== e.fadeEndTime && e.fadeEndTime >= Nt.now()) return !0;
                }return !1;
            }setFeatureState(t, e, r) {
                this._state.updateState(t = t || "_geojsonTileLayer", e, r);
            }removeFeatureState(t, e, r) {
                this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, r);
            }getFeatureState(t, e) {
                return this._state.getState(t = t || "_geojsonTileLayer", e);
            }setDependencies(t, e, r) {
                const n = this._tiles[t];n && n.setDependencies(e, r);
            }reloadTilesForDependencies(t, e) {
                for (const r in this._tiles) this._tiles[r].hasDependency(t, e) && this._reloadTile(+r, "reloading");this._cache.filter(r => !r.hasDependency(t, e));
            }_preloadTiles(t, e) {
                const r = new Map(),
                      n = Array.isArray(t) ? t : [t],
                      i = this.map.painter.terrain,
                      s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;for (const t of n) {
                    const e = t.coveringTiles({ tileSize: s, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });for (const t of e) r.set(t.key, t);this.usedForTerrain && t.updateElevation(!1);
                }M(Array.from(r.values()), (t, e) => {
                    const r = new Fd(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);this._loadTile(r, t => {
                        "raster-dem" === this._source.type && r.dem && this._backfillDEM(r), e(t, r);
                    });
                }, e);
            }
        }function iy(t, e) {
            const r = Math.abs(2 * t.wrap) - +(t.wrap < 0),
                  n = Math.abs(2 * e.wrap) - +(e.wrap < 0);return t.overscaledZ - e.overscaledZ || n - r || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;
        }function sy(t) {
            return "raster" === t || "image" === t || "video" === t || "custom" === t;
        }function ay(t, e) {
            const r = 1 << t.z;return [t.x / r + e, (t.x + 1) / r + e];
        }ny.maxOverzooming = 10, ny.maxUnderzooming = 3;class oy {
            constructor(t, e, r) {
                this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;
            }static create(t, e, r) {
                const n = r || t.findDEMTileFor(e);if (!n || !n.dem) return;const i = n.dem,
                      s = n.tileID,
                      a = 1 << e.canonical.z - s.canonical.z;return new oy(n, n.tileSize / ko / a, [(e.canonical.x / a - s.canonical.x) * i.dim, (e.canonical.y / a - s.canonical.y) * i.dim]);
            }tileCoordToPixel(t, e) {
                const r = e * this._scale + this._offset[1],
                      n = Math.floor(t * this._scale + this._offset[0]),
                      i = Math.floor(r);return new d(n, i);
            }getElevationAt(t, e, r, n) {
                const i = t * this._scale + this._offset[0],
                      s = e * this._scale + this._offset[1],
                      a = Math.floor(i),
                      o = Math.floor(s),
                      l = this._dem;return n = !!n, r ? Mr(Mr(l.get(a, o, n), l.get(a, o + 1, n), s - o), Mr(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);
            }getElevationAtPixel(t, e, r) {
                return this._dem.get(t, e, !!r);
            }getMeterToDEM(t) {
                return (1 << this._demTile.tileID.canonical.z) * au(1, t) * this._dem.stride;
            }
        }class ly {
            constructor(t, e) {
                this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ji(ko, 16, 0), this.featureIndexArray = new ja(), this.promoteId = e;
            }insert(t, e, r, n, i, s = 0) {
                const a = this.featureIndexArray.length;this.featureIndexArray.emplaceBack(r, n, i, s);const o = this.grid;for (let t = 0; t < e.length; t++) {
                    const r = e[t],
                          n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];for (let t = 0; t < r.length; t++) {
                        const e = r[t];n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);
                    }n[0] < ko && n[1] < ko && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);
                }
            }loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new sh(new op(this.rawTileData)).layers, this.sourceLayerCoder = new kd(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};for (const t in this.vtLayers) this.vtFeatures[t] = [];
                }return this.vtLayers;
            }query(t, e, r, n) {
                this.loadVTLayers();const i = t.params || {},
                      s = ai(i.filter),
                      a = t.tileResult,
                      o = t.transform,
                      l = a.bufferedTilespaceBounds,
                      u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t, e, r, n) => Vu(a.bufferedTilespaceGeometry, t, e, r, n));u.sort(cy);let c = null;o.elevation && u.length > 0 && (c = oy.create(o.elevation, this.tileID));const h = {};let p;for (let o = 0; o < u.length; o++) {
                    const l = u[o];if (l === p) continue;p = l;const f = this.featureIndexArray.get(l);let d = null;this.loadMatchingFeature(h, f, s, i.layers, i.availableImages, e, r, n, (e, r, n, i = 0) => (d || (d = bu(e, this.tileID.canonical, t.tileTransform)), r.queryIntersectsFeature(a, e, n, d, this.z, t.transform, t.pixelPosMatrix, c, i)));
                }return h;
            }loadMatchingFeature(t, e, r, n, i, s, a, o, l) {
                const { featureIndex: u, bucketIndex: c, sourceLayerIndex: h, layoutVertexArrayOffset: p } = e,
                      f = this.bucketLayerIDs[c];if (n && !function (t, e) {
                    for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;return !1;
                }(n, f)) return;const d = this.sourceLayerCoder.decode(h),
                      y = this.vtLayers[d].feature(u);if (r.needGeometry) {
                    const t = wu(y, !0);if (!r.filter(new Us(this.tileID.overscaledZ), t, this.tileID.canonical)) return;
                } else if (!r.filter(new Us(this.tileID.overscaledZ), y)) return;const m = this.getId(y, d);for (let e = 0; e < f.length; e++) {
                    const r = f[e];if (n && n.indexOf(r) < 0) continue;const c = s[r];if (!c) continue;let h = {};void 0 !== m && o && (h = o.getState(c.sourceLayer || "_geojsonTileLayer", m));const d = z({}, a[r]);d.paint = uy(d.paint, c.paint, y, h, i), d.layout = uy(d.layout, c.layout, y, h, i);const g = !l || l(y, c, h, p);if (!g) continue;const x = new Md(y, this.z, this.x, this.y, m);x.layer = d;let v = t[r];void 0 === v && (v = t[r] = []), v.push({ featureIndex: u, feature: x, intersectionZ: g });
                }
            }lookupSymbolFeatures(t, e, r, n, i, s, a, o) {
                const l = {};this.loadVTLayers();const u = ai(i);for (const i of t) this.loadMatchingFeature(l, { bucketIndex: r, sourceLayerIndex: n, featureIndex: i, layoutVertexArrayOffset: 0 }, u, s, a, o, e);return l;
            }loadFeature(t) {
                const { featureIndex: e, sourceLayerIndex: r } = t;this.loadVTLayers();const n = this.sourceLayerCoder.decode(r),
                      i = this.vtFeatures[n];if (i[e]) return i[e];const s = this.vtLayers[n].feature(e);return i[e] = s, s;
            }hasLayer(t) {
                for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;return !1;
            }getId(t, e) {
                let r = t.id;if (this.promoteId) {
                    const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e];null != n && (r = t.properties[n]), "boolean" == typeof r && (r = Number(r));
                }return r;
            }
        }function uy(t, e, r, n, i) {
            return F(t, (t, s) => {
                const a = e instanceof Ks ? e.get(s) : null;return a && a.evaluate ? a.evaluate(r, n, i) : a;
            });
        }function cy(t, e) {
            return e - t;
        }Oi(ly, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });class hy {
            constructor(t, e) {
                this.width = t, this.height = e, this.nextRow = 0, this.image = new Ju({ width: t, height: e }), this.positions = {}, this.uploaded = !1;
            }getDash(t, e) {
                const r = this.getKey(t, e);return this.positions[r];
            }trim() {
                const t = this.width,
                      e = this.height = P(this.nextRow);this.image.resize({ width: t, height: e });
            }getKey(t, e) {
                return t.join(",") + e;
            }getDashRanges(t, e, r) {
                const n = [];let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,
                    s = t[0] * r,
                    a = !0;n.push({ left: i, right: s, isDash: a, zeroLength: 0 === t[0] });let o = t[0];for (let e = 1; e < t.length; e++) {
                    a = !a;const l = t[e];i = o * r, o += l, s = o * r, n.push({ left: i, right: s, isDash: a, zeroLength: 0 === l });
                }return n;
            }addRoundDash(t, e, r) {
                const n = e / 2;for (let e = -r; e <= r; e++) {
                    const i = this.width * (this.nextRow + r + e);let s = 0,
                        a = t[s];for (let o = 0; o < this.width; o++) {
                        o / a.right > 1 && (a = t[++s]);const l = Math.abs(o - a.left),
                              u = Math.abs(o - a.right),
                              c = Math.min(l, u);let h;const p = e / r * (n + 1);if (a.isDash) {
                            const t = n - Math.abs(p);h = Math.sqrt(c * c + t * t);
                        } else h = n - Math.sqrt(c * c + p * p);this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }addRegularDash(t, e) {
                for (let e = t.length - 1; e >= 0; --e) {
                    const r = t[e],
                          n = t[e + 1];r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));
                }const r = t[0],
                      n = t[t.length - 1];r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);const i = this.width * this.nextRow;let s = 0,
                    a = t[s];for (let r = 0; r < this.width; r++) {
                    r / a.right > 1 && (a = t[++s]);const n = Math.abs(r - a.left),
                          o = Math.abs(r - a.right),
                          l = Math.min(n, o);this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));
                }
            }addDash(t, e) {
                const r = this.getKey(t, e);if (this.positions[r]) return this.positions[r];const n = "round" === e,
                      i = n ? 7 : 0,
                      s = 2 * i + 1;if (this.nextRow + s > this.height) return $("LineAtlas out of space"), null;0 === t.length && t.push(1);let a = 0;for (let e = 0; e < t.length; e++) t[e] < 0 && ($("Negative value is found in line dasharray, replacing values with 0"), t[e] = 0), a += t[e];if (0 !== a) {
                    const r = this.width / a,
                          s = this.getDashRanges(t, this.width, r);n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e ? .5 * r : 0);
                }const o = this.nextRow + i;this.nextRow += s;const l = { tl: [o, i], br: [a, 0] };return this.positions[r] = l, l;
            }
        }Oi(hy, "LineAtlas");class py {
            constructor(t) {
                const e = {},
                      r = [];for (const n in t) {
                    const i = t[n],
                          s = e[n] = {};for (const t in i.glyphs) {
                        const e = i.glyphs[+t];if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height) continue;const n = e.metrics.localGlyph ? 2 : 1,
                              a = { x: 0, y: 0, w: e.bitmap.width + 2 * n, h: e.bitmap.height + 2 * n };r.push(a), s[t] = a;
                    }
                }const { w: n, h: i } = Cp(r),
                      s = new Ju({ width: n || 1, height: i || 1 });for (const r in t) {
                    const n = t[r];for (const t in n.glyphs) {
                        const i = n.glyphs[+t];if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;const a = e[r][t],
                              o = i.metrics.localGlyph ? 2 : 1;Ju.copy(i.bitmap, s, { x: 0, y: 0 }, { x: a.x + o, y: a.y + o }, i.bitmap);
                    }
                }this.image = s, this.positions = e;
            }
        }Oi(py, "GlyphAtlas");class fy {
            constructor(t) {
                this.tileID = new Mh(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.enableTerrain = !!t.enableTerrain, this.isSymbolTile = t.isSymbolTile, this.tileTransform = Vf(t.tileID.canonical, t.projection), this.projection = t.projection;
            }parse(t, e, r, n, i) {
                this.status = "parsing", this.data = t, this.collisionBoxArray = new Ea();const s = new kd(Object.keys(t.layers).sort()),
                      a = new ly(this.tileID, this.promoteId);a.bucketLayerIDs = [];const o = {},
                      l = new hy(256, 256),
                      u = { featureIndex: a, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l, availableImages: r },
                      c = e.familiesBySource[this.source];for (const e in c) {
                    const n = t.layers[e];if (!n) continue;let i = !1,
                        l = !1;for (const t of c[e]) "symbol" === t[0].type ? i = !0 : l = !0;if (!0 === this.isSymbolTile && !i) continue;if (!1 === this.isSymbolTile && !l) continue;1 === n.version && $(`Vector tile source "${this.source}" layer "${e}" does not use vector tile spec v2 and therefore may have some rendering errors.`);const h = s.encode(e),
                          p = [];for (let t = 0; t < n.length; t++) {
                        const r = n.feature(t),
                              i = a.getId(r, e);p.push({ feature: r, id: i, index: t, sourceLayerIndex: h });
                    }for (const t of c[e]) {
                        const e = t[0];void 0 !== this.isSymbolTile && "symbol" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || "none" !== e.visibility && (dy(t, this.zoom, r), (o[e.id] = e.createBucket({ index: a.bucketLayerIDs.length, layers: t, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r })).populate(p, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(t.map(t => t.id)));
                    }
                }let h, p, f, d;l.trim();const y = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom },
                      m = F(u.glyphDependencies, t => Object.keys(t).map(Number));Object.keys(m).length ? n.send("getGlyphs", { uid: this.uid, stacks: m }, (t, e) => {
                    h || (h = t, p = e, v.call(this));
                }, void 0, !1, y) : p = {};const g = Object.keys(u.iconDependencies);g.length ? n.send("getImages", { icons: g, source: this.source, tileID: this.tileID, type: "icons" }, (t, e) => {
                    h || (h = t, f = e, v.call(this));
                }, void 0, !1, y) : f = {};const x = Object.keys(u.patternDependencies);function v() {
                    if (h) return i(h);if (p && f && d) {
                        const t = new py(p),
                              e = new Dp(f, d);for (const n in o) {
                            const i = o[n];i instanceof hd ? (dy(i.layers, this.zoom, r), kf(i, p, t.positions, f, e.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof jh || i instanceof Uc || i instanceof fh) && (dy(i.layers, this.zoom, r), i.addFeatures(u, this.tileID.canonical, e.patternPositions, r, this.tileTransform));
                        }this.status = "done", i(null, { buckets: T(o).filter(t => !t.isEmpty()), featureIndex: a, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t.image, lineAtlas: l, imageAtlas: e, glyphMap: this.returnDependencies ? p : null, iconMap: this.returnDependencies ? f : null, glyphPositions: this.returnDependencies ? t.positions : null });
                    }
                }x.length ? n.send("getImages", { icons: x, source: this.source, tileID: this.tileID, type: "patterns" }, (t, e) => {
                    h || (h = t, d = e, v.call(this));
                }, void 0, !1, y) : d = {}, v.call(this);
            }
        }function dy(t, e, r) {
            const n = new Us(e);for (const e of t) e.recalculate(n, r);
        }class yy {
            constructor(t) {
                this.entries = {}, this.scheduler = t;
            }request(t, e, r, n) {
                const i = this.entries[t] = this.entries[t] || { callbacks: [] };if (i.result) {
                    const [t, r] = i.result;return this.scheduler ? this.scheduler.add(() => {
                        n(t, r);
                    }, e) : n(t, r), () => {};
                }return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {
                    i.result = [r, n];for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {
                        t(r, n);
                    }, e) : t(r, n);setTimeout(() => delete this.entries[t], 3e3);
                })), () => {
                    i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));
                };
            }
        }function my(t, e, r) {
            const n = JSON.stringify(t.request);return t.data && (this.deduped.entries[n] = { result: [null, t.data] }), this.deduped.request(n, { type: "parseTile", isSymbolTile: t.isSymbolTile, zoom: t.tileZoom }, e => {
                const n = ut(t.request, (t, n, i, s) => {
                    t ? e(t) : n && e(null, { vectorTile: r ? void 0 : new sh(new op(n)), rawData: n, cacheControl: i, expires: s });
                });return () => {
                    n.cancel(), e();
                };
            }, e);
        }t.ARRAY_TYPE = To, t.AUTH_ERR_MSG = yt, t.Aabb = _l, t.Actor = class {
            constructor(t, r, n) {
                this.target = t, this.parent = r, this.mapId = n, this.callbacks = {}, this.cancelCallbacks = {}, V(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = N() ? t : e, this.scheduler = new Sd();
            }send(t, e, r, n, i = !1, s) {
                const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);r && (r.metadata = s, this.callbacks[a] = r);const o = Z(this.globalScope) ? void 0 : [];return this.target.postMessage({ id: a, type: t, hasCallback: !!r, targetMapId: n, mustQueue: i, sourceMapId: this.mapId, data: Gi(e, o) }, o), { cancel: () => {
                        r && delete this.callbacks[a], this.target.postMessage({ id: a, type: "<cancel>", targetMapId: n, sourceMapId: this.mapId });
                    } };
            }receive(t) {
                const e = t.data,
                      r = e.id;if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {
                    const t = this.cancelCallbacks[r];delete this.cancelCallbacks[r], t && t.cancel();
                } else if (e.mustQueue || N()) {
                    const t = this.callbacks[r];this.cancelCallbacks[r] = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || { type: "message" });
                } else this.processTask(r, e);
            }processTask(t, e) {
                if ("<response>" === e.type) {
                    const r = this.callbacks[t];delete this.callbacks[t], r && (e.error ? r(Xi(e.error)) : r(null, Xi(e.data)));
                } else {
                    const r = Z(this.globalScope) ? void 0 : [],
                          n = e.hasCallback ? (e, n) => {
                        delete this.cancelCallbacks[t], this.target.postMessage({ id: t, type: "<response>", sourceMapId: this.mapId, error: e ? Gi(e) : null, data: Gi(n, r) }, r);
                    } : t => {},
                          i = Xi(e.data);if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {
                        const t = e.type.split(".");this.parent.getWorkerSource(e.sourceMapId, t[0], i.source)[t[1]](i, n);
                    } else n(new Error(`Could not find function ${e.type}`));
                }
            }remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }, t.CanonicalTileID = kh, t.Color = Me, t.ColorMode = Qd, t.CullFaceMode = ry, t.DEMData = Kd, t.DataConstantProperty = Ys, t.DedupedRequest = yy, t.DepthMode = Hd, t.EXTENT = ko, t.Elevation = class {
            isDataAvailableAtPoint(t) {
                const e = this._source();if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1) return !1;const r = e.getSource().maxzoom,
                      n = 1 << r,
                      i = Math.floor(t.x),
                      s = Math.floor((t.x - i) * n),
                      a = Math.floor(t.y * n),
                      o = this.findDEMTileFor(new Mh(r, i, r, s, a));return !(!o || !o.dem);
            }getAtPointOrZero(t, e = 0) {
                return this.getAtPoint(t, e) || 0;
            }getAtPoint(t, e, r = !0) {
                if (this.isUsingMockSource()) return null;null == e && (e = null);const n = this._source();if (!n) return e;if (t.y < 0 || t.y > 1) return e;const i = n.getSource().maxzoom,
                      s = 1 << i,
                      a = Math.floor(t.x),
                      o = t.x - a,
                      l = new Mh(i, a, i, Math.floor(o * s), Math.floor(t.y * s)),
                      u = this.findDEMTileFor(l);if (!u || !u.dem) return e;const c = u.dem,
                      h = 1 << u.tileID.canonical.z,
                      p = (o * h - u.tileID.canonical.x) * c.dim,
                      f = (t.y * h - u.tileID.canonical.y) * c.dim,
                      d = Math.floor(p),
                      y = Math.floor(f);return (r ? this.exaggeration() : 1) * Mr(Mr(c.get(d, y), c.get(d, y + 1), f - y), Mr(c.get(d + 1, y), c.get(d + 1, y + 1), f - y), p - d);
            }getAtTileOffset(t, e, r) {
                const n = 1 << t.canonical.z;return this.getAtPointOrZero(new pu(t.wrap + (t.canonical.x + e / ko) / n, (t.canonical.y + r / ko) / n));
            }getAtTileOffsetFunc(t, e, r, n) {
                return i => {
                    const s = this.getAtTileOffset(t, i.x, i.y),
                          a = n.upVector(t.canonical, i.x, i.y);return Ho(a, a, s * n.upVectorScale(t.canonical, e, r).metersToTile), a;
                };
            }getForTilePoints(t, e, r, n) {
                if (this.isUsingMockSource()) return !1;const i = oy.create(this, t, n);return !!i && (e.forEach(t => {
                    t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);
                }), !0);
            }getMinMaxForTile(t) {
                if (this.isUsingMockSource()) return null;const e = this.findDEMTileFor(t);if (!e || !e.dem) return null;const r = e.dem.tree,
                      n = e.tileID,
                      i = 1 << t.canonical.z - n.canonical.z;let s = t.canonical.x / i - n.canonical.x,
                    a = t.canonical.y / i - n.canonical.y,
                    o = 0;for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {
                    s *= 2, a *= 2;const t = 2 * Math.floor(a) + Math.floor(s);o = r.childOffsets[o] + t, s %= 1, a %= 1;
                }return { min: this.exaggeration() * r.minimums[o], max: this.exaggeration() * r.maximums[o] };
            }getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }raycast(t, e, r) {
                throw new Error("Pure virtual method called.");
            }pointCoordinate(t) {
                throw new Error("Pure virtual method called.");
            }_source() {
                throw new Error("Pure virtual method called.");
            }isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }exaggeration() {
                throw new Error("Pure virtual method called.");
            }findDEMTileFor(t) {
                throw new Error("Pure virtual method called.");
            }get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
        }, t.ErrorEvent = Kt, t.EvaluationParameters = Us, t.Event = Zt, t.Evented = Yt, t.FillExtrusionBucket = fh, t.Frustum = wl, t.FrustumCorners = bl, t.GLOBE_RADIUS = Al, t.GLOBE_SCALE_MATCH_LATITUDE = 45, t.GLOBE_ZOOM_THRESHOLD_MAX = 6, t.GLOBE_ZOOM_THRESHOLD_MIN = 5, t.GlobeSharedBuffers = class {
            constructor(t) {
                this._createGrid(t), this._createPoles(t);
            }destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();for (const t of this._poleSegments) t.destroy();for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();for (const t of this._wireframeSegments) t.destroy();
                }
            }_fillGridMeshWithLods(t, e) {
                const r = new sa(),
                      n = new wa(),
                      i = [],
                      s = t + 1 + 2,
                      a = e[0] + 1,
                      o = e[0] + 1 + (1 + e.length),
                      l = (t, e, r) => {
                    let n = t === s - 1 ? t - 2 : 0 === t ? t : t - 1;return n += r ? 24575 : 0, [n, e];
                };for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, 0, !0));for (let t = 0; t < a; ++t) for (let e = 0; e < s; ++e) r.emplaceBack(...l(e, t, (0 === e || e === s - 1) && !0));for (let t = 0; t < e.length; ++t) {
                    const n = e[t];for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, n, !0));
                }for (let t = 0; t < e.length; ++t) {
                    const a = n.length,
                          l = e[t] + 1 + 2,
                          u = new wa();for (let r = 0; r < l - 1; r++) {
                        const i = r === l - 2,
                              a = i ? s * (o - e.length + t - r) : s;for (let t = 0; t < s - 1; t++) {
                            const e = r * s + t;0 === r || i || 0 === t || t === s - 2 ? (u.emplaceBack(e + 1, e, e + a), u.emplaceBack(e + a, e + a + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + a), n.emplaceBack(e + a, e + a + 1, e + 1));
                        }
                    }const c = So.simpleSegment(0, a, r.length, n.length - a);for (let t = 0; t < u.uint16.length; t += 3) n.emplaceBack(u.uint16[t], u.uint16[t + 1], u.uint16[t + 2]);const h = So.simpleSegment(0, a, r.length, n.length - a);i.push({ withoutSkirts: c, withSkirts: h });
                }return { vertices: r, indices: n, segments: i };
            }_createGrid(t) {
                const e = this._fillGridMeshWithLods(Sl, kl);this._gridSegments = e.segments, this._gridBuffer = t.createVertexBuffer(e.vertices, xl.members), this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0);
            }_createPoles(t) {
                const e = new wa();for (let t = 0; t <= Sl; t++) e.emplaceBack(0, t + 1, t + 2);this._poleIndexBuffer = t.createIndexBuffer(e, !0);const r = new ka(),
                      n = new ka();this._poleSegments = [];for (let t = 0, e = 0; t < 5; t++) {
                    const i = 360 / (1 << t);r.emplaceBack(0, -Al, 0, .5, 0), n.emplaceBack(0, -Al, 0, .5, 1);for (let t = 0; t <= Sl; t++) {
                        const e = t / Sl,
                              s = Mr(0, i, e),
                              [a, o, l] = Ul(Jl, Ql, s, Al);r.emplaceBack(a, o, l, e, 0), n.emplaceBack(a, o, l, e, 1);
                    }this._poleSegments.push(So.simpleSegment(e, 0, 66, 64)), e += 66;
                }this._poleNorthVertexBuffer = t.createVertexBuffer(r, ml, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, ml, !1);
            }getGridBuffers(t, e) {
                return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];
            }getPoleBuffers(t) {
                return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];
            }getWirefameBuffers(t, e) {
                if (!this._wireframeSegments) {
                    const e = new Ma(),
                          r = Sl,
                          n = r + 1 + 2,
                          i = 1;this._wireframeSegments = [];for (let t = 0, s = 0; t < kl.length; t++) {
                        const a = kl[t];for (let t = i; t < a + i; t++) for (let s = i; s < r + i; s++) {
                            const r = t * n + s;e.emplaceBack(r, r + 1), e.emplaceBack(r, r + n), e.emplaceBack(r, r + n + 1);
                        }const o = a * r * 3;this._wireframeSegments.push(So.simpleSegment(0, s, (a + 1) * n, o)), s += o;
                    }this._wireframeIndexBuffer = t.createIndexBuffer(e);
                }return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e]];
            }
        }, t.GlyphManager = cf, t.ImagePosition = Pp, t.LivePerformanceUtils = Lt, t.LngLat = ru, t.LngLatBounds = Io, t.LocalGlyphMode = uf, t.MAX_MERCATOR_LATITUDE = cu, t.MercatorCoordinate = pu, t.ONE_EM = Wh, t.OverscaledTileID = Mh, t.PerformanceMarkers = Vt, t.Properties = Js, t.RGBAImage = Qu, t.Ray = vl, t.RequestManager = class {
            constructor(t, e, r) {
                this._transformRequestFn = t, this._customAccessToken = e, this._silenceAuthErrors = !!r, this._createSkuToken();
            }_createSkuToken() {
                const t = function () {
                    let t = "";for (let e = 0; e < 10; e++) t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];return { token: ["1", h, t].join(""), tokenExpiresAt: Date.now() + 432e5 };
                }();this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
            }_isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }transformRequest(t, e) {
                return this._transformRequestFn && this._transformRequestFn(t, e) || { url: t };
            }normalizeStyleURL(t, e) {
                if (!mt(t)) return t;const r = _t(t);return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
            }normalizeGlyphsURL(t, e) {
                if (!mt(t)) return t;const r = _t(t);return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
            }normalizeSourceURL(t, e, r, n) {
                if (!mt(t)) return t;const i = _t(t);return i.path = `/v4/${i.authority}.json`, i.params.push("secure"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || e);
            }normalizeSpriteURL(t, e, r, n) {
                const i = _t(t);return mt(t) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`, At(i));
            }normalizeTileURL(t, e, r) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t && !mt(t)) return t;const n = _t(t);n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || r && "raster" !== n.authority && 512 === r ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`), "raster" === n.authority ? n.path = `/${i.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = `/${i.TILE_URL_VERSION}${n.path}`);const a = this._customAccessToken || function (t) {
                    for (const e of t) {
                        const t = e.match(/^access_token=(.*)$/);if (t) return t[1];
                    }return null;
                }(n.params) || i.ACCESS_TOKEN;return i.REQUIRE_ACCESS_TOKEN && a && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, a);
            }canonicalizeTileURL(t, e) {
                const r = _t(t);if (!r.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return t;let n = "mapbox://";r.path.match(/^\/raster\/v1\//) ? n += `raster/${r.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${r.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;let s = r.params;return e && (s = s.filter(t => !t.match(/^access_token=/))), s.length && (n += `?${s.join("&")}`), n;
            }canonicalizeTileset(t, e) {
                const r = !!e && mt(e),
                      n = [];for (const e of t.tiles || []) gt(e) ? n.push(this.canonicalizeTileURL(e, r)) : n.push(e);return n;
            }_makeAPIURL(t, e) {
                const r = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",
                      n = _t(i.API_URL);if (t.protocol = n.protocol, t.authority = n.authority, "http" === t.protocol) {
                    const e = t.params.indexOf("secure");e >= 0 && t.params.splice(e, 1);
                }if ("/" !== n.path && (t.path = `${n.path}${t.path}`), !i.REQUIRE_ACCESS_TOKEN) return At(t);if (e = e || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);if ("s" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);
                }return t.params = t.params.filter(t => -1 === t.indexOf("access_token")), t.params.push(`access_token=${e || ""}`), At(t);
            }
        }, t.ResourceType = st, t.SegmentVector = So, t.SourceCache = ny, t.StencilMode = Jd, t.StructArrayLayout1ui2 = Ta, t.StructArrayLayout2f1f2i16 = xa, t.StructArrayLayout2i4 = sa, t.StructArrayLayout2ui4 = Ma, t.StructArrayLayout3f12 = ba, t.StructArrayLayout3ui6 = wa, t.StructArrayLayout4i8 = oa, t.StructArrayLayout5f20 = ka, t.Texture = _d, t.Tile = Fd, t.Transitionable = qs, t.Uniform1f = to, t.Uniform1i = class extends Qa {
            constructor(t) {
                super(t), this.current = 0;
            }set(t, e, r) {
                this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }, t.Uniform2f = class extends Qa {
            constructor(t) {
                super(t), this.current = [0, 0];
            }set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }, t.Uniform3f = class extends Qa {
            constructor(t) {
                super(t), this.current = [0, 0, 0];
            }set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }, t.Uniform4f = eo, t.UniformColor = ro, t.UniformMatrix2f = class extends Qa {
            constructor(t) {
                super(t), this.current = so;
            }set(t, e, r) {
                if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 4; t++) if (r[t] !== this.current[t]) {
                    this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);break;
                }
            }
        }, t.UniformMatrix3f = class extends Qa {
            constructor(t) {
                super(t), this.current = io;
            }set(t, e, r) {
                if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 9; t++) if (r[t] !== this.current[t]) {
                    this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);break;
                }
            }
        }, t.UniformMatrix4f = class extends Qa {
            constructor(t) {
                super(t), this.current = no;
            }set(t, e, r) {
                if (this.fetchUniformLocation(t, e)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);break;
                    }
                }
            }
        }, t.UnwrappedTileID = Ih, t.ValidationError = Wn, t.VectorTileFeature = ah, t.VectorTileWorkerSource = class extends Yt {
            constructor(t, e, r, n, i) {
                super(), this.actor = t, this.layerIndex = e, this.availableImages = r, this.loadVectorData = i || my, this.loading = {}, this.loaded = {}, this.deduped = new yy(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler;
            }loadTile(t, e) {
                const r = t.uid,
                      n = t && t.request,
                      i = n && n.collectResourceTiming,
                      s = this.loading[r] = new fy(t);s.abort = this.loadVectorData(t, (a, o) => {
                    const l = !this.loading[r];if (delete this.loading[r], l || a || !o) return s.status = "done", l || (this.loaded[r] = s), e(a);const u = o.rawData,
                          c = {};o.expires && (c.expires = o.expires), o.cacheControl && (c.cacheControl = o.cacheControl), s.vectorTile = o.vectorTile || new sh(new op(u));const h = () => {
                        s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, (t, r) => {
                            if (t || !r) return e(t);const s = {};if (i) {
                                const t = jt(n);t.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t)));
                            }e(null, z({ rawTileData: u.slice(0) }, r, c, s));
                        });
                    };this.isSpriteLoaded ? h() : this.once("isSpriteLoaded", () => {
                        this.scheduler ? this.scheduler.add(h, { type: "parseTile", isSymbolTile: t.isSymbolTile, zoom: t.tileZoom }) : h();
                    }), this.loaded = this.loaded || {}, this.loaded[r] = s;
                });
            }reloadTile(t, e) {
                const r = this.loaded,
                      n = t.uid,
                      i = this;if (r && r[n]) {
                    const s = r[n];s.showCollisionBoxes = t.showCollisionBoxes, s.enableTerrain = !!t.enableTerrain, s.projection = t.projection, s.tileTransform = Vf(t.tileID.canonical, t.projection);const a = (t, r) => {
                        const n = s.reloadCallback;n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e(t, r);
                    };"parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());
                }
            }abortTile(t, e) {
                const r = t.uid,
                      n = this.loading[r];n && (n.abort && n.abort(), delete this.loading[r]), e();
            }removeTile(t, e) {
                const r = this.loaded,
                      n = t.uid;r && r[n] && delete r[n], e();
            }
        }, t.WritingMode = Vp, t.ZoomDependentExpression = Zn, t.add = Go, t.addDynamicAttributes = od, t.adjoint = function (t, e) {
            var r = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = e[4],
                o = e[5],
                l = e[6],
                u = e[7],
                c = e[8];return t[0] = a * c - o * u, t[1] = i * u - n * c, t[2] = n * o - i * a, t[3] = o * l - s * c, t[4] = r * c - i * l, t[5] = i * s - r * o, t[6] = s * u - a * l, t[7] = n * l - r * u, t[8] = r * a - n * s, t;
        }, t.asyncAll = M, t.bezier = _, t.bindAll = V, t.boundsAttributes = Vd, t.bufferConvexPolygon = function (t, e) {
            const r = [];for (let n = 0; n < t.length; n++) {
                const i = I(n - 1, -1, t.length - 1),
                      s = I(n + 1, -1, t.length - 1),
                      a = t[n],
                      o = t[s],
                      l = t[i].sub(a).unit(),
                      u = o.sub(a).unit(),
                      c = u.angleWithSep(l.x, l.y),
                      h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));r.push(a.add(h));
            }return r;
        }, t.cacheEntryPossiblyAdded = function (t) {
            it++, it > tt && (t.getActor().send("enforceCacheSizeLimit", Q), it = 0);
        }, t.calculateGlobeLabelMatrix = function (t, e) {
            const { x: r, y: n } = t.point,
                  i = Zl(r, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);return Po(i, i, Xl(Pl(e)));
        }, t.calculateGlobeMatrix = function (t) {
            const { x: e, y: r } = t.point,
                  { lng: n, lat: i } = t._center;return Zl(e, r, t.worldSize, n, i);
        }, t.calculateGlobeMercatorMatrix = function (t) {
            const e = t.pixelsPerMeter,
                  r = e / au(1, t.center.lat),
                  n = Eo(new Float64Array(16));return Do(n, n, [t.point.x, t.point.y, 0]), Vo(n, n, [r, r, e]), Float32Array.from(n);
        }, t.circumferenceAtLatitude = nu, t.clamp = S, t.clearTileCache = function (t) {
            if (!et()) return;const r = e.caches.delete(H);t && r.catch(t).then(() => t());
        }, t.clipLine = sf, t.clone = function (t) {
            var e = new To(16);return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
        }, t.clone$1 = j, t.collisionCircleLayout = Hh, t.config = i, t.conjugate = function (t, e) {
            return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
        }, t.create = function () {
            var t = new To(16);return To != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
        }, t.create$1 = zo, t.createExpression = Gn, t.createLayout = na, t.createStyleLayer = function (t) {
            return "custom" === t.type ? new xd(t) : new wd[t.type](t);
        }, t.cross = tl, t.degToRad = x, t.distance = function (t, e) {
            return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2]);
        }, t.div = function (t, e, r) {
            return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;
        }, t.dot = Qo, t.earthRadius = tu, t.ease = A, t.easeCubicInOut = w, t.ecefToLatLng = function ([t, e, r]) {
            const n = Math.hypot(t, e, r),
                  i = Math.atan2(t, r),
                  s = .5 * Math.PI - Math.acos(-e / n);return new ru(v(i), v(s));
        }, t.emitValidationErrors = Ri, t.endsWith = L, t.enforceCacheSizeLimit = function (t) {
            rt(), W && W.then(e => {
                e.keys().then(r => {
                    for (let n = 0; n < r.length - t; n++) e.delete(r[n]);
                });
            });
        }, t.evaluateSizeForFeature = tp, t.evaluateSizeForZoom = ep, t.evaluateVariableOffset = Sf, t.evented = Ls, t.exactEquals = function (t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];
        }, t.exactEquals$1 = function (t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
        }, t.exported = Nt, t.exported$1 = s, t.extend = z, t.extend$1 = Wt, t.fillExtrusionHeightLift = bh, t.filterObject = R, t.fromMat4 = function (t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
        }, t.fromQuat = function (t, e) {
            var r = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                a = r + r,
                o = n + n,
                l = i + i,
                u = r * a,
                c = n * a,
                h = n * o,
                p = i * a,
                f = i * o,
                d = i * l,
                y = s * a,
                m = s * o,
                g = s * l;return t[0] = 1 - h - d, t[1] = c + g, t[2] = p - m, t[3] = 0, t[4] = c - g, t[5] = 1 - u - d, t[6] = f + y, t[7] = 0, t[8] = p + m, t[9] = f - y, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
        }, t.fromRotation = function (t, e) {
            var r = Math.sin(e),
                n = Math.cos(e);return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
        }, t.fromScaling = Ro, t.furthestTileCorner = function (t) {
            const e = Math.round((t + 45 + 360) % 360 / 90) % 4;return b[e];
        }, t.getAABBPointSquareDist = function (t, e, r) {
            let n = 0;for (let i = 0; i < 2; ++i) {
                const s = r ? r[i] : 0;t[i] > s && (n += (t[i] - s) * (t[i] - s)), e[i] < s && (n += (s - e[i]) * (s - e[i]));
            }return n;
        }, t.getAnchorAlignment = Xp, t.getAnchorJustification = If, t.getBounds = function (t) {
            let e = 1 / 0,
                r = 1 / 0,
                n = -1 / 0,
                i = -1 / 0;for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);return { min: new d(e, r), max: new d(n, i) };
        }, t.getColumn = Y, t.getGridMatrix = function (t, e, r, n) {
            const i = e.getNorth(),
                  s = e.getSouth(),
                  a = e.getWest(),
                  o = e.getEast(),
                  l = 1 << t.z,
                  u = o - a,
                  c = i - s,
                  h = u / Sl,
                  p = -c / kl[r],
                  f = [0, h, 0, p, 0, 0, i, a, 0];if (t.z > 0) {
                const t = 180 / n;Bo(f, f, [t / u + 1, 0, 0, 0, t / c + 1, 0, -.5 * t / h, .5 * t / p, 1]);
            }return f[2] = l, f[5] = t.x, f[8] = t.y, f;
        }, t.getImage = dt, t.getJSON = function (t, e) {
            return lt(z(t, { type: "json" }), e);
        }, t.getLatitudinalLod = function (t) {
            const e = cu - 5;t = S(t, -e, e) / e * 90;const r = Math.pow(Math.abs(Math.sin(x(t))), 3);return Math.round(r * (kl.length - 1));
        }, t.getMapSessionAPI = Pt, t.getPerformanceMeasurement = jt, t.getProjection = rd, t.getRTLTextPluginStatus = Fs, t.getReferrer = ot, t.getTilePoint = function (t, { x: e, y: r }, n = 0) {
            return new d(((e - n) * t.scale - t.x) * ko, (r * t.scale - t.y) * ko);
        }, t.getTileVec3 = function (t, e, r = 0) {
            return No(((e.x - r) * t.scale - t.x) * ko, (e.y * t.scale - t.y) * ko, uu(e.z, e.y));
        }, t.getVideo = function (t, r) {
            const n = e.document.createElement("video");n.muted = !0, n.onloadstart = function () {
                r(null, n);
            };for (let r = 0; r < t.length; r++) {
                const i = e.document.createElement("source");ct(t[r]) || (n.crossOrigin = "Anonymous"), i.src = t[r], n.appendChild(i);
            }return { cancel: () => {} };
        }, t.globeCenterToScreenPoint = function (t) {
            const e = [0, 0, 0],
                  r = Eo(new Float64Array(16));return Po(r, t.pixelMatrix, t.globeMatrix), el(e, e, r), new d(e[0], e[1]);
        }, t.globeDenormalizeECEF = Xl, t.globeECEFOrigin = function (t, e) {
            const r = [0, 0, 0];return el(r, r, Gl(Pl(e.canonical))), el(r, r, t), r;
        }, t.globeMetersToEcef = zl, t.globeNormalizeECEF = Gl, t.globePixelsToTileUnits = function (t, e) {
            return ko / (512 * Math.pow(2, t)) * ql(Pl(e));
        }, t.globePoleMatrixForTile = function (t, e, r) {
            const n = Eo(new Float64Array(16)),
                  i = (e / (1 << t) - .5) * Math.PI * 2;return Fo(n, r.globeMatrix, i), Float32Array.from(n);
        }, t.globeTileBounds = Pl, t.globeTiltAtLngLat = Yl, t.globeToMercatorTransition = Kl, t.globeUseCustomAntiAliasing = function (t, e, r) {
            const n = Kl(r.zoom),
                  i = t.style.map._antialias,
                  s = !!e.extStandardDerivatives,
                  a = e.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;return 0 === n && !i && !a && s;
        }, t.identity = Eo, t.identity$1 = hl, t.invert = Co, t.isFullscreen = function () {
            return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
        }, t.isLngLatBehindGlobe = Hl, t.isMapAuthenticated = function (t) {
            return Dt.has(t);
        }, t.isMapboxURL = mt, t.isSafariWithAntialiasingBug = function (t) {
            const e = t.navigator ? t.navigator.userAgent : null;return !!Z(t) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t.latFromMercatorY = lu, t.latLngToECEF = $l, t.len = al, t.length = qo, t.length$1 = function (t) {
            return Math.hypot(t[0], t[1], t[2], t[3]);
        }, t.lngFromMercatorX = ou, t.loadVectorTile = my, t.makeRequest = lt, t.mapValue = function (t, e, r, n, i) {
            return S((t - e) / (r - e) * (i - n) + n, n, i);
        }, t.mercatorScale = hu, t.mercatorXfromLng = iu, t.mercatorYfromLat = su, t.mercatorZfromAltitude = au, t.mul = Uo, t.mul$1 = sl, t.multiply = Po, t.multiply$1 = Bo, t.multiply$2 = Zo, t.nextPowerOfTwo = P, t.normalize = Jo, t.normalize$1 = dl, t.normalize$2 = ll, t.number = Mr, t.ortho = function (t, e, r, n, i, s, a) {
            var o = 1 / (e - r),
                l = 1 / (n - i),
                u = 1 / (s - a);return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t;
        }, t.pbf = op, t.perspective = function (t, e, r, n, i) {
            var s,
                a = 1 / Math.tan(e / 2);return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t;
        }, t.pick = function (t, e) {
            const r = {};for (let n = 0; n < e.length; n++) {
                const i = e[n];i in t && (r[i] = t[i]);
            }return r;
        }, t.plugin = js, t.pointGeometry = d, t.polesInViewport = function (t) {
            const e = Eo(new Float64Array(16));Po(e, t.pixelMatrix, t.globeMatrix);const r = [0, Il, 0],
                  n = [0, Ml, 0];return el(r, r, e), el(n, n, e), [r[0] > 0 && r[0] <= t.width && r[1] > 0 && r[1] <= t.height && !Hl(t, new ru(t.center.lat, 90)), n[0] > 0 && n[0] <= t.width && n[1] > 0 && n[1] <= t.height && !Hl(t, new ru(t.center.lat, -90))];
        }, t.polygonContainsPoint = Du, t.polygonIntersectsBox = Vu, t.polygonIntersectsPolygon = ku, t.polygonizeBounds = function (t, e, r = 0, n = !0) {
            const i = new d(r, r),
                  s = t.sub(i),
                  a = e.add(i),
                  o = [s, new d(a.x, s.y), a, new d(s.x, a.y)];return n && o.push(s.clone()), o;
        }, t.posAttributes = xl, t.postMapLoadEvent = zt, t.postPerformanceEvent = Et, t.postTurnstileEvent = Mt, t.potpack = Cp, t.prevPowerOfTwo = function (t) {
            return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }, t.radToDeg = v, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function (t) {
            return t({ pluginStatus: Cs, pluginURL: Ps }), Ls.on("pluginStateChange", t), t;
        }, t.removeAuthState = function (t) {
            Dt.delete(t);
        }, t.renderColorRamp = ec, t.resample = du, t.rotateX = Lo, t.rotateX$1 = pl, t.rotateY = Fo, t.rotateY$1 = fl, t.rotateZ = function (t, e, r) {
            var n = Math.sin(r),
                i = Math.cos(r),
                s = e[0],
                a = e[1],
                o = e[2],
                l = e[3],
                u = e[4],
                c = e[5],
                h = e[6],
                p = e[7];return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;
        }, t.rotateZ$1 = function (t, e, r) {
            r *= .5;var n = e[0],
                i = e[1],
                s = e[2],
                a = e[3],
                o = Math.sin(r),
                l = Math.cos(r);return t[0] = n * l + i * o, t[1] = i * l - n * o, t[2] = s * l + a * o, t[3] = a * l - s * o, t;
        }, t.scale = Vo, t.scale$1 = ol, t.scale$2 = Ho, t.scaleAndAdd = Wo, t.set = function (t, e, r, n) {
            return t[0] = e, t[1] = r, t[2] = n, t;
        }, t.setCacheLimits = function (t, e) {
            Q = t, tt = e;
        }, t.setColumn = function (t, e, r) {
            t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];
        }, t.setRTLTextPlugin = function (t, e, r = !1) {
            if (Cs === Ts || Cs === zs || Cs === Bs) throw new Error("setRTLTextPlugin cannot be called multiple times.");Ps = Nt.resolveURL(t), Cs = Ts, Es = e, Vs(), r || Rs();
        }, t.smoothstep = k, t.spec = Ht, t.squaredLength = function (t) {
            var e = t[0],
                r = t[1],
                n = t[2];return e * e + r * r + n * n;
        }, t.storeAuthState = function (t, e) {
            e ? Dt.add(t) : Dt.delete(t);
        }, t.sub = il, t.subtract = Xo, t.symbolSize = rp, t.tileAABB = function (t, e, r, n, i, s, a, o, l) {
            if ("globe" === l.name) return Fl(t, e, new kh(r, n, i));const u = Vf({ z: r, x: n, y: i }, l);return new _l([(s + u.x / u.scale) * e, e * (u.y / u.scale), a], [(s + u.x2 / u.scale) * e, e * (u.y2 / u.scale), o]);
        }, t.tileCornersToBounds = Rl, t.tileTransform = Vf, t.transformMat3 = function (t, e, r) {
            var n = e[0],
                i = e[1],
                s = e[2];return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t;
        }, t.transformMat4 = el, t.transformMat4$1 = ul, t.transformQuat = rl, t.transitionTileAABBinECEF = Vl, t.translate = Do, t.transpose = function (t, e) {
            if (t === e) {
                var r = e[1],
                    n = e[2],
                    i = e[5];t[1] = e[3], t[2] = e[6], t[3] = r, t[5] = e[7], t[6] = n, t[7] = i;
            } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];return t;
        }, t.triggerPluginCompletionEvent = Ds, t.uniqueId = E, t.updateGlobeVertexNormal = function (t, e, r, n, i) {
            const s = 5 * e + 2;t.float32[s + 0] = r, t.float32[s + 1] = n, t.float32[s + 2] = i;
        }, t.validateCustomStyleLayer = function (t) {
            const e = [],
                  r = t.id;return void 0 === r && e.push({ message: `layers.${r}: missing required property "id"` }), void 0 === t.render && e.push({ message: `layers.${r}: missing required method "render"` }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), e;
        }, t.validateFilter = t => Fi(xi(t)), t.validateFog = t => Fi(Bi(t)), t.validateLayer = t => Fi(Ai(t)), t.validateLight = t => Fi(Ti(t)), t.validateSource = t => Fi(Ii(t)), t.validateStyle = Di, t.validateTerrain = t => Fi(zi(t)), t.values = T, t.vectorTile = Zc, t.version = r, t.warnOnce = $, t.window = e, t.wrap = I;
    });

    define(["./shared"], function (e) {
        "use strict";
        function t(e) {
            if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e);if (Array.isArray(e)) {
                let r = "[";for (const o of e) r += `${t(o)},`;return `${r}]`;
            }let r = "{";for (const o of Object.keys(e).sort()) r += `${o}:${t(e[o])},`;return `${r}}`;
        }function r(r) {
            let o = "";for (const n of e.refProperties) o += `/${t(r[n])}`;return o;
        }class o {
            constructor(e) {
                this.keyCache = {}, e && this.replace(e);
            }replace(e) {
                this._layerConfigs = {}, this._layers = {}, this.update(e, []);
            }update(t, o) {
                for (const r of t) this._layerConfigs[r.id] = r, (this._layers[r.id] = e.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id];for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];this.familiesBySource = {};const n = function (e, t) {
                    const o = {};for (let n = 0; n < e.length; n++) {
                        const i = t && t[e[n].id] || r(e[n]);t && (t[e[n].id] = i);let s = o[i];s || (s = o[i] = []), s.push(e[n]);
                    }const n = [];for (const e in o) n.push(o[e]);return n;
                }(e.values(this._layerConfigs), this.keyCache);for (const e of n) {
                    const t = e.map(e => this._layers[e.id]),
                          r = t[0];if ("none" === r.visibility) continue;const o = r.source || "";let n = this.familiesBySource[o];n || (n = this.familiesBySource[o] = {});const i = r.sourceLayer || "_geojsonTileLayer";let s = n[i];s || (s = n[i] = []), s.push(t);
                }
            }
        }class n {
            loadTile(t, r) {
                const { uid: o, encoding: n, rawImageData: i, padding: s, buildQuadTree: a } = t,
                      l = e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? this.getImageData(i, s) : i;r(null, new e.DEMData(o, l, n, s < 1, a));
            }getImageData(e, t) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);const r = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r;
            }
        }var i = function e(t, r) {
            var o,
                n = t && t.type;if ("FeatureCollection" === n) for (o = 0; o < t.features.length; o++) e(t.features[o], r);else if ("GeometryCollection" === n) for (o = 0; o < t.geometries.length; o++) e(t.geometries[o], r);else if ("Feature" === n) e(t.geometry, r);else if ("Polygon" === n) s(t.coordinates, r);else if ("MultiPolygon" === n) for (o = 0; o < t.coordinates.length; o++) s(t.coordinates[o], r);return t;
        };function s(e, t) {
            if (0 !== e.length) {
                a(e[0], t);for (var r = 1; r < e.length; r++) a(e[r], !t);
            }
        }function a(e, t) {
            for (var r = 0, o = 0, n = 0, i = e.length, s = i - 1; n < i; s = n++) {
                var a = (e[n][0] - e[s][0]) * (e[s][1] + e[n][1]),
                    l = r + a;o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r, r = l;
            }r + o >= 0 != !!t && e.reverse();
        }const l = e.VectorTileFeature.prototype.toGeoJSON;class u {
            constructor(t) {
                this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));
            }loadGeometry() {
                if (1 === this._feature.type) {
                    const t = [];for (const r of this._feature.geometry) t.push([new e.pointGeometry(r[0], r[1])]);return t;
                }{
                    const t = [];for (const r of this._feature.geometry) {
                        const o = [];for (const t of r) o.push(new e.pointGeometry(t[0], t[1]));t.push(o);
                    }return t;
                }
            }toGeoJSON(e, t, r) {
                return l.call(this, e, t, r);
            }
        }class h {
            constructor(t) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t;
            }feature(e) {
                return new u(this._features[e]);
            }
        }var c = {},
            f = { get exports() {
                return c;
            }, set exports(e) {
                c = e;
            } },
            p = e.pointGeometry,
            g = e.vectorTile.VectorTileFeature,
            d = m;function m(e, t) {
            this.options = t || {}, this.features = e, this.length = e.length;
        }function y(e, t) {
            this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;
        }m.prototype.feature = function (e) {
            return new y(this.features[e], this.options.extent);
        }, y.prototype.loadGeometry = function () {
            var e = this.rawGeometry;this.geometry = [];for (var t = 0; t < e.length; t++) {
                for (var r = e[t], o = [], n = 0; n < r.length; n++) o.push(new p(r[n][0], r[n][1]));this.geometry.push(o);
            }return this.geometry;
        }, y.prototype.bbox = function () {
            this.geometry || this.loadGeometry();for (var e = this.geometry, t = 1 / 0, r = -1 / 0, o = 1 / 0, n = -1 / 0, i = 0; i < e.length; i++) for (var s = e[i], a = 0; a < s.length; a++) {
                var l = s[a];t = Math.min(t, l.x), r = Math.max(r, l.x), o = Math.min(o, l.y), n = Math.max(n, l.y);
            }return [t, o, r, n];
        }, y.prototype.toGeoJSON = g.prototype.toGeoJSON;var v = e.pbf,
            x = d;function w(e) {
            var t = new v();return function (e, t) {
                for (var r in e.layers) t.writeMessage(3, S, e.layers[r]);
            }(e, t), t.finish();
        }function S(e, t) {
            var r;t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);var o = { keys: [], values: [], keycache: {}, valuecache: {} };for (r = 0; r < e.length; r++) o.feature = e.feature(r), t.writeMessage(2, M, o);var n = o.keys;for (r = 0; r < n.length; r++) t.writeStringField(3, n[r]);var i = o.values;for (r = 0; r < i.length; r++) t.writeMessage(4, T, i[r]);
        }function M(e, t) {
            var r = e.feature;void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, P, e), t.writeVarintField(3, r.type), t.writeMessage(4, I, r);
        }function P(e, t) {
            var r = e.feature,
                o = e.keys,
                n = e.values,
                i = e.keycache,
                s = e.valuecache;for (var a in r.properties) {
                var l = r.properties[a],
                    u = i[a];if (null !== l) {
                    void 0 === u && (o.push(a), i[a] = u = o.length - 1), t.writeVarint(u);var h = typeof l;"string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));var c = h + ":" + l,
                        f = s[c];void 0 === f && (n.push(l), s[c] = f = n.length - 1), t.writeVarint(f);
                }
            }
        }function b(e, t) {
            return (t << 3) + (7 & e);
        }function k(e) {
            return e << 1 ^ e >> 31;
        }function I(e, t) {
            for (var r = e.loadGeometry(), o = e.type, n = 0, i = 0, s = r.length, a = 0; a < s; a++) {
                var l = r[a],
                    u = 1;1 === o && (u = l.length), t.writeVarint(b(1, u));for (var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++) {
                    1 === c && 1 !== o && t.writeVarint(b(2, h - 1));var f = l[c].x - n,
                        p = l[c].y - i;t.writeVarint(k(f)), t.writeVarint(k(p)), n += f, i += p;
                }3 === o && t.writeVarint(b(7, 1));
            }
        }function T(e, t) {
            var r = typeof e;"string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));
        }function _(e, t, r, o, n, i) {
            if (n - o <= r) return;const s = o + n >> 1;L(e, t, s, o, n, i % 2), _(e, t, r, o, s - 1, i + 1), _(e, t, r, s + 1, n, i + 1);
        }function L(e, t, r, o, n, i) {
            for (; n > o;) {
                if (n - o > 600) {
                    const s = n - o + 1,
                          a = r - o + 1,
                          l = Math.log(s),
                          u = .5 * Math.exp(2 * l / 3),
                          h = .5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1);L(e, t, r, Math.max(o, Math.floor(r - a * u / s + h)), Math.min(n, Math.floor(r + (s - a) * u / s + h)), i);
                }const s = t[2 * r + i];let a = o,
                    l = n;for (C(e, t, o, r), t[2 * n + i] > s && C(e, t, o, n); a < l;) {
                    for (C(e, t, a, l), a++, l--; t[2 * a + i] < s;) a++;for (; t[2 * l + i] > s;) l--;
                }t[2 * o + i] === s ? C(e, t, o, l) : (l++, C(e, t, l, n)), l <= r && (o = l + 1), r <= l && (n = l - 1);
            }
        }function C(e, t, r, o) {
            O(e, r, o), O(t, 2 * r, 2 * o), O(t, 2 * r + 1, 2 * o + 1);
        }function O(e, t, r) {
            const o = e[t];e[t] = e[r], e[r] = o;
        }function z(e, t, r, o) {
            const n = e - r,
                  i = t - o;return n * n + i * i;
        }f.exports = w, c.fromVectorTileJs = w, c.fromGeojsonVt = function (e, t) {
            t = t || {};var r = {};for (var o in e) r[o] = new x(e[o].features, t), r[o].name = o, r[o].version = t.version, r[o].extent = t.extent;return w({ layers: r });
        }, c.GeoJSONWrapper = x;const E = e => e[0],
              F = e => e[1];class N {
            constructor(e, t = E, r = F, o = 64, n = Float64Array) {
                this.nodeSize = o, this.points = e;const i = e.length < 65536 ? Uint16Array : Uint32Array,
                      s = this.ids = new i(e.length),
                      a = this.coords = new n(2 * e.length);for (let o = 0; o < e.length; o++) s[o] = o, a[2 * o] = t(e[o]), a[2 * o + 1] = r(e[o]);_(s, a, o, 0, s.length - 1, 0);
            }range(e, t, r, o) {
                return function (e, t, r, o, n, i, s) {
                    const a = [0, e.length - 1, 0],
                          l = [];let u, h;for (; a.length;) {
                        const c = a.pop(),
                              f = a.pop(),
                              p = a.pop();if (f - p <= s) {
                            for (let s = p; s <= f; s++) u = t[2 * s], h = t[2 * s + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[s]);continue;
                        }const g = Math.floor((p + f) / 2);u = t[2 * g], h = t[2 * g + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[g]);const d = (c + 1) % 2;(0 === c ? r <= u : o <= h) && (a.push(p), a.push(g - 1), a.push(d)), (0 === c ? n >= u : i >= h) && (a.push(g + 1), a.push(f), a.push(d));
                    }return l;
                }(this.ids, this.coords, e, t, r, o, this.nodeSize);
            }within(e, t, r) {
                return function (e, t, r, o, n, i) {
                    const s = [0, e.length - 1, 0],
                          a = [],
                          l = n * n;for (; s.length;) {
                        const u = s.pop(),
                              h = s.pop(),
                              c = s.pop();if (h - c <= i) {
                            for (let n = c; n <= h; n++) z(t[2 * n], t[2 * n + 1], r, o) <= l && a.push(e[n]);continue;
                        }const f = Math.floor((c + h) / 2),
                              p = t[2 * f],
                              g = t[2 * f + 1];z(p, g, r, o) <= l && a.push(e[f]);const d = (u + 1) % 2;(0 === u ? r - n <= p : o - n <= g) && (s.push(c), s.push(f - 1), s.push(d)), (0 === u ? r + n >= p : o + n >= g) && (s.push(f + 1), s.push(h), s.push(d));
                    }return a;
                }(this.ids, this.coords, e, t, r, this.nodeSize);
            }
        }const j = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: e => e },
              Z = Math.fround || (G = new Float32Array(1), e => (G[0] = +e, G[0]));var G;class J {
            constructor(e) {
                this.options = B(Object.create(j), e), this.trees = new Array(this.options.maxZoom + 1);
            }load(e) {
                const { log: t, minZoom: r, maxZoom: o, nodeSize: n } = this.options;t && console.time("total time");const i = `prepare ${e.length} points`;t && console.time(i), this.points = e;let s = [];for (let t = 0; t < e.length; t++) e[t].geometry && s.push(Y(e[t], t));this.trees[o + 1] = new N(s, R, q, n, Float32Array), t && console.timeEnd(i);for (let e = o; e >= r; e--) {
                    const r = +Date.now();s = this._cluster(s, e), this.trees[e] = new N(s, R, q, n, Float32Array), t && console.log("z%d: %d clusters in %dms", e, s.length, +Date.now() - r);
                }return t && console.timeEnd("total time"), this;
            }getClusters(e, t) {
                let r = ((e[0] + 180) % 360 + 360) % 360 - 180;const o = Math.max(-90, Math.min(90, e[1]));let n = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;const i = Math.max(-90, Math.min(90, e[3]));if (e[2] - e[0] >= 360) r = -180, n = 180;else if (r > n) {
                    const e = this.getClusters([r, o, 180, i], t),
                          s = this.getClusters([-180, o, n, i], t);return e.concat(s);
                }const s = this.trees[this._limitZoom(t)],
                      a = s.range(A(r), D(i), A(n), D(o)),
                      l = [];for (const e of a) {
                    const t = s.points[e];l.push(t.numPoints ? X(t) : this.points[t.index]);
                }return l;
            }getChildren(e) {
                const t = this._getOriginId(e),
                      r = this._getOriginZoom(e),
                      o = "No cluster with the specified id.",
                      n = this.trees[r];if (!n) throw new Error(o);const i = n.points[t];if (!i) throw new Error(o);const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)),
                      a = n.within(i.x, i.y, s),
                      l = [];for (const t of a) {
                    const r = n.points[t];r.parentId === e && l.push(r.numPoints ? X(r) : this.points[r.index]);
                }if (0 === l.length) throw new Error(o);return l;
            }getLeaves(e, t, r) {
                const o = [];return this._appendLeaves(o, e, t = t || 10, r = r || 0, 0), o;
            }getTile(e, t, r) {
                const o = this.trees[this._limitZoom(e)],
                      n = Math.pow(2, e),
                      { extent: i, radius: s } = this.options,
                      a = s / i,
                      l = (r - a) / n,
                      u = (r + 1 + a) / n,
                      h = { features: [] };return this._addTileFeatures(o.range((t - a) / n, l, (t + 1 + a) / n, u), o.points, t, r, n, h), 0 === t && this._addTileFeatures(o.range(1 - a / n, l, 1, u), o.points, n, r, n, h), t === n - 1 && this._addTileFeatures(o.range(0, l, a / n, u), o.points, -1, r, n, h), h.features.length ? h : null;
            }getClusterExpansionZoom(e) {
                let t = this._getOriginZoom(e) - 1;for (; t <= this.options.maxZoom;) {
                    const r = this.getChildren(e);if (t++, 1 !== r.length) break;e = r[0].properties.cluster_id;
                }return t;
            }_appendLeaves(e, t, r, o, n) {
                const i = this.getChildren(t);for (const t of i) {
                    const i = t.properties;if (i && i.cluster ? n + i.point_count <= o ? n += i.point_count : n = this._appendLeaves(e, i.cluster_id, r, o, n) : n < o ? n++ : e.push(t), e.length === r) break;
                }return n;
            }_addTileFeatures(e, t, r, o, n, i) {
                for (const s of e) {
                    const e = t[s],
                          a = e.numPoints;let l, u, h;if (a) l = V(e), u = e.x, h = e.y;else {
                        const t = this.points[e.index];l = t.properties, u = A(t.geometry.coordinates[0]), h = D(t.geometry.coordinates[1]);
                    }const c = { type: 1, geometry: [[Math.round(this.options.extent * (u * n - r)), Math.round(this.options.extent * (h * n - o))]], tags: l };let f;a ? f = e.id : this.options.generateId ? f = e.index : this.points[e.index].id && (f = this.points[e.index].id), void 0 !== f && (c.id = f), i.features.push(c);
                }
            }_limitZoom(e) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
            }_cluster(e, t) {
                const r = [],
                      { radius: o, extent: n, reduce: i, minPoints: s } = this.options,
                      a = o / (n * Math.pow(2, t));for (let o = 0; o < e.length; o++) {
                    const n = e[o];if (n.zoom <= t) continue;n.zoom = t;const l = this.trees[t + 1],
                          u = l.within(n.x, n.y, a),
                          h = n.numPoints || 1;let c = h;for (const e of u) {
                        const r = l.points[e];r.zoom > t && (c += r.numPoints || 1);
                    }if (c > h && c >= s) {
                        let e = n.x * h,
                            s = n.y * h,
                            a = i && h > 1 ? this._map(n, !0) : null;const f = (o << 5) + (t + 1) + this.points.length;for (const r of u) {
                            const o = l.points[r];if (o.zoom <= t) continue;o.zoom = t;const u = o.numPoints || 1;e += o.x * u, s += o.y * u, o.parentId = f, i && (a || (a = this._map(n, !0)), i(a, this._map(o)));
                        }n.parentId = f, r.push(W(e / c, s / c, f, c, a));
                    } else if (r.push(n), c > 1) for (const e of u) {
                        const o = l.points[e];o.zoom <= t || (o.zoom = t, r.push(o));
                    }
                }return r;
            }_getOriginId(e) {
                return e - this.points.length >> 5;
            }_getOriginZoom(e) {
                return (e - this.points.length) % 32;
            }_map(e, t) {
                if (e.numPoints) return t ? B({}, e.properties) : e.properties;const r = this.points[e.index].properties,
                      o = this.options.map(r);return t && o === r ? B({}, o) : o;
            }
        }function W(e, t, r, o, n) {
            return { x: Z(e), y: Z(t), zoom: 1 / 0, id: r, parentId: -1, numPoints: o, properties: n };
        }function Y(e, t) {
            const [r, o] = e.geometry.coordinates;return { x: Z(A(r)), y: Z(D(o)), zoom: 1 / 0, index: t, parentId: -1 };
        }function X(e) {
            return { type: "Feature", id: e.id, properties: V(e), geometry: { type: "Point", coordinates: [(t = e.x, 360 * (t - .5)), $(e.y)] } };var t;
        }function V(e) {
            const t = e.numPoints,
                  r = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;return B(B({}, e.properties), { cluster: !0, cluster_id: e.id, point_count: t, point_count_abbreviated: r });
        }function A(e) {
            return e / 360 + .5;
        }function D(e) {
            const t = Math.sin(e * Math.PI / 180),
                  r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;return r < 0 ? 0 : r > 1 ? 1 : r;
        }function $(e) {
            const t = (180 - 360 * e) * Math.PI / 180;return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
        }function B(e, t) {
            for (const r in t) e[r] = t[r];return e;
        }function R(e) {
            return e.x;
        }function q(e) {
            return e.y;
        }function U(e, t, r, o) {
            for (var n, i = o, s = r - t >> 1, a = r - t, l = e[t], u = e[t + 1], h = e[r], c = e[r + 1], f = t + 3; f < r; f += 3) {
                var p = Q(e[f], e[f + 1], l, u, h, c);if (p > i) n = f, i = p;else if (p === i) {
                    var g = Math.abs(f - s);g < a && (n = f, a = g);
                }
            }i > o && (n - t > 3 && U(e, t, n, o), e[n + 2] = i, r - n > 3 && U(e, n, r, o));
        }function Q(e, t, r, o, n, i) {
            var s = n - r,
                a = i - o;if (0 !== s || 0 !== a) {
                var l = ((e - r) * s + (t - o) * a) / (s * s + a * a);l > 1 ? (r = n, o = i) : l > 0 && (r += s * l, o += a * l);
            }return (s = e - r) * s + (a = t - o) * a;
        }function H(e, t, r, o) {
            var n = { id: void 0 === e ? null : e, type: t, geometry: r, tags: o, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };return function (e) {
                var t = e.geometry,
                    r = e.type;if ("Point" === r || "MultiPoint" === r || "LineString" === r) K(e, t);else if ("Polygon" === r || "MultiLineString" === r) for (var o = 0; o < t.length; o++) K(e, t[o]);else if ("MultiPolygon" === r) for (o = 0; o < t.length; o++) for (var n = 0; n < t[o].length; n++) K(e, t[o][n]);
            }(n), n;
        }function K(e, t) {
            for (var r = 0; r < t.length; r += 3) e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);
        }function ee(e, t, r, o) {
            if (t.geometry) {
                var n = t.geometry.coordinates,
                    i = t.geometry.type,
                    s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),
                    a = [],
                    l = t.id;if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = o || 0), "Point" === i) te(n, a);else if ("MultiPoint" === i) for (var u = 0; u < n.length; u++) te(n[u], a);else if ("LineString" === i) re(n, a, s, !1);else if ("MultiLineString" === i) {
                    if (r.lineMetrics) {
                        for (u = 0; u < n.length; u++) re(n[u], a = [], s, !1), e.push(H(l, "LineString", a, t.properties));return;
                    }oe(n, a, s, !1);
                } else if ("Polygon" === i) oe(n, a, s, !0);else {
                    if ("MultiPolygon" !== i) {
                        if ("GeometryCollection" === i) {
                            for (u = 0; u < t.geometry.geometries.length; u++) ee(e, { id: l, geometry: t.geometry.geometries[u], properties: t.properties }, r, o);return;
                        }throw new Error("Input data is not a valid GeoJSON object.");
                    }for (u = 0; u < n.length; u++) {
                        var h = [];oe(n[u], h, s, !0), a.push(h);
                    }
                }e.push(H(l, i, a, t.properties));
            }
        }function te(e, t) {
            t.push(ne(e[0])), t.push(ie(e[1])), t.push(0);
        }function re(e, t, r, o) {
            for (var n, i, s = 0, a = 0; a < e.length; a++) {
                var l = ne(e[a][0]),
                    u = ie(e[a][1]);t.push(l), t.push(u), t.push(0), a > 0 && (s += o ? (n * u - l * i) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(u - i, 2))), n = l, i = u;
            }var h = t.length - 3;t[2] = 1, U(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;
        }function oe(e, t, r, o) {
            for (var n = 0; n < e.length; n++) {
                var i = [];re(e[n], i, r, o), t.push(i);
            }
        }function ne(e) {
            return e / 360 + .5;
        }function ie(e) {
            var t = Math.sin(e * Math.PI / 180),
                r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;return r < 0 ? 0 : r > 1 ? 1 : r;
        }function se(e, t, r, o, n, i, s, a) {
            if (o /= t, i >= (r /= t) && s < o) return e;if (s < r || i >= o) return null;for (var l = [], u = 0; u < e.length; u++) {
                var h = e[u],
                    c = h.geometry,
                    f = h.type,
                    p = 0 === n ? h.minX : h.minY,
                    g = 0 === n ? h.maxX : h.maxY;if (p >= r && g < o) l.push(h);else if (!(g < r || p >= o)) {
                    var d = [];if ("Point" === f || "MultiPoint" === f) ae(c, d, r, o, n);else if ("LineString" === f) le(c, d, r, o, n, !1, a.lineMetrics);else if ("MultiLineString" === f) he(c, d, r, o, n, !1);else if ("Polygon" === f) he(c, d, r, o, n, !0);else if ("MultiPolygon" === f) for (var m = 0; m < c.length; m++) {
                        var y = [];he(c[m], y, r, o, n, !0), y.length && d.push(y);
                    }if (d.length) {
                        if (a.lineMetrics && "LineString" === f) {
                            for (m = 0; m < d.length; m++) l.push(H(h.id, f, d[m], h.tags));continue;
                        }"LineString" !== f && "MultiLineString" !== f || (1 === d.length ? (f = "LineString", d = d[0]) : f = "MultiLineString"), "Point" !== f && "MultiPoint" !== f || (f = 3 === d.length ? "Point" : "MultiPoint"), l.push(H(h.id, f, d, h.tags));
                    }
                }
            }return l.length ? l : null;
        }function ae(e, t, r, o, n) {
            for (var i = 0; i < e.length; i += 3) {
                var s = e[i + n];s >= r && s <= o && (t.push(e[i]), t.push(e[i + 1]), t.push(e[i + 2]));
            }
        }function le(e, t, r, o, n, i, s) {
            for (var a, l, u = ue(e), h = 0 === n ? fe : pe, c = e.start, f = 0; f < e.length - 3; f += 3) {
                var p = e[f],
                    g = e[f + 1],
                    d = e[f + 2],
                    m = e[f + 3],
                    y = e[f + 4],
                    v = 0 === n ? p : g,
                    x = 0 === n ? m : y,
                    w = !1;s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))), v < r ? x > r && (l = h(u, p, g, m, y, r), s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o), s && (u.start = c + a * l)) : ce(u, p, g, d), x < r && v >= r && (l = h(u, p, g, m, y, r), w = !0), x > o && v <= o && (l = h(u, p, g, m, y, o), w = !0), !i && w && (s && (u.end = c + a * l), t.push(u), u = ue(e)), s && (c += a);
            }var S = e.length - 3;p = e[S], g = e[S + 1], d = e[S + 2], (v = 0 === n ? p : g) >= r && v <= o && ce(u, p, g, d), S = u.length - 3, i && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && ce(u, u[0], u[1], u[2]), u.length && t.push(u);
        }function ue(e) {
            var t = [];return t.size = e.size, t.start = e.start, t.end = e.end, t;
        }function he(e, t, r, o, n, i) {
            for (var s = 0; s < e.length; s++) le(e[s], t, r, o, n, i, !1);
        }function ce(e, t, r, o) {
            e.push(t), e.push(r), e.push(o);
        }function fe(e, t, r, o, n, i) {
            var s = (i - t) / (o - t);return e.push(i), e.push(r + (n - r) * s), e.push(1), s;
        }function pe(e, t, r, o, n, i) {
            var s = (i - r) / (n - r);return e.push(t + (o - t) * s), e.push(i), e.push(1), s;
        }function ge(e, t) {
            for (var r = [], o = 0; o < e.length; o++) {
                var n,
                    i = e[o],
                    s = i.type;if ("Point" === s || "MultiPoint" === s || "LineString" === s) n = de(i.geometry, t);else if ("MultiLineString" === s || "Polygon" === s) {
                    n = [];for (var a = 0; a < i.geometry.length; a++) n.push(de(i.geometry[a], t));
                } else if ("MultiPolygon" === s) for (n = [], a = 0; a < i.geometry.length; a++) {
                    for (var l = [], u = 0; u < i.geometry[a].length; u++) l.push(de(i.geometry[a][u], t));n.push(l);
                }r.push(H(i.id, s, n, i.tags));
            }return r;
        }function de(e, t) {
            var r = [];r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);for (var o = 0; o < e.length; o += 3) r.push(e[o] + t, e[o + 1], e[o + 2]);return r;
        }function me(e, t) {
            if (e.transformed) return e;var r,
                o,
                n,
                i = 1 << e.z,
                s = e.x,
                a = e.y;for (r = 0; r < e.features.length; r++) {
                var l = e.features[r],
                    u = l.geometry,
                    h = l.type;if (l.geometry = [], 1 === h) for (o = 0; o < u.length; o += 2) l.geometry.push(ye(u[o], u[o + 1], t, i, s, a));else for (o = 0; o < u.length; o++) {
                    var c = [];for (n = 0; n < u[o].length; n += 2) c.push(ye(u[o][n], u[o][n + 1], t, i, s, a));l.geometry.push(c);
                }
            }return e.transformed = !0, e;
        }function ye(e, t, r, o, n, i) {
            return [Math.round(r * (e * o - n)), Math.round(r * (t * o - i))];
        }function ve(e, t, r, o, n) {
            for (var i = t === n.maxZoom ? 0 : n.tolerance / ((1 << t) * n.extent), s = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r, y: o, z: t, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a = 0; a < e.length; a++) {
                s.numFeatures++, xe(s, e[a], i, n);var l = e[a].minX,
                    u = e[a].minY,
                    h = e[a].maxX,
                    c = e[a].maxY;l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);
            }return s;
        }function xe(e, t, r, o) {
            var n = t.geometry,
                i = t.type,
                s = [];if ("Point" === i || "MultiPoint" === i) for (var a = 0; a < n.length; a += 3) s.push(n[a]), s.push(n[a + 1]), e.numPoints++, e.numSimplified++;else if ("LineString" === i) we(s, n, e, r, !1, !1);else if ("MultiLineString" === i || "Polygon" === i) for (a = 0; a < n.length; a++) we(s, n[a], e, r, "Polygon" === i, 0 === a);else if ("MultiPolygon" === i) for (var l = 0; l < n.length; l++) {
                var u = n[l];for (a = 0; a < u.length; a++) we(s, u[a], e, r, !0, 0 === a);
            }if (s.length) {
                var h = t.tags || null;if ("LineString" === i && o.lineMetrics) {
                    for (var c in h = {}, t.tags) h[c] = t.tags[c];h.mapbox_clip_start = n.start / n.size, h.mapbox_clip_end = n.end / n.size;
                }var f = { geometry: s, type: "Polygon" === i || "MultiPolygon" === i ? 3 : "LineString" === i || "MultiLineString" === i ? 2 : 1, tags: h };null !== t.id && (f.id = t.id), e.features.push(f);
            }
        }function we(e, t, r, o, n, i) {
            var s = o * o;if (o > 0 && t.size < (n ? s : o)) r.numPoints += t.length / 3;else {
                for (var a = [], l = 0; l < t.length; l += 3) (0 === o || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;n && function (e, t) {
                    for (var r = 0, o = 0, n = e.length, i = n - 2; o < n; i = o, o += 2) r += (e[o] - e[i]) * (e[o + 1] + e[i + 1]);if (r > 0 === t) for (o = 0, n = e.length; o < n / 2; o += 2) {
                        var s = e[o],
                            a = e[o + 1];e[o] = e[n - 2 - o], e[o + 1] = e[n - 1 - o], e[n - 2 - o] = s, e[n - 1 - o] = a;
                    }
                }(a, i), e.push(a);
            }
        }function Se(e, t) {
            var r = (t = this.options = function (e, t) {
                for (var r in t) e[r] = t[r];return e;
            }(Object.create(this.options), t)).debug;if (r && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");var o = function (e, t) {
                var r = [];if ("FeatureCollection" === e.type) for (var o = 0; o < e.features.length; o++) ee(r, e.features[o], t, o);else ee(r, "Feature" === e.type ? e : { geometry: e }, t);return r;
            }(e, t);this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o = function (e, t) {
                var r = t.buffer / t.extent,
                    o = e,
                    n = se(e, 1, -1 - r, r, 0, -1, 2, t),
                    i = se(e, 1, 1 - r, 2 + r, 0, -1, 2, t);return (n || i) && (o = se(e, 1, -r, 1 + r, 0, -1, 2, t) || [], n && (o = ge(n, 1).concat(o)), i && (o = o.concat(ge(i, -1)))), o;
            }(o, t), o.length && this.splitTile(o, 0, 0, 0), r && (o.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }function Me(e, t, r) {
            return 32 * ((1 << e) * r + t) + e;
        }function Pe(e, t) {
            const r = e.tileID.canonical;if (!this._geoJSONIndex) return t(null, null);const o = this._geoJSONIndex.getTile(r.z, r.x, r.y);if (!o) return t(null, null);const n = new h(o.features);let i = c(n);0 === i.byteOffset && i.byteLength === i.buffer.byteLength || (i = new Uint8Array(i)), t(null, { vectorTile: n, rawData: i.buffer });
        }Se.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, Se.prototype.splitTile = function (e, t, r, o, n, i, s) {
            for (var a = [e, t, r, o], l = this.options, u = l.debug; a.length;) {
                o = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();var h = 1 << t,
                    c = Me(t, r, o),
                    f = this.tiles[c];if (!f && (u > 1 && console.time("creation"), f = this.tiles[c] = ve(e, t, r, o, l), this.tileCoords.push({ z: t, x: r, y: o }), u)) {
                    u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, o, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd("creation"));var p = "z" + t;this.stats[p] = (this.stats[p] || 0) + 1, this.total++;
                }if (f.source = e, n) {
                    if (t === l.maxZoom || t === n) continue;var g = 1 << n - t;if (r !== Math.floor(i / g) || o !== Math.floor(s / g)) continue;
                } else if (t === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue;if (f.source = null, 0 !== e.length) {
                    u > 1 && console.time("clipping");var d,
                        m,
                        y,
                        v,
                        x,
                        w,
                        S = .5 * l.buffer / l.extent,
                        M = .5 - S,
                        P = .5 + S,
                        b = 1 + S;d = m = y = v = null, x = se(e, h, r - S, r + P, 0, f.minX, f.maxX, l), w = se(e, h, r + M, r + b, 0, f.minX, f.maxX, l), e = null, x && (d = se(x, h, o - S, o + P, 1, f.minY, f.maxY, l), m = se(x, h, o + M, o + b, 1, f.minY, f.maxY, l), x = null), w && (y = se(w, h, o - S, o + P, 1, f.minY, f.maxY, l), v = se(w, h, o + M, o + b, 1, f.minY, f.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(d || [], t + 1, 2 * r, 2 * o), a.push(m || [], t + 1, 2 * r, 2 * o + 1), a.push(y || [], t + 1, 2 * r + 1, 2 * o), a.push(v || [], t + 1, 2 * r + 1, 2 * o + 1);
                }
            }
        }, Se.prototype.getTile = function (e, t, r) {
            var o = this.options,
                n = o.extent,
                i = o.debug;if (e < 0 || e > 24) return null;var s = 1 << e,
                a = Me(e, t = (t % s + s) % s, r);if (this.tiles[a]) return me(this.tiles[a], n);i > 1 && console.log("drilling down to z%d-%d-%d", e, t, r);for (var l, u = e, h = t, c = r; !l && u > 0;) u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[Me(u, h, c)];return l && l.source ? (i > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), i > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e, t, r), i > 1 && console.timeEnd("drilling down"), this.tiles[a] ? me(this.tiles[a], n) : null) : null;
        };class be extends e.VectorTileWorkerSource {
            constructor(e, t, r, o, n) {
                super(e, t, r, o, Pe), n && (this.loadGeoJSON = n);
            }loadData(t, r) {
                const o = t && t.request,
                      n = o && o.collectResourceTiming;this.loadGeoJSON(t, (s, a) => {
                    if (s || !a) return r(s);if ("object" != typeof a) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));{
                        i(a, !0);try {
                            if (t.filter) {
                                const r = e.createExpression(t.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });if ("error" === r.result) throw new Error(r.value.map(e => `${e.key}: ${e.message}`).join(", "));const o = a.features.filter(e => r.value.evaluate({ zoom: 0 }, e));a = { type: "FeatureCollection", features: o };
                            }this._geoJSONIndex = t.cluster ? new J(function ({ superclusterOptions: t, clusterProperties: r }) {
                                if (!r || !t) return t;const o = {},
                                      n = {},
                                      i = { accumulated: null, zoom: 0 },
                                      s = { properties: null },
                                      a = Object.keys(r);for (const t of a) {
                                    const [i, s] = r[t],
                                          a = e.createExpression(s),
                                          l = e.createExpression("string" == typeof i ? [i, ["accumulated"], ["get", t]] : i);o[t] = a.value, n[t] = l.value;
                                }return t.map = e => {
                                    s.properties = e;const t = {};for (const e of a) t[e] = o[e].evaluate(i, s);return t;
                                }, t.reduce = (e, t) => {
                                    s.properties = t;for (const t of a) i.accumulated = e[t], e[t] = n[t].evaluate(i, s);
                                }, t;
                            }(t)).load(a.features) : function (e, t) {
                                return new Se(e, t);
                            }(a, t.geojsonVtOptions);
                        } catch (s) {
                            return r(s);
                        }this.loaded = {};const l = {};if (n) {
                            const r = e.getPerformanceMeasurement(o);r && (l.resourceTiming = {}, l.resourceTiming[t.source] = JSON.parse(JSON.stringify(r)));
                        }r(null, l);
                    }
                });
            }reloadTile(e, t) {
                const r = this.loaded;return r && r[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);
            }loadGeoJSON(t, r) {
                if (t.request) e.getJSON(t.request, r);else {
                    if ("string" != typeof t.data) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));try {
                        return r(null, JSON.parse(t.data));
                    } catch (e) {
                        return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                    }
                }
            }getClusterExpansionZoom(e, t) {
                try {
                    t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
                } catch (e) {
                    t(e);
                }
            }getClusterChildren(e, t) {
                try {
                    t(null, this._geoJSONIndex.getChildren(e.clusterId));
                } catch (e) {
                    t(e);
                }
            }getClusterLeaves(e, t) {
                try {
                    t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
                } catch (e) {
                    t(e);
                }
            }
        }class ke {
            constructor(t) {
                this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: be }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {
                    if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);this.workerSourceTypes[e] = t;
                }, this.self.registerRTLTextPlugin = t => {
                    if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;
                };
            }clearCaches(e, t, r) {
                delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], r();
            }checkIfReady(e, t, r) {
                r();
            }setReferrer(e, t) {
                this.referrer = t;
            }spriteLoaded(t, r) {
                this.isSpriteLoaded[t] = r;for (const o in this.workerSources[t]) {
                    const n = this.workerSources[t][o];for (const t in n) n[t] instanceof e.VectorTileWorkerSource && (n[t].isSpriteLoaded = r, n[t].fire(new e.Event("isSpriteLoaded")));
                }
            }setImages(e, t, r) {
                this.availableImages[e] = t;for (const r in this.workerSources[e]) {
                    const o = this.workerSources[e][r];for (const e in o) o[e].availableImages = t;
                }r();
            }enableTerrain(e, t, r) {
                this.terrain = t, r();
            }setProjection(t, r) {
                this.projections[t] = e.getProjection(r);
            }setLayers(e, t, r) {
                this.getLayerIndex(e).replace(t), r();
            }updateLayers(e, t, r) {
                this.getLayerIndex(e).update(t.layers, t.removedIds), r();
            }loadTile(t, r, o) {
                const n = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r) : r;n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).loadTile(n, o);
            }loadDEMTile(t, r, o) {
                const n = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r) : r;this.getDEMWorkerSource(t, r.source).loadTile(n, o);
            }reloadTile(t, r, o) {
                const n = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r) : r;n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).reloadTile(n, o);
            }abortTile(e, t, r) {
                this.getWorkerSource(e, t.type, t.source).abortTile(t, r);
            }removeTile(e, t, r) {
                this.getWorkerSource(e, t.type, t.source).removeTile(t, r);
            }removeSource(e, t, r) {
                if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;const o = this.workerSources[e][t.type][t.source];delete this.workerSources[e][t.type][t.source], void 0 !== o.removeSource ? o.removeSource(t, r) : r();
            }loadWorkerSource(e, t, r) {
                try {
                    this.self.importScripts(t.url), r();
                } catch (e) {
                    r(e.toString());
                }
            }syncRTLPluginState(t, r, o) {
                try {
                    e.plugin.setState(r);const t = e.plugin.getPluginURL();if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {
                        this.self.importScripts(t);const r = e.plugin.isParsed();o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), r);
                    }
                } catch (e) {
                    o(e.toString());
                }
            }getAvailableImages(e) {
                let t = this.availableImages[e];return t || (t = []), t;
            }getLayerIndex(e) {
                let t = this.layerIndexes[e];return t || (t = this.layerIndexes[e] = new o()), t;
            }getWorkerSource(e, t, r) {
                if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][r]) {
                    const o = { send: (t, r, o, n, i, s) => {
                            this.actor.send(t, r, o, e, i, s);
                        }, scheduler: this.actor.scheduler };this.workerSources[e][t][r] = new this.workerSourceTypes[t](o, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e]);
                }return this.workerSources[e][t][r];
            }getDEMWorkerSource(e, t) {
                return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new n()), this.demWorkerSources[e][t];
            }enforceCacheSizeLimit(t, r) {
                e.enforceCacheSizeLimit(r);
            }getWorkerPerformanceMetrics(e, t, r) {
                r(void 0, void 0);
            }
        }return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new ke(self)), ke;
    });

    define(["./shared"], function (e) {
        "use strict";
        function t(e, i) {
            if (Array.isArray(e)) {
                if (!Array.isArray(i) || e.length !== i.length) return !1;for (let o = 0; o < e.length; o++) if (!t(e[o], i[o])) return !1;return !0;
            }if ("object" == typeof e && null !== e && null !== i) {
                if ("object" != typeof i) return !1;if (Object.keys(e).length !== Object.keys(i).length) return !1;for (const o in e) if (!t(e[o], i[o])) return !1;return !0;
            }return e === i;
        }var i = o;function o(e) {
            return !function (e) {
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () {
                    if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;var e,
                        t,
                        i = new Blob([""], { type: "text/javascript" }),
                        o = URL.createObjectURL(i);try {
                        t = new Worker(o), e = !0;
                    } catch (t) {
                        e = !1;
                    }return t && t.terminate(), URL.revokeObjectURL(o), e;
                }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () {
                    var e = document.createElement("canvas");e.width = e.height = 1;var t = e.getContext("2d");if (!t) return !1;var i = t.getImageData(0, 0, 1, 1);return i && i.width === e.width;
                }() ? (void 0 === r[t = e && e.failIfMajorPerformanceCaveat] && (r[t] = function (e) {
                    var t,
                        i = function (e) {
                        var t = document.createElement("canvas"),
                            i = Object.create(o.webGLContextAttributes);return i.failIfMajorPerformanceCaveat = e, t.getContext("webgl", i) || t.getContext("experimental-webgl", i);
                    }(e);if (!i) return !1;try {
                        t = i.createShader(i.VERTEX_SHADER);
                    } catch (e) {
                        return !1;
                    }return !(!t || i.isContextLost()) && (i.shaderSource(t, "void main() {}"), i.compileShader(t), !0 === i.getShaderParameter(t, i.COMPILE_STATUS));
                }(t)), r[t] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";var t;
            }(e);
        }var r = {};function n(t, i, o) {
            const r = e.window.document.createElement(t);return void 0 !== i && (r.className = i), o && o.appendChild(r), r;
        }function s(t, i, o) {
            const r = e.window.document.createElementNS("http://www.w3.org/2000/svg", t);for (const e of Object.keys(i)) r.setAttributeNS(null, e, i[e]);return o && o.appendChild(r), r;
        }o.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };const a = e.window.document && e.window.document.documentElement.style,
              l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";let c;function h() {
            a && l && (c = a[l], a[l] = "none");
        }function u() {
            a && l && (a[l] = c);
        }function _(t) {
            t.preventDefault(), t.stopPropagation(), e.window.removeEventListener("click", _, !0);
        }function d() {
            e.window.addEventListener("click", _, !0), e.window.setTimeout(() => {
                e.window.removeEventListener("click", _, !0);
            }, 0);
        }function p(e, t) {
            const i = e.getBoundingClientRect();return g(e, i, t);
        }function m(e, t) {
            const i = e.getBoundingClientRect(),
                  o = [];for (let r = 0; r < t.length; r++) o.push(g(e, i, t[r]));return o;
        }function f(t) {
            return void 0 !== e.window.InstallTrigger && 2 === t.button && t.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t.button;
        }function g(t, i, o) {
            const r = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;return new e.pointGeometry((o.clientX - i.left) * r, (o.clientY - i.top) * r);
        }function v(e, t) {
            var i = t[0],
                o = t[1],
                r = t[2],
                n = t[3],
                s = i * n - r * o;return s ? (e[0] = n * (s = 1 / s), e[1] = -o * s, e[2] = -r * s, e[3] = i * s, e) : null;
        }function x(e) {
            const { userImage: t } = e;return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);
        }class y extends e.Evented {
            constructor() {
                super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
            }isLoaded() {
                return this.loaded;
            }setLoaded(e) {
                if (this.loaded !== e && (this.loaded = e, e)) {
                    for (const { ids: e, callback: t } of this.requestors) this._notify(e, t);this.requestors = [];
                }
            }hasImage(e) {
                return !!this.getImage(e);
            }getImage(e) {
                return this.images[e];
            }addImage(e, t) {
                this._validate(e, t) && (this.images[e] = t);
            }_validate(t, i) {
                let o = !0;return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))), o = !1), o;
            }_validateStretch(e, t) {
                if (!e) return !0;let i = 0;for (const o of e) {
                    if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;i = o[1];
                }return !0;
            }_validateContent(e, t) {
                return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));
            }updateImage(e, t) {
                t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0;
            }removeImage(e) {
                const t = this.images[e];delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();
            }listImages() {
                return Object.keys(this.images);
            }getImages(e, t) {
                let i = !0;if (!this.isLoaded()) for (const t of e) this.images[t] || (i = !1);this.isLoaded() || i ? this._notify(e, t) : this.requestors.push({ ids: e, callback: t });
            }_notify(t, i) {
                const o = {};for (const i of t) {
                    this.images[i] || this.fire(new e.Event("styleimagemissing", { id: i }));const t = this.images[i];t ? o[i] = { data: t.data.clone(), pixelRatio: t.pixelRatio, sdf: t.sdf, version: t.version, stretchX: t.stretchX, stretchY: t.stretchY, content: t.content, hasRenderCallback: Boolean(t.userImage && t.userImage.render) } : e.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }i(null, o);
            }getPixelSize() {
                const { width: e, height: t } = this.atlasImage;return { width: e, height: t };
            }getPattern(t) {
                const i = this.patterns[t],
                      o = this.getImage(t);if (!o) return null;if (i && i.position.version === o.version) return i.position;if (i) i.position.version = o.version;else {
                    const i = { w: o.data.width + 2, h: o.data.height + 2, x: 0, y: 0 },
                          r = new e.ImagePosition(i, o);this.patterns[t] = { bin: i, position: r };
                }return this._updatePatternAtlas(), this.patterns[t].position;
            }bind(t) {
                const i = t.gl;this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e.Texture(t, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
            }_updatePatternAtlas() {
                const t = [];for (const e in this.patterns) t.push(this.patterns[e].bin);const { w: i, h: o } = e.potpack(t),
                      r = this.atlasImage;r.resize({ width: i || 1, height: o || 1 });for (const t in this.patterns) {
                    const { bin: i } = this.patterns[t],
                          o = i.x + 1,
                          n = i.y + 1,
                          s = this.images[t].data,
                          a = s.width,
                          l = s.height;e.RGBAImage.copy(s, r, { x: 0, y: 0 }, { x: o, y: n }, { width: a, height: l }), e.RGBAImage.copy(s, r, { x: 0, y: l - 1 }, { x: o, y: n - 1 }, { width: a, height: 1 }), e.RGBAImage.copy(s, r, { x: 0, y: 0 }, { x: o, y: n + l }, { width: a, height: 1 }), e.RGBAImage.copy(s, r, { x: a - 1, y: 0 }, { x: o - 1, y: n }, { width: 1, height: l }), e.RGBAImage.copy(s, r, { x: 0, y: 0 }, { x: o + a, y: n }, { width: 1, height: l });
                }this.dirty = !0;
            }beginFrame() {
                this.callbackDispatchedThisFrame = {};
            }dispatchRenderCallbacks(e) {
                for (const t of e) {
                    if (this.callbackDispatchedThisFrame[t]) continue;this.callbackDispatchedThisFrame[t] = !0;const e = this.images[t];x(e) && this.updateImage(t, e);
                }
            }
        }const b = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class {
                constructor() {
                    this.specification = e.spec.light.position;
                }possiblyEvaluate(t, i) {
                    return function ([t, i, o]) {
                        const r = e.degToRad(i + 90),
                              n = e.degToRad(o);return { x: t * Math.cos(r) * Math.sin(n), y: t * Math.sin(r) * Math.sin(n), z: t * Math.cos(n), azimuthal: i, polar: o };
                    }(t.expression.evaluate(i));
                }interpolate(t, i, o) {
                    return { x: e.number(t.x, i.x, o), y: e.number(t.y, i.y, o), z: e.number(t.z, i.z, o), azimuthal: e.number(t.azimuthal, i.azimuthal, o), polar: e.number(t.polar, i.polar, o) };
                }
            }(), color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) }),
              w = "-transition";class T extends e.Evented {
            constructor(t) {
                super(), this._transitionable = new e.Transitionable(b), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
            }getLight() {
                return this._transitionable.serialize();
            }setLight(t, i = {}) {
                if (!this._validate(e.validateLight, t, i)) for (const i in t) {
                    const o = t[i];e.endsWith(i, w) ? this._transitionable.setTransition(i.slice(0, -w.length), o) : this._transitionable.setValue(i, o);
                }
            }updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }hasTransition() {
                return this._transitioning.hasTransition();
            }recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }_validate(t, i, o) {
                return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: e.spec })));
            }
        }const E = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) }),
              C = "-transition";class M extends e.Evented {
            constructor(t, i) {
                super(), this._transitionable = new e.Transitionable(E), this.set(t), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;
            }get() {
                return this._transitionable.serialize();
            }set(t) {
                for (const i in t) {
                    const o = t[i];e.endsWith(i, C) ? this._transitionable.setTransition(i.slice(0, -C.length), o) : this._transitionable.setValue(i, o);
                }
            }updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }hasTransition() {
                return this._transitioning.hasTransition();
            }recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
        }function I(t, i, o, r) {
            const n = e.smoothstep(45, 65, o),
                  [s, a] = S(t, r),
                  l = e.length(i);let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));return c *= c * c, c = Math.min(1, 1.00747 * c), c * n * t.alpha;
        }function S(e, t) {
            const i = .5 / Math.tan(.5 * t);return [e.range[0] + i, e.range[1] + i];
        }const D = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]), "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]), "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"]) }),
              L = "-transition";class A extends e.Evented {
            constructor(t, i) {
                super(), this._transitionable = new e.Transitionable(D), this.set(t), this._transitioning = this._transitionable.untransitioned(), this._transform = i;
            }get state() {
                const t = this._transform,
                      i = "globe" === t.projection.name,
                      o = e.globeToMercatorTransition(t.zoom),
                      r = this.properties.get("range"),
                      n = [.5, 3];return { range: i ? [e.number(n[0], r[0], o), e.number(n[1], r[1], o)] : r, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
            }get() {
                return this._transitionable.serialize();
            }set(t, i = {}) {
                if (!this._validate(e.validateFog, t, i)) {
                    for (const i of Object.keys(e.spec.fog)) t && void 0 === t[i] && (t[i] = e.spec.fog[i].default);for (const i in t) {
                        const o = t[i];e.endsWith(i, L) ? this._transitionable.setTransition(i.slice(0, -L.length), o) : this._transitionable.setValue(i, o);
                    }
                }
            }getOpacity(t) {
                if (!this._transform.projection.supportsFog) return 0;const i = this.properties && this.properties.get("color") || 1;return ("globe" === this._transform.projection.name ? 1 : e.smoothstep(45, 65, t)) * i.a;
            }getOpacityAtLatLng(t, i) {
                return this._transform.projection.supportsFog ? function (t, i, o) {
                    const r = e.MercatorCoordinate.fromLngLat(i),
                          n = o.elevation ? o.elevation.getAtPointOrZero(r) : 0,
                          s = [r.x, r.y, n];return e.transformMat4(s, s, o.mercatorFogMatrix), I(t, s, o.pitch, o._fov);
                }(this.state, t, i) : 0;
            }getFovAdjustedRange(e) {
                return this._transform.projection.supportsFog ? S(this.state, e) : [0, 1];
            }updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }hasTransition() {
                return this._transitioning.hasTransition();
            }recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }_validate(t, i, o) {
                return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: e.spec })));
            }
        }class z {
            constructor(t, i) {
                this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();const o = this.workerPool.acquire(this.id);for (let e = 0; e < o.length; e++) {
                    const t = new z.Actor(o[e], i, this.id);t.name = `Worker ${e}`, this.actors.push(t);
                }this.ready = !1, this.broadcast("checkIfReady", null, () => {
                    this.ready = !0;
                });
            }broadcast(t, i, o) {
                e.asyncAll(this.actors, (e, o) => {
                    e.send(t, i, o);
                }, o = o || function () {});
            }getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }remove() {
                this.actors.forEach(e => {
                    e.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }function P(t, i, o) {
            return i * (e.EXTENT / (t.tileSize * Math.pow(2, o - t.tileID.overscaledZ)));
        }z.Actor = e.Actor;class R {
            constructor(e, t, i, o) {
                this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);
            }static createFromScreenPoints(t, i) {
                let o, r;if (t instanceof e.pointGeometry || "number" == typeof t[0]) {
                    const n = e.pointGeometry.convert(t);o = [n], r = i.isPointAboveHorizon(n);
                } else {
                    const n = e.pointGeometry.convert(t[0]),
                          s = e.pointGeometry.convert(t[1]);o = [n, s], r = e.polygonizeBounds(n, s).every(e => i.isPointAboveHorizon(e));
                }return new R(o, i.getCameraPoint(), r, i);
            }isPointQuery() {
                return 1 === this.screenBounds.length;
            }bufferedScreenGeometry(t) {
                return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);
            }bufferedCameraGeometry(t) {
                const i = this.screenBounds[0],
                      o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1],
                      r = e.polygonizeBounds(i, o, 0, !1);return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e.bufferConvexPolygon(r, t);
            }bufferedCameraGeometryGlobe(t) {
                const i = this.screenBounds[0],
                      o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1],
                      r = e.polygonizeBounds(i, o, t),
                      n = this.cameraPoint.clone();switch (3 * ((n.y > i.y) + (n.y > o.y)) + ((n.x > i.x) + (n.x > o.x))) {case 0:
                        r[0] = n, r[4] = n.clone();break;case 1:
                        r.splice(1, 0, n);break;case 2:
                        r[1] = n;break;case 3:
                        r.splice(4, 0, n);break;case 5:
                        r.splice(2, 0, n);break;case 6:
                        r[3] = n;break;case 7:
                        r.splice(3, 0, n);break;case 8:
                        r[2] = n;}return r;
            }containsTile(t, i, o, r = 0) {
                const n = t.queryPadding / i._pixelsPerMercatorPixel + 1,
                      s = o ? this._bufferedCameraMercator(n, i) : this._bufferedScreenMercator(n, i);let a = t.tileID.wrap + (s.unwrapped ? r : 0);const l = s.polygon.map(i => e.getTilePoint(t.tileTransform, i, a));if (!e.polygonIntersectsBox(l, 0, 0, e.EXTENT, e.EXTENT)) return;a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);const c = this.screenGeometryMercator.polygon.map(i => e.getTileVec3(t.tileTransform, i, a)),
                      h = c.map(t => new e.pointGeometry(t[0], t[1])),
                      u = i.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0),
                      _ = e.getTileVec3(t.tileTransform, u, a),
                      d = c.map(t => {
                    const i = e.sub(t, t, _);return e.normalize(i, i), new e.Ray(_, i);
                }),
                      p = P(t, 1, i.zoom) * i._pixelsPerMercatorPixel;return { queryGeometry: this, tilespaceGeometry: h, tilespaceRays: d, bufferedTilespaceGeometry: l, bufferedTilespaceBounds: (m = e.getBounds(l), m.min.x = e.clamp(m.min.x, 0, e.EXTENT), m.min.y = e.clamp(m.min.y, 0, e.EXTENT), m.max.x = e.clamp(m.max.x, 0, e.EXTENT), m.max.y = e.clamp(m.max.y, 0, e.EXTENT), m), tile: t, tileID: t.tileID, pixelToTileUnitsFactor: p };var m;
            }_bufferedScreenMercator(e, t) {
                const i = k(e);if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];{
                    let o;return o = "globe" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : { polygon: this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e)), unwrapped: !0 }, this._screenRaycastCache[i] = o, o;
                }
            }_bufferedCameraMercator(e, t) {
                const i = k(e);if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];{
                    let o;return o = "globe" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : { polygon: this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e)), unwrapped: !0 }, this._cameraRaycastCache[i] = o, o;
                }
            }_projectAndResample(t, i) {
                const o = function (t, i) {
                    const o = e.multiply([], i.pixelMatrix, i.globeMatrix),
                          r = [0, -e.GLOBE_RADIUS, 0, 1],
                          n = [0, e.GLOBE_RADIUS, 0, 1],
                          s = [0, 0, 0, 1];e.transformMat4$1(r, r, o), e.transformMat4$1(n, n, o), e.transformMat4$1(s, s, o);const a = new e.pointGeometry(r[0] / r[3], r[1] / r[3]),
                          l = new e.pointGeometry(n[0] / n[3], n[1] / n[3]),
                          c = e.polygonContainsPoint(t, a) && r[3] < s[3],
                          h = e.polygonContainsPoint(t, l) && n[3] < s[3];if (!c && !h) return null;const u = function (e, t, i) {
                        for (let o = 1; o < e.length; o++) {
                            const r = B(t.pointCoordinate3D(e[o - 1]).x),
                                  n = B(t.pointCoordinate3D(e[o]).x);if (i < 0) {
                                if (r < n) return { idx: o, t: -r / (n - 1 - r) };
                            } else if (n < r) return { idx: o, t: (1 - r) / (n + 1 - r) };
                        }return null;
                    }(t, i, c ? -1 : 1);if (!u) return null;const { idx: _, t: d } = u;let p = _ > 1 ? O(t.slice(0, _), i) : [],
                        m = _ < t.length ? O(t.slice(_), i) : [];p = p.map(t => new e.pointGeometry(B(t.x), t.y)), m = m.map(t => new e.pointGeometry(B(t.x), t.y));const f = [...p];0 === f.length && f.push(m[m.length - 1]);const g = e.number(f[f.length - 1].y, (0 === m.length ? p[0] : m[0]).y, d);let v;return v = c ? [new e.pointGeometry(0, g), new e.pointGeometry(0, 0), new e.pointGeometry(1, 0), new e.pointGeometry(1, g)] : [new e.pointGeometry(1, g), new e.pointGeometry(1, 1), new e.pointGeometry(0, 1), new e.pointGeometry(0, g)], f.push(...v), 0 === m.length ? f.push(p[0]) : f.push(...m), { polygon: f.map(t => new e.MercatorCoordinate(t.x, t.y)), unwrapped: !1 };
                }(t, i);if (o) return o;const r = function (t, i) {
                    let o = !1,
                        r = -1 / 0,
                        n = 0;for (let e = 0; e < t.length - 1; e++) t[e].x > r && (r = t[e].x, n = e);for (let e = 0; e < t.length - 1; e++) {
                        const i = (n + e) % (t.length - 1),
                              r = t[i],
                              s = t[i + 1];Math.abs(r.x - s.x) > .5 && (r.x < s.x ? (r.x += 1, 0 === i && (t[t.length - 1].x += 1)) : (s.x += 1, i + 1 === t.length - 1 && (t[0].x += 1)), o = !0);
                    }const s = e.mercatorXfromLng(i.center.lng);return o && s < Math.abs(s - 1) && t.forEach(e => {
                        e.x -= 1;
                    }), { polygon: t, unwrapped: o };
                }(O(t, i).map(t => new e.pointGeometry(B(t.x), t.y)), i);return { polygon: r.polygon.map(t => new e.MercatorCoordinate(t.x, t.y)), unwrapped: r.unwrapped };
            }
        }function O(t, i) {
            return e.resample(t, e => {
                const t = i.pointCoordinate3D(e);e.x = t.x, e.y = t.y;
            }, 1 / 256);
        }function B(e) {
            return e < 0 ? 1 + e % 1 : e % 1;
        }function k(e) {
            return 100 * e | 0;
        }function F(t, i, o, r, n) {
            const s = function (o, r) {
                if (o) return n(o);if (r) {
                    t.url && r.tiles && t.tiles && delete t.tiles;const o = e.pick(e.extend(r, t), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);r.vector_layers && (o.vectorLayers = r.vector_layers, o.vectorLayerIds = o.vectorLayers.map(e => e.id)), o.tiles = i.canonicalizeTileset(o, t.url), n(null, o);
                }
            };return t.url ? e.getJSON(i.transformRequest(i.normalizeSourceURL(t.url, null, o, r), e.ResourceType.Source), s) : e.exported.frame(() => s(null, t));
        }class U {
            constructor(t, i, o) {
                this.bounds = e.LngLatBounds.convert(this.validateBounds(t)), this.minzoom = i || 0, this.maxzoom = o || 24;
            }validateBounds(e) {
                return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
            }contains(t) {
                const i = Math.pow(2, t.z),
                      o = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i),
                      r = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i),
                      n = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i),
                      s = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i);return t.x >= o && t.x < n && t.y >= r && t.y < s;
            }
        }class N {
            constructor(e, t, i) {
                this.context = e;const o = e.gl;this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || t.destroy();
            }bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }updateData(e) {
                const t = this.context.gl;this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
            }destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }const G = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };class j {
            constructor(e, t, i, o) {
                this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.context = e;const r = e.gl;this.buffer = r.createBuffer(), e.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t.destroy();
            }bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }updateData(e) {
                const t = this.context.gl;this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);
            }enableAttributes(e, t) {
                for (let i = 0; i < this.attributes.length; i++) {
                    const o = t.attributes[this.attributes[i].name];void 0 !== o && e.enableVertexAttribArray(o);
                }
            }setVertexAttribPointers(e, t, i) {
                for (let o = 0; o < this.attributes.length; o++) {
                    const r = this.attributes[o],
                          n = t.attributes[r.name];void 0 !== n && e.vertexAttribPointer(n, r.components, e[G[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));
                }
            }destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }class Z {
            constructor(e) {
                this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }get() {
                return this.current;
            }set(e) {}getDefault() {
                return this.default;
            }setDefault() {
                this.set(this.default);
            }
        }class V extends Z {
            getDefault() {
                return e.Color.transparent;
            }set(e) {
                const t = this.current;(e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }class W extends Z {
            getDefault() {
                return 1;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
            }
        }class X extends Z {
            getDefault() {
                return 0;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
            }
        }class q extends Z {
            getDefault() {
                return [!0, !0, !0, !0];
            }set(e) {
                const t = this.current;(e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }class $ extends Z {
            getDefault() {
                return !0;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
            }
        }class H extends Z {
            getDefault() {
                return 255;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
            }
        }class Y extends Z {
            getDefault() {
                return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }set(e) {
                const t = this.current;(e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
            }
        }class K extends Z {
            getDefault() {
                const e = this.gl;return [e.KEEP, e.KEEP, e.KEEP];
            }set(e) {
                const t = this.current;(e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
            }
        }class J extends Z {
            getDefault() {
                return !1;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;
            }
        }class Q extends Z {
            getDefault() {
                return [0, 1];
            }set(e) {
                const t = this.current;(e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }class ee extends Z {
            getDefault() {
                return !1;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;
            }
        }class te extends Z {
            getDefault() {
                return this.gl.LESS;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
            }
        }class ie extends Z {
            getDefault() {
                return !1;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;
            }
        }class oe extends Z {
            getDefault() {
                const e = this.gl;return [e.ONE, e.ZERO];
            }set(e) {
                const t = this.current;(e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }class re extends Z {
            getDefault() {
                return e.Color.transparent;
            }set(e) {
                const t = this.current;(e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }class ne extends Z {
            getDefault() {
                return this.gl.FUNC_ADD;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
            }
        }class se extends Z {
            getDefault() {
                return !1;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;
            }
        }class ae extends Z {
            getDefault() {
                return this.gl.BACK;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
            }
        }class le extends Z {
            getDefault() {
                return this.gl.CCW;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
            }
        }class ce extends Z {
            getDefault() {
                return null;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
            }
        }class he extends Z {
            getDefault() {
                return this.gl.TEXTURE0;
            }set(e) {
                (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
            }
        }class ue extends Z {
            getDefault() {
                const e = this.gl;return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
            }set(e) {
                const t = this.current;(e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }class _e extends Z {
            getDefault() {
                return null;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
            }
        }class de extends Z {
            getDefault() {
                return null;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }class pe extends Z {
            getDefault() {
                return null;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;
            }
        }class me extends Z {
            getDefault() {
                return null;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }class fe extends Z {
            getDefault() {
                return null;
            }set(e) {
                const t = this.gl;t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }class ge extends Z {
            constructor(e) {
                super(e), this.vao = e.extVertexArrayObject;
            }getDefault() {
                return null;
            }set(e) {
                this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1);
            }
        }class ve extends Z {
            getDefault() {
                return 4;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
            }
        }class xe extends Z {
            getDefault() {
                return !1;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }class ye extends Z {
            getDefault() {
                return !1;
            }set(e) {
                if (e === this.current && !this.dirty) return;const t = this.gl;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }class be extends Z {
            constructor(e, t) {
                super(e), this.context = e, this.parent = t;
            }getDefault() {
                return null;
            }
        }class we extends be {
            setDirty() {
                this.dirty = !0;
            }set(e) {
                if (e === this.current && !this.dirty) return;this.context.bindFramebuffer.set(this.parent);const t = this.gl;t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }class Te extends be {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }set(e) {
                if (e === this.current && !this.dirty) return;this.context.bindFramebuffer.set(this.parent);const t = this.gl;t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }class Ee extends Te {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }class Ce {
            constructor(e, t, i, o) {
                this.context = e, this.width = t, this.height = i;const r = this.framebuffer = e.gl.createFramebuffer();this.colorAttachment = new we(e, r), o && (this.depthAttachment = new Te(e, r));
            }destroy() {
                const e = this.context.gl,
                      t = this.colorAttachment.get();if (t && e.deleteTexture(t), this.depthAttachment) {
                    const t = this.depthAttachment.get();t && e.deleteRenderbuffer(t);
                }e.deleteFramebuffer(this.framebuffer);
            }
        }class Me {
            constructor(e, t = !1) {
                if (this.gl = e, this.isWebGL2 = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t) {
                    const t = e;this.extVertexArrayObject = { createVertexArrayOES: t.createVertexArray.bind(e), deleteVertexArrayOES: t.deleteVertexArray.bind(e), bindVertexArrayOES: t.bindVertexArray.bind(e) };
                }this.clearColor = new V(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new $(this), this.stencilMask = new H(this), this.stencilFunc = new Y(this), this.stencilOp = new K(this), this.stencilTest = new J(this), this.depthRange = new Q(this), this.depthTest = new ee(this), this.depthFunc = new te(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new re(this), this.blendEquation = new ne(this), this.cullFace = new se(this), this.cullFaceSide = new ae(this), this.frontFace = new le(this), this.program = new ce(this), this.activeTexture = new he(this), this.viewport = new ue(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de(this), this.bindTexture = new pe(this), this.bindVertexBuffer = new me(this), this.bindElementBuffer = new fe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge(this), this.pixelStoreUnpack = new ve(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = e.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t || (this.extTextureHalfFloat = e.getExtension("OES_texture_half_float")), (t || this.extTextureHalfFloat && e.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t || e.getExtension("OES_standard_derivatives"), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE);
            }setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }createIndexBuffer(e, t) {
                return new N(this, e, t);
            }createVertexBuffer(e, t, i) {
                return new j(this, e, t, i);
            }createRenderbuffer(e, t, i) {
                const o = this.gl,
                      r = o.createRenderbuffer();return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), r;
            }createFramebuffer(e, t, i) {
                return new Ce(this, e, t, i);
            }clear({ color: e, depth: t, stencil: i }) {
                const o = this.gl;let r = 0;e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (r |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o.clear(r);
            }setCullFace(e) {
                !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
            }setDepthMode(e) {
                e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
            }setStencilMode(e) {
                e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
            }setColorMode(i) {
                t(i.blendFunction, e.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(i.blendFunction), this.blendColor.set(i.blendColor)), this.colorMask.set(i.mask);
            }unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
        }class Ie extends e.Evented {
            constructor(t, i, o, r) {
                if (super(), this.id = t, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.extend(this, e.pick(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
            }load(t) {
                this._loaded = !1, this.fire(new e.Event("dataloading", { dataType: "source" }));const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,
                      o = this.map._worldview;this._tileJSONRequest = F(this._options, this.map._requestManager, i, o, (r, n) => {
                    this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.ErrorEvent(r))) : n && (e.extend(this, n), n.bounds && (this.tileBounds = new U(n.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t && t(r);
                });
            }loaded() {
                return this._loaded;
            }hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }onAdd(e) {
                this.map = e, this.load();
            }reload() {
                this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
            }setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }onRemove() {
                this.cancelTileJSONRequest();
            }serialize() {
                return e.extend({}, this._options);
            }loadTile(t, i) {
                const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),
                      r = { request: this.map._requestManager.transformRequest(o, e.ResourceType.Tile), data: void 0, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t.isSymbolTile };if (r.request.collectResourceTiming = this._collectResourceTiming, t.actor && "expired" !== t.state) "loading" === t.state ? t.reloadCallback = i : t.request = t.actor.send("reloadTile", r, n.bind(this));else if (t.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", r, n.bind(this), void 0, !0);else {
                    const i = e.loadVectorTile.call({ deduped: this._deduped }, r, (e, i) => {
                        e || !i ? n.call(this, e) : (r.data = { cacheControl: i.cacheControl, expires: i.expires, rawData: i.rawData.slice(0) }, t.actor && t.actor.send("loadTile", r, n.bind(this), void 0, !0));
                    }, !0);t.request = { cancel: i };
                }function n(o, r) {
                    return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
                }
            }abortTile(e) {
                e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", { uid: e.uid, type: this.type, source: this.id });
            }unloadTile(e) {
                e.unloadVectorData(), e.actor && e.actor.send("removeTile", { uid: e.uid, type: this.type, source: this.id });
            }hasTransition() {
                return !1;
            }afterUpdate() {
                this._tileWorkers = {};
            }cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }class Se extends e.Evented {
            constructor(t, i, o, r) {
                super(), this.id = t, this.dispatcher = o, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.extend({ type: "raster" }, i), e.extend(this, e.pick(i, ["url", "scheme", "tileSize"]));
            }load(t) {
                this._loaded = !1, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, (i, o) => {
                    this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.ErrorEvent(i)) : o && (e.extend(this, o), o.bounds && (this.tileBounds = new U(o.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t && t(i);
                });
            }loaded() {
                return this._loaded;
            }onAdd(e) {
                this.map = e, this.load();
            }reload() {
                this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
            }setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }onRemove() {
                this.cancelTileJSONRequest();
            }serialize() {
                return e.extend({}, this._options);
            }hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }loadTile(t, i) {
                const o = e.exported.devicePixelRatio >= 2,
                      r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);t.request = e.getImage(this.map._requestManager.transformRequest(r, e.ResourceType.Tile), (o, r, n, s) => (delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : o ? (t.state = "errored", i(o)) : r ? (this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: n, expires: s }), t.setTexture(r, this.map.painter), t.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null)));
            }static loadTileData(e, t, i) {
                e.setTexture(t, i);
            }static unloadTileData(e, t) {
                e.texture && t.saveTileTexture(e.texture);
            }abortTile(e, t) {
                e.request && (e.request.cancel(), delete e.request), t();
            }unloadTile(e, t) {
                e.texture && this.map.painter.saveTileTexture(e.texture), t();
            }hasTransition() {
                return !1;
            }cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }let De;function Le(t, i, o, r, n, s, a, l) {
            const c = [t, o, n, i, r, s, 1, 1, 1],
                  h = [a, l, 1],
                  u = e.adjoint([], c),
                  [_, d, p] = e.transformMat3(h, h, e.transpose(u, u));return e.multiply$1(c, [_, 0, 0, 0, d, 0, 0, 0, p], c);
        }class Ae extends e.Evented {
            constructor(e, t, i, o) {
                super(), this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = t, this._dirty = !1;
            }load(t, i) {
                this._loaded = i || !1, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i, o) => {
                    if (this._imageRequest = null, this._loaded = !0, i) this.fire(new e.ErrorEvent(i));else if (o) {
                        const { HTMLImageElement: i } = e.window;this.image = o instanceof i ? e.exported.getImageData(o) : o, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading();
                    }
                });
            }loaded() {
                return this._loaded;
            }updateImage(e) {
                return this.image && e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;
            }_finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }onAdd(e) {
                this.map = e, this.load();
            }onRemove() {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
            }setCoordinates(t) {
                this.coordinates = t, this._boundsArray = void 0;const i = t.map(e.MercatorCoordinate.fromLngLat);return this.tileID = function (t) {
                    let i = 1 / 0,
                        o = 1 / 0,
                        r = -1 / 0,
                        n = -1 / 0;for (const e of t) i = Math.min(i, e.x), o = Math.min(o, e.y), r = Math.max(r, e.x), n = Math.max(n, e.y);const s = Math.max(r - i, n - o),
                          a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)),
                          l = Math.pow(2, a);return new e.CanonicalTileID(a, Math.floor((i + r) / 2 * l), Math.floor((o + n) / 2 * l));
                }(i), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }_clear() {
                this._boundsArray = void 0;
            }_prepareData(t) {
                for (const e in this.tiles) {
                    const t = this.tiles[e];"loaded" !== t.state && (t.state = "loaded", t.texture = this.texture);
                }if (this._boundsArray) return;const i = e.tileTransform(this.tileID, this.map.transform.projection),
                      [o, r, n, s] = this.coordinates.map(t => {
                    const o = i.projection.project(t[0], t[1]);return e.getTilePoint(i, o)._round();
                });this.perspectiveTransform = function (t, i, o, r, n, s, a, l, c, h) {
                    const u = Le(0, 0, t, 0, 0, i, t, i),
                          _ = Le(o, r, n, s, a, l, c, h);return e.multiply$1(_, e.adjoint(u, u), _), [_[6] / _[8] * t / e.EXTENT, _[7] / _[8] * i / e.EXTENT];
                }(this.width, this.height, o.x, o.y, r.x, r.y, s.x, s.y, n.x, n.y);const a = this._boundsArray = new e.StructArrayLayout4i8();a.emplaceBack(o.x, o.y, 0, 0), a.emplaceBack(r.x, r.y, e.EXTENT, 0), a.emplaceBack(s.x, s.y, 0, e.EXTENT), a.emplaceBack(n.x, n.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t.createVertexBuffer(a, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            }prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;const t = this.map.painter.context,
                      i = t.gl;this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(t);
            }loadTile(e, t) {
                this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = "errored", t(null));
            }serialize() {
                return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }hasTransition() {
                return !1;
            }
        }const ze = { vector: Ie, raster: Se, "raster-dem": class extends Se {
                constructor(t, i, o, r) {
                    super(t, i, o, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, i), this.encoding = i.encoding || "mapbox";
                }loadTile(t, i) {
                    const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);function r(e, o) {
                        e && (t.state = "errored", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = "loaded", i(null));
                    }t.request = e.getImage(this.map._requestManager.transformRequest(o, e.ResourceType.Tile), function (o, n, s, a) {
                        if (delete t.request, t.aborted) t.state = "unloaded", i(null);else if (o) t.state = "errored", i(o);else if (n) {
                            this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: s, expires: a });const i = e.window.ImageBitmap && n instanceof e.window.ImageBitmap && (null == De && (De = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), De),
                                  o = 1 - (n.width - e.prevPowerOfTwo(n.width)) / 2;o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));const l = i ? n : e.exported.getImageData(n, o),
                                  c = { uid: t.uid, coord: t.tileID, source: this.id, rawImageData: l, encoding: this.encoding, padding: o };t.actor && "expired" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send("loadDEMTile", c, r.bind(this), void 0, !0));
                        }
                    }.bind(this));
                }_getNeighboringTiles(t) {
                    const i = t.canonical,
                          o = Math.pow(2, i.z),
                          r = (i.x - 1 + o) % o,
                          n = 0 === i.x ? t.wrap - 1 : t.wrap,
                          s = (i.x + 1 + o) % o,
                          a = i.x + 1 === o ? t.wrap + 1 : t.wrap,
                          l = {};return l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y).key] = { backfilled: !1 }, i.y > 0 && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y - 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y - 1).key] = { backfilled: !1 }), i.y + 1 < o && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y + 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = { backfilled: !1 }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y + 1).key] = { backfilled: !1 }), l;
                }unloadTile(e) {
                    e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded";
                }
            }, geojson: class extends e.Evented {
                constructor(t, i, o, r) {
                    super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;const n = e.EXTENT / this.tileSize;this.workerOptions = e.extend({ source: this.id, cluster: i.cluster || !1, geojsonVtOptions: { buffer: (void 0 !== i.buffer ? i.buffer : 128) * n, tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: i.lineMetrics || !1, generateId: i.generateId || !1 }, superclusterOptions: { maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i.clusterMinPoints || 2), extent: e.EXTENT, radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n, log: !1, generateId: i.generateId || !1 }, clusterProperties: i.clusterProperties, filter: i.filter }, i.workerOptions);
                }onAdd(e) {
                    this.map = e, this.setData(this._data);
                }setData(e) {
                    return this._data = e, this._updateWorkerData(), this;
                }getClusterExpansionZoom(e, t) {
                    return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e, source: this.id }, t), this;
                }getClusterChildren(e, t) {
                    return this.actor.send("geojson.getClusterChildren", { clusterId: e, source: this.id }, t), this;
                }getClusterLeaves(e, t, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e, limit: t, offset: i }, o), this;
                }_updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = !1;const t = e.extend({}, this.workerOptions),
                          i = this._data;"string" == typeof i ? (t.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i), e.ResourceType.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (t, i) => {
                        if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.ErrorEvent(t));else {
                            const t = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t.resourceTiming = i.resourceTiming[this.id]), this.fire(new e.Event("data", t)), this._metadataFired = !0;
                        }this._coalesce && (this._updateWorkerData(), this._coalesce = !1);
                    });
                }loaded() {
                    return this._loaded;
                }loadTile(t, i) {
                    const o = t.actor ? "reloadTile" : "loadTile";t.actor = this.actor, t.request = this.actor.send(o, { type: this.type, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e, r) => (delete t.request, t.unloadVectorData(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(r, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
                }abortTile(e) {
                    e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
                }unloadTile(e) {
                    e.unloadVectorData(), this.actor.send("removeTile", { uid: e.uid, type: this.type, source: this.id });
                }onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                }serialize() {
                    return e.extend({}, this._options, { type: this.type, data: this._data });
                }hasTransition() {
                    return !1;
                }
            }, video: class extends Ae {
                constructor(e, t, i, o) {
                    super(e, t, i, o), this.roundZoom = !0, this.type = "video", this.options = t;
                }load() {
                    this._loaded = !1;const t = this.options;this.urls = [];for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.ResourceType.Source).url);e.getVideo(this.urls, (t, i) => {
                        this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }pause() {
                    this.video && this.video.pause();
                }play() {
                    this.video && this.video.play();
                }seek(t) {
                    if (this.video) {
                        const i = this.video.seekable;t < i.start(0) || t > i.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t;
                    }
                }getVideo() {
                    return this.video;
                }onAdd(e) {
                    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;const t = this.map.painter.context,
                          i = t.gl;this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);
                }serialize() {
                    return { type: "video", urls: this.urls, coordinates: this.coordinates };
                }hasTransition() {
                    return this.video && !this.video.paused;
                }
            }, image: Ae, canvas: class extends Ae {
                constructor(t, i, o, r) {
                    super(t, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => "number" != typeof e)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
                }load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function () {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }getCanvas() {
                    return this.canvas;
                }onAdd(e) {
                    this.map = e, this.load(), this.canvas && this.animate && this.play();
                }onRemove() {
                    this.pause();
                }prepare() {
                    let t = !1;if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;if (0 === Object.keys(this.tiles).length) return;const i = this.map.painter.context;this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new e.Texture(i, this.canvas, i.gl.RGBA, { premultiply: !0 }), this._prepareData(i);
                }serialize() {
                    return { type: "canvas", coordinates: this.coordinates };
                }hasTransition() {
                    return this._playing;
                }_hasInvalidDimensions() {
                    for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;return !1;
                }
            }, custom: class extends e.Evented {
                constructor(t, i, o, r) {
                    super(), this.id = t, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
                }serialize() {
                    return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
                }load() {
                    this._loaded = !0, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
                }loaded() {
                    return this._loaded;
                }onAdd(t) {
                    this._map = t, this._loaded = !1, this.fire(new e.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();
                }onRemove(e) {
                    this._implementation.onRemove && this._implementation.onRemove(e);
                }hasTile(e) {
                    if (this._implementation.hasTile) {
                        const { x: t, y: i, z: o } = e.canonical;return this._implementation.hasTile({ x: t, y: i, z: o });
                    }return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }loadTile(t, i) {
                    const { x: o, y: r, z: n } = t.tileID.canonical,
                          s = new e.window.AbortController();t.request = Promise.resolve(this._implementation.loadTile({ x: o, y: r, z: n }, { signal: s.signal })).then(function (o) {
                        return delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : void 0 === o ? (t.state = "errored", i(null)) : null === o ? (this.loadTileData(t, { width: this.tileSize, height: this.tileSize, data: null }), t.state = "loaded", i(null)) : function (t) {
                            return t instanceof e.window.ImageData || t instanceof e.window.HTMLCanvasElement || t instanceof e.window.ImageBitmap || t instanceof e.window.HTMLImageElement;
                        }(o) ? (this.loadTileData(t, o), t.state = "loaded", void i(null)) : (t.state = "errored", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }.bind(this)).catch(e => {
                        20 !== e.code && (t.state = "errored", i(e));
                    }), t.request.cancel = () => s.abort();
                }loadTileData(e, t) {
                    Se.loadTileData(e, t, this._map.painter);
                }unloadTileData(e) {
                    Se.unloadTileData(e, this._map.painter);
                }unloadTile(e, t) {
                    if (this.unloadTileData(e), this._implementation.unloadTile) {
                        const { x: t, y: i, z: o } = e.tileID.canonical;this._implementation.unloadTile({ x: t, y: i, z: o });
                    }t();
                }abortTile(e, t) {
                    e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();
                }hasTransition() {
                    return !1;
                }_coveringTiles() {
                    return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map(e => ({ x: e.canonical.x, y: e.canonical.y, z: e.canonical.z }));
                }_clearTiles() {
                    this._map.style._clearSource(this.id);
                }_update() {
                    this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
                }
            } },
              Pe = function (t, i, o, r) {
            const n = new ze[i.type](t, i, o, r);if (n.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${n.id}`);return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n), n;
        };function Re(t, i) {
            const o = e.identity([]);return e.scale(o, o, [.5 * t.width, .5 * -t.height, 1]), e.translate(o, o, [1, -1, 0]), e.multiply(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
        }function Oe(e, t, i, o, r, n, s, a = !1) {
            const l = e.tilesIn(o, s, a);l.sort(ke);const c = [];for (const o of l) c.push({ wrappedTileID: o.tile.tileID.wrapped().key, queryResults: o.tile.queryRenderedFeatures(t, i, e._state, o, r, n, Re(e.transform, o.tile.tileID), a) });const h = function (e) {
                const t = {},
                      i = {};for (const o of e) {
                    const e = o.queryResults,
                          r = o.wrappedTileID,
                          n = i[r] = i[r] || {};for (const i in e) {
                        const o = e[i],
                              r = n[i] = n[i] || {},
                              s = t[i] = t[i] || [];for (const e of o) r[e.featureIndex] || (r[e.featureIndex] = !0, s.push(e));
                    }
                }return t;
            }(c);for (const t in h) h[t].forEach(t => {
                const i = t.feature,
                      o = i.layer;o && "background" !== o.type && "sky" !== o.type && (i.source = o.source, o["source-layer"] && (i.sourceLayer = o["source-layer"]), i.state = void 0 !== i.id ? e.getFeatureState(o["source-layer"], i.id) : {});
            });return h;
        }function Be(e, t) {
            const i = e.getRenderableIds().map(t => e.getTileByID(t)),
                  o = [],
                  r = {};for (let e = 0; e < i.length; e++) {
                const n = i[e],
                      s = n.tileID.canonical.key;r[s] || (r[s] = !0, n.querySourceFeatures(o, t));
            }return o;
        }function ke(e, t) {
            const i = e.tileID,
                  o = t.tileID;return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }function Fe() {
            return null != fn.workerClass ? new fn.workerClass() : new e.window.Worker(fn.workerUrl);
        }const Ue = "mapboxgl_preloaded_worker_pool";class Ne {
            constructor() {
                this.active = {};
            }acquire(e) {
                if (!this.workers) for (this.workers = []; this.workers.length < Ne.workerCount;) this.workers.push(new Fe());return this.active[e] = !0, this.workers.slice();
            }release(e) {
                delete this.active[e], 0 === this.numActive() && (this.workers.forEach(e => {
                    e.terminate();
                }), this.workers = null);
            }isPreloaded() {
                return !!this.active[Ue];
            }numActive() {
                return Object.keys(this.active).length;
            }
        }let Ge;function je() {
            return Ge || (Ge = new Ne()), Ge;
        }function Ze(t, i) {
            const o = {};for (const e in t) "ref" !== e && (o[e] = t[e]);return e.refProperties.forEach(e => {
                e in i && (o[e] = i[e]);
            }), o;
        }function Ve(e) {
            e = e.slice();const t = Object.create(null);for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];for (let i = 0; i < e.length; i++) "ref" in e[i] && (e[i] = Ze(e[i], t[e[i].ref]));return e;
        }Ne.workerCount = 2;const We = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };function Xe(e, t, i) {
            i.push({ command: We.addSource, args: [e, t[e]] });
        }function qe(e, t, i) {
            t.push({ command: We.removeSource, args: [e] }), i[e] = !0;
        }function $e(e, t, i, o) {
            qe(e, i, o), Xe(e, t, i);
        }function He(e, i, o) {
            let r;for (r in e[o]) if (e[o].hasOwnProperty(r) && "data" !== r && !t(e[o][r], i[o][r])) return !1;for (r in i[o]) if (i[o].hasOwnProperty(r) && "data" !== r && !t(e[o][r], i[o][r])) return !1;return !0;
        }function Ye(e, i, o, r, n, s) {
            let a;for (a in i = i || {}, e = e || {}) e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({ command: s, args: [r, a, i[a], n] }));for (a in i) i.hasOwnProperty(a) && !e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({ command: s, args: [r, a, i[a], n] }));
        }function Ke(e) {
            return e.id;
        }function Je(e, t) {
            return e[t.id] = t, e;
        }class Qe {
            constructor(e, t) {
                this.reset(e, t);
            }reset(e, t) {
                this.points = e || [], this._distances = [0];for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }lerp(t) {
                if (1 === this.points.length) return this.points[0];t = e.clamp(t, 0, 1);let i = 1,
                    o = this._distances[i];const r = t * this.paddedLength + this.padding;for (; o < r && i < this._distances.length;) o = this._distances[++i];const n = i - 1,
                      s = this._distances[n],
                      a = o - s,
                      l = a > 0 ? (r - s) / a : 0;return this.points[n].mult(1 - l).add(this.points[i].mult(l));
            }
        }class et {
            constructor(e, t, i) {
                const o = this.boxCells = [],
                      r = this.circleCells = [];this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), r.push([]);this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;
            }keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }insert(e, t, i, o, r) {
                this._forEachCell(t, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
            }insertCircle(e, t, i, o) {
                this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);
            }_insertBoxCell(e, t, i, o, r, n) {
                this.boxCells[r].push(n);
            }_insertCircleCell(e, t, i, o, r, n) {
                this.circleCells[r].push(n);
            }_query(e, t, i, o, r, n) {
                if (i < 0 || e > this.width || o < 0 || t > this.height) return !r && [];const s = [];if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {
                    if (r) return !0;for (let e = 0; e < this.boxKeys.length; e++) s.push({ key: this.boxKeys[e], x1: this.bboxes[4 * e], y1: this.bboxes[4 * e + 1], x2: this.bboxes[4 * e + 2], y2: this.bboxes[4 * e + 3] });for (let e = 0; e < this.circleKeys.length; e++) {
                        const t = this.circles[3 * e],
                              i = this.circles[3 * e + 1],
                              o = this.circles[3 * e + 2];s.push({ key: this.circleKeys[e], x1: t - o, y1: i - o, x2: t + o, y2: i + o });
                    }return n ? s.filter(n) : s;
                }return this._forEachCell(e, t, i, o, this._queryCell, s, { hitTest: r, seenUids: { box: {}, circle: {} } }, n), r ? s.length > 0 : s;
            }_queryCircle(e, t, i, o, r) {
                const n = e - i,
                      s = e + i,
                      a = t - i,
                      l = t + i;if (s < 0 || n > this.width || l < 0 || a > this.height) return !o && [];const c = [];return this._forEachCell(n, a, s, l, this._queryCellCircle, c, { hitTest: o, circle: { x: e, y: t, radius: i }, seenUids: { box: {}, circle: {} } }, r), o ? c.length > 0 : c;
            }query(e, t, i, o, r) {
                return this._query(e, t, i, o, !1, r);
            }hitTest(e, t, i, o, r) {
                return this._query(e, t, i, o, !0, r);
            }hitTestCircle(e, t, i, o) {
                return this._queryCircle(e, t, i, !0, o);
            }_queryCell(e, t, i, o, r, n, s, a) {
                const l = s.seenUids,
                      c = this.boxCells[r];if (null !== c) {
                    const r = this.bboxes;for (const h of c) if (!l.box[h]) {
                        l.box[h] = !0;const c = 4 * h;if (e <= r[c + 2] && t <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!a || a(this.boxKeys[h]))) {
                            if (s.hitTest) return n.push(!0), !0;n.push({ key: this.boxKeys[h], x1: r[c], y1: r[c + 1], x2: r[c + 2], y2: r[c + 3] });
                        }
                    }
                }const h = this.circleCells[r];if (null !== h) {
                    const r = this.circles;for (const c of h) if (!l.circle[c]) {
                        l.circle[c] = !0;const h = 3 * c;if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t, i, o) && (!a || a(this.circleKeys[c]))) {
                            if (s.hitTest) return n.push(!0), !0;{
                                const e = r[h],
                                      t = r[h + 1],
                                      i = r[h + 2];n.push({ key: this.circleKeys[c], x1: e - i, y1: t - i, x2: e + i, y2: t + i });
                            }
                        }
                    }
                }
            }_queryCellCircle(e, t, i, o, r, n, s, a) {
                const l = s.circle,
                      c = s.seenUids,
                      h = this.boxCells[r];if (null !== h) {
                    const e = this.bboxes;for (const t of h) if (!c.box[t]) {
                        c.box[t] = !0;const i = 4 * t;if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t]))) return n.push(!0), !0;
                    }
                }const u = this.circleCells[r];if (null !== u) {
                    const e = this.circles;for (const t of u) if (!c.circle[t]) {
                        c.circle[t] = !0;const i = 3 * t;if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t]))) return n.push(!0), !0;
                    }
                }
            }_forEachCell(e, t, i, o, r, n, s, a) {
                const l = this._convertToXCellCoord(e),
                      c = this._convertToYCellCoord(t),
                      h = this._convertToXCellCoord(i),
                      u = this._convertToYCellCoord(o);for (let _ = l; _ <= h; _++) for (let l = c; l <= u; l++) if (r.call(this, e, t, i, o, this.xCellCount * l + _, n, s, a)) return;
            }_convertToXCellCoord(e) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
            }_convertToYCellCoord(e) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
            }_circlesCollide(e, t, i, o, r, n) {
                const s = o - e,
                      a = r - t,
                      l = i + n;return l * l > s * s + a * a;
            }_circleAndRectCollide(e, t, i, o, r, n, s) {
                const a = (n - o) / 2,
                      l = Math.abs(e - (o + a));if (l > a + i) return !1;const c = (s - r) / 2,
                      h = Math.abs(t - (r + c));if (h > c + i) return !1;if (l <= a || h <= c) return !0;const u = l - a,
                      _ = h - c;return u * u + _ * _ <= i * i;
            }
        }const tt = Math.tan(85 * Math.PI / 180);function it(t, i, o, r, n, s, a) {
            const l = e.create();if (o) {
                if ("globe" === s.name) {
                    const t = e.calculateGlobeLabelMatrix(n, i);e.multiply(l, l, t);
                } else {
                    const t = v([], a);l[0] = t[0], l[1] = t[1], l[4] = t[2], l[5] = t[3], r || e.rotateZ(l, l, n.angle);
                }
            } else e.multiply(l, n.labelPlaneMatrix, t);return l;
        }function ot(e, t, i, o, r, n, s) {
            const a = it(e, t, i, o, r, n, s);return "globe" === n.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;
        }function rt(t, i, o, r, n, s, a) {
            if (o) {
                if ("globe" === s.name) {
                    const l = it(t, i, o, r, n, s, a);return e.invert(l, l), e.multiply(l, t, l), l;
                }{
                    const i = e.clone(t),
                          o = e.identity([]);return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.multiply(i, i, o), r || e.rotateZ(i, i, -n.angle), i;
                }
            }return n.glCoordMatrix;
        }function nt(t, i, o, r) {
            const n = [t, i, o, 1];o ? e.transformMat4$1(n, n, r) : ft(n, n, r);const s = n[3];return n[0] /= s, n[1] /= s, n[2] /= s, n;
        }function st(e, t) {
            return Math.min(.5 + e / t * .5, 1.5);
        }function at(e, t) {
            const i = e[0] / e[3],
                  o = e[1] / e[3];return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];
        }function lt(t, i, o, r, n, s, a, l, c, h) {
            const u = o.transform,
                  _ = r ? t.textSizeData : t.iconSizeData,
                  d = e.evaluateSizeForZoom(_, o.transform.zoom),
                  p = "globe" === u.projection.name,
                  m = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],
                  f = r ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;f.clear();let g = null;p && (g = r ? t.text.globeExtVertexArray : t.icon.globeExtVertexArray);const v = t.lineVertexArray,
                  x = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,
                  y = o.transform.width / o.transform.height;let b,
                w = !1;for (let r = 0; r < x.length; r++) {
                const p = x.get(r),
                      { numGlyphs: T, writingMode: E } = p;if (E !== e.WritingMode.vertical || w || b === e.WritingMode.horizontal || (w = !0), b = E, (p.hidden || E === e.WritingMode.vertical) && !w) {
                    mt(T, f);continue;
                }w = !1;const C = new e.pointGeometry(p.tileAnchorX, p.tileAnchorY);let { x: M, y: I, z: S } = u.projection.projectTilePoint(C.x, C.y, h.canonical);if (c) {
                    const [e, t, i] = c(C);M += e, I += t, S += i;
                }const D = [M, I, S, 1];if (e.transformMat4$1(D, D, i), !at(D, m)) {
                    mt(T, f);continue;
                }const L = st(o.transform.cameraToCenterDistance, D[3]),
                      A = e.evaluateSizeForFeature(_, d, p),
                      z = a ? A / L : A * L,
                      P = nt(M, I, S, n);if (P[3] <= 0) {
                    mt(T, f);continue;
                }let R = {};const O = a ? null : c,
                      B = ut(p, z, !1, l, i, n, s, t.glyphOffsetArray, v, f, g, P, C, R, y, O, u.projection, h, a);w = B.useVertical, O && B.needsFlipping && (R = {}), (B.notEnoughRoom || w || B.needsFlipping && ut(p, z, !0, l, i, n, s, t.glyphOffsetArray, v, f, g, P, C, R, y, O, u.projection, h, a).notEnoughRoom) && mt(T, f);
            }r ? (t.text.dynamicLayoutVertexBuffer.updateData(f), g && t.text.globeExtVertexBuffer.updateData(g)) : (t.icon.dynamicLayoutVertexBuffer.updateData(f), g && t.icon.globeExtVertexBuffer.updateData(g));
        }function ct(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
            const { lineStartIndex: f, glyphStartIndex: g, segment: v } = a,
                  x = g + a.numGlyphs,
                  y = f + a.lineLength,
                  b = t.getoffsetX(g),
                  w = t.getoffsetX(x - 1),
                  T = pt(e * b, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);if (!T) return null;const E = pt(e * w, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);return E ? { first: T, last: E } : null;
        }function ht(t, i, o, r) {
            return t === e.WritingMode.horizontal && Math.abs(r) > Math.abs(o) ? { useVertical: !0 } : t === e.WritingMode.vertical ? r > 0 ? { needsFlipping: !0 } : null : 0 !== i && function (e, t) {
                return 0 === e || Math.abs(t / e) > tt;
            }(o, r) ? 1 === i ? { needsFlipping: !0 } : null : o < 0 ? { needsFlipping: !0 } : null;
        }function ut(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v, x) {
            const y = i / 24,
                  b = t.lineOffsetX * y,
                  w = t.lineOffsetY * y,
                  { lineStartIndex: T, glyphStartIndex: E, numGlyphs: C, segment: M, writingMode: I, flipState: S } = t,
                  D = T + t.lineLength,
                  L = t => {
                if (u) {
                    const [i, o, r] = t.up,
                          n = h.length;e.updateGlobeVertexNormal(u, n + 0, i, o, r), e.updateGlobeVertexNormal(u, n + 1, i, o, r), e.updateGlobeVertexNormal(u, n + 2, i, o, r), e.updateGlobeVertexNormal(u, n + 3, i, o, r);
                }const [i, o, r] = t.point;e.addDynamicAttributes(h, i, o, r, t.angle);
            };if (C > 1) {
                const e = ct(y, l, b, w, o, _, d, t, c, s, p, f, !1, g, v, x);if (!e) return { notEnoughRoom: !0 };if (r && !o) {
                    let [i, o, r] = e.first.point,
                        [n, s, l] = e.last.point;[i, o] = nt(i, o, r, a), [n, s] = nt(n, s, l, a);const c = ht(I, S, (n - i) * m, s - o);if (t.flipState = c && c.needsFlipping ? 1 : 2, c) return c;
                }L(e.first);for (let e = E + 1; e < E + C - 1; e++) {
                    const t = pt(y * l.getoffsetX(e), b, w, o, _, d, M, T, D, c, s, p, f, !1, !1, g, v, x);if (!t) return h.length -= 4 * (e - E), { notEnoughRoom: !0 };L(t);
                }L(e.last);
            } else {
                if (r && !o) {
                    const i = nt(d.x, d.y, 0, n),
                          o = T + M + 1,
                          r = new e.pointGeometry(c.getx(o), c.gety(o)),
                          s = nt(r.x, r.y, 0, n),
                          a = s[3] > 0 ? s : dt(d, r, i, 1, n, void 0, g, v.canonical),
                          l = ht(I, S, (a[0] - i[0]) * m, a[1] - i[1]);if (t.flipState = l && l.needsFlipping ? 1 : 2, l) return l;
                }const i = pt(y * l.getoffsetX(E), b, w, o, _, d, M, T, D, c, s, p, f, !1, !1, g, v, x);if (!i) return { notEnoughRoom: !0 };L(i);
            }return {};
        }function _t(e, t, i, o, r) {
            const { x: n, y: s, z: a } = o.projectTilePoint(e.x, e.y, t);if (!r) return nt(n, s, a, i);const [l, c, h] = r(e);return nt(n + l, s + c, a + h, i);
        }function dt(t, i, o, r, n, s, a, l) {
            const c = _t(t.sub(i)._unit()._add(t), l, n, a, s);return e.sub(c, o, c), e.normalize(c, c), e.scaleAndAdd(c, o, c, r);
        }function pt(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v) {
            const x = r ? t - i : t + i;let y = x > 0 ? 1 : -1,
                b = 0;r && (y *= -1, b = Math.PI), y < 0 && (b += Math.PI);let w = l + a + (y > 0 ? 0 : 1) | 0,
                T = n,
                E = n,
                C = 0,
                M = 0;const I = Math.abs(x),
                  S = [],
                  D = [];let L = s,
                A = L;const z = () => dt(A, L, E, I - C + 1, u, d, f, g.canonical);for (; C + M <= I;) {
                if (w += y, w < l || w >= c) return null;if (E = T, A = L, S.push(E), p && D.push(A), L = new e.pointGeometry(h.getx(w), h.gety(w)), T = _[w], !T) {
                    const e = _t(L, g.canonical, u, f, d);T = e[3] > 0 ? _[w] = e : z();
                }C += M, M = e.distance(E, T);
            }m && d && (_[w] && (T = z(), M = e.distance(E, T)), _[w] = T);const P = (I - C) / M,
                  R = L.sub(A)._mult(P)._add(A),
                  O = e.sub([], T, E),
                  B = e.scaleAndAdd([], E, O, P);let k = [0, 0, 1],
                F = O[0],
                U = O[1];if (v && (k = f.upVector(g.canonical, R.x, R.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {
                const t = [k[2], 0, -k[0]],
                      i = e.cross([], k, t);e.normalize(t, t), e.normalize(i, i), F = e.dot(O, t), U = e.dot(O, i);
            }if (o) {
                const t = e.cross([], k, O);e.normalize(t, t), e.scaleAndAdd(B, B, t, o * y);
            }const N = b + Math.atan2(U, F);return S.push(B), p && D.push(R), { point: B, angle: N, path: S, tilePath: D, up: k };
        }function mt(e, t) {
            const i = t.length,
                  o = i + 4 * e;t.resize(o), t.float32.fill(-1 / 0, 4 * i, 4 * o);
        }function ft(e, t, i) {
            const o = t[0],
                  r = t[1];return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;
        }const gt = 100;class vt {
            constructor(e, t, i = new et(e.width + 200, e.height + 200, 25), o = new et(e.width + 200, e.height + 200, 25)) {
                this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + gt, this.screenBottomBoundary = e.height + gt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;
            }placeCollisionBox(e, t, i, o, r, n, s, a) {
                let l = i.projectedAnchorX,
                    c = i.projectedAnchorY,
                    h = i.projectedAnchorZ;const u = i.elevation,
                      _ = i.tileID,
                      d = e.getProjection();if (u && _) {
                    const [e, t, o] = d.upVector(_.canonical, i.tileAnchorX, i.tileAnchorY),
                          r = d.upVectorScale(_.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;l += e * u * r, c += t * u * r, h += o * u * r;
                }const p = this.projectAndGetPerspectiveRatio(s, l, c, h, i.tileID, "globe" === d.name || !!u || this.transform.pitch > 0, d),
                      m = n * p.perspectiveRatio,
                      f = (i.x1 * t + o.x - i.padding) * m + p.point.x,
                      g = (i.y1 * t + o.y - i.padding) * m + p.point.y,
                      v = (i.x2 * t + o.x + i.padding) * m + p.point.x,
                      x = (i.y2 * t + o.y + i.padding) * m + p.point.y,
                      y = p.perspectiveRatio <= .55 || p.occluded;return !this.isInsideGrid(f, g, v, x) || !r && this.grid.hitTest(f, g, v, x, a) || y ? { box: [], offscreen: !1, occluded: p.occluded } : { box: [f, g, v, x], offscreen: this.isOffscreen(f, g, v, x), occluded: !1 };
            }placeCollisionCircles(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
                const f = [],
                      g = this.transform.elevation,
                      v = t.getProjection(),
                      x = g ? g.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, v) : null,
                      y = new e.pointGeometry(o.tileAnchorX, o.tileAnchorY);let { x: b, y: w, z: T } = v.projectTilePoint(y.x, y.y, m.canonical);if (x) {
                    const [e, t, i] = x(y);b += e, w += t, T += i;
                }const E = "globe" === v.name,
                      C = this.projectAndGetPerspectiveRatio(a, b, w, T, m, E || !!g || this.transform.pitch > 0, v),
                      { perspectiveRatio: M } = C,
                      I = (u ? s / M : s * M) / e.ONE_EM,
                      S = nt(b, w, T, l),
                      D = C.signedDistanceFromCamera > 0 ? ct(I, n, o.lineOffsetX * I, o.lineOffsetY * I, !1, S, y, o, r, l, {}, g && !u ? x : null, u && !!g, v, m, u) : null;let L = !1,
                    A = !1,
                    z = !0;if (D && !C.occluded) {
                    const t = .5 * d * M + p,
                          o = new e.pointGeometry(-100, -100),
                          r = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary),
                          n = new Qe(),
                          { first: s, last: a } = D,
                          l = s.path.length;let u = [];for (let e = l - 1; e >= 1; e--) u.push(s.path[e]);for (let e = 1; e < a.path.length; e++) u.push(a.path[e]);const m = 2.5 * t;c && (u = u.map(([e, t, i], o) => (x && !E && (i = x(o < l - 1 ? s.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), nt(e, t, i, c))), u.some(e => e[3] <= 0) && (u = []));let g = [];if (u.length > 0) {
                        let t = 1 / 0,
                            i = -1 / 0,
                            n = 1 / 0,
                            s = -1 / 0;for (const e of u) t = Math.min(t, e[0]), n = Math.min(n, e[1]), i = Math.max(i, e[0]), s = Math.max(s, e[1]);i >= o.x && t <= r.x && s >= o.y && n <= r.y && (g = [u.map(t => new e.pointGeometry(t[0], t[1]))], (t < o.x || i > r.x || n < o.y || s > r.y) && (g = e.clipLine(g, o.x, o.y, r.x, r.y)));
                    }for (const e of g) {
                        n.reset(e, .25 * t);let o = 0;o = n.length <= .5 * t ? 1 : Math.ceil(n.paddedLength / m) + 1;for (let e = 0; e < o; e++) {
                            const r = e / Math.max(o - 1, 1),
                                  s = n.lerp(r),
                                  a = s.x + gt,
                                  l = s.y + gt;f.push(a, l, t, 0);const c = a - t,
                                  u = l - t,
                                  d = a + t,
                                  p = l + t;if (z = z && this.isOffscreen(c, u, d, p), A = A || this.isInsideGrid(c, u, d, p), !i && this.grid.hitTestCircle(a, l, t, _) && (L = !0, !h)) return { circles: [], offscreen: !1, collisionDetected: L, occluded: !1 };
                        }
                    }
                }return { circles: !h && L || !A ? [] : f, offscreen: z, collisionDetected: L, occluded: C.occluded };
            }queryRenderedSymbols(t) {
                if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};const i = [];let o = 1 / 0,
                    r = 1 / 0,
                    n = -1 / 0,
                    s = -1 / 0;for (const a of t) {
                    const t = new e.pointGeometry(a.x + gt, a.y + gt);o = Math.min(o, t.x), r = Math.min(r, t.y), n = Math.max(n, t.x), s = Math.max(s, t.y), i.push(t);
                }const a = this.grid.query(o, r, n, s).concat(this.ignoredGrid.query(o, r, n, s)),
                      l = {},
                      c = {};for (const t of a) {
                    const o = t.key;if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;const r = [new e.pointGeometry(t.x1, t.y1), new e.pointGeometry(t.x2, t.y1), new e.pointGeometry(t.x2, t.y2), new e.pointGeometry(t.x1, t.y2)];e.polygonIntersectsPolygon(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }return c;
            }insertCollisionBox(e, t, i, o, r) {
                (t ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i, featureIndex: o, collisionGroupID: r }, e[0], e[1], e[2], e[3]);
            }insertCollisionCircles(e, t, i, o, r) {
                const n = t ? this.ignoredGrid : this.grid,
                      s = { bucketInstanceId: i, featureIndex: o, collisionGroupID: r };for (let t = 0; t < e.length; t += 4) n.insertCircle(s, e[t], e[t + 1], e[t + 2]);
            }projectAndGetPerspectiveRatio(t, i, o, r, n, s, a) {
                const l = [i, o, r, 1];let c = !1;if (r || this.transform.pitch > 0) {
                    e.transformMat4$1(l, l, t);const s = "globe" === a.name;if (this.fogState && n && !s) {
                        const t = function (t, i, o, r, n, s) {
                            const a = s.calculateFogTileMatrix(n),
                                  l = [i, o, r];return e.transformMat4(l, l, a), I(t, l, s.pitch, s._fov);
                        }(this.fogState, i, o, r, n.toUnwrapped(), this.transform);c = t > .9;
                    }
                } else ft(l, l, t);const h = l[3];return { point: new e.pointGeometry((l[0] / h + 1) / 2 * this.transform.width + gt, (-l[1] / h + 1) / 2 * this.transform.height + gt), perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5), signedDistanceFromCamera: h, occluded: s && l[2] > h || c };
            }isOffscreen(e, t, i, o) {
                return i < gt || e >= this.screenRightBoundary || o < gt || t > this.screenBottomBoundary;
            }isInsideGrid(e, t, i, o) {
                return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;
            }getViewportMatrix() {
                const t = e.identity([]);return e.translate(t, t, [-100, -100, 0]), t;
            }
        }function xt(t, i, o) {
            const r = i.createTileMatrix(t, t.worldSize, o.toUnwrapped());return e.multiply(new Float32Array(16), t.projMatrix, r);
        }function yt(e, t, i) {
            if (t.projection.name === i.projection.name) return e.projMatrix;const o = i.clone();return o.setProjection(t.projection), xt(o, t.getProjection(), e);
        }function bt(e, t, i) {
            return t.name === i.projection.name ? e.projMatrix : xt(i, t, e);
        }class wt {
            constructor(e, t, i, o) {
                this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;
            }isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }class Tt {
            constructor(e, t, i, o, r, n = !1) {
                this.text = new wt(e ? e.text : null, t, i, r), this.icon = new wt(e ? e.icon : null, t, o, r), this.clipped = n;
            }isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }class Et {
            constructor(e, t, i, o = !1) {
                this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;
            }
        }class Ct {
            constructor() {
                this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
            }
        }class Mt {
            constructor(e, t, i, o, r) {
                this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;
            }
        }class It {
            constructor(e) {
                this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
            }get(e) {
                if (this.crossSourceCollisions) return { ID: 0, predicate: null };if (!this.collisionGroups[e]) {
                    const t = ++this.maxGroupID;this.collisionGroups[e] = { ID: t, predicate: e => e.collisionGroupID === t };
                }return this.collisionGroups[e];
            }
        }function St(t, i, o, r, n) {
            const { horizontalAlign: s, verticalAlign: a } = e.getAnchorAlignment(t),
                  l = -(s - .5) * i,
                  c = -(a - .5) * o,
                  h = e.evaluateVariableOffset(t, r);return new e.pointGeometry(l + h[0] * n, c + h[1] * n);
        }function Dt(t, i, o, r, n) {
            const s = new e.pointGeometry(t, i);return o && s._rotate(r ? n : -n), s;
        }class Lt {
            constructor(e, t, i, o, r) {
                this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new vt(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new It(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
            }getBucketParts(t, i, o, r) {
                const n = o.getBucket(i),
                      s = o.latestFeatureIndex;if (!n || !s || i.id !== n.layerIds[0]) return;const a = n.layers[0].layout,
                      l = o.collisionBoxArray,
                      c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),
                      h = o.tileSize / e.EXTENT,
                      u = o.tileID.toUnwrapped();this.transform.setProjection(n.projection);const _ = (d = o.tileID, p = n.getProjection(), m = this.transform, p.name === this.projection ? m.calculateProjMatrix(d.toUnwrapped()) : xt(m, p, d));var d, p, m;const f = "map" === a.get("text-pitch-alignment"),
                      g = "map" === a.get("text-rotation-alignment");i.compileFilter();const v = i.dynamicFilter(),
                      x = i.dynamicFilterNeedsFeature(),
                      y = this.transform.calculatePixelsToTileUnitsMatrix(o),
                      b = ot(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);let w = null;if (f) {
                    const t = rt(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);w = e.multiply([], this.transform.labelPlaneMatrix, t);
                }let T = null;v && o.latestFeatureIndex && (T = { unwrappedTileID: u, dynamicFilter: v, dynamicFilterNeedsFeature: x, featureIndex: o.latestFeatureIndex }), this.retainedQueryData[n.bucketInstanceId] = new Mt(n.bucketInstanceId, s, n.sourceLayerIndex, n.index, o.tileID);const E = { bucket: n, layout: a, posMatrix: _, textLabelPlaneMatrix: b, labelToScreenMatrix: w, clippingData: T, scale: c, textPixelRatio: h, holdingForFade: o.holdingForFade(), collisionBoxArray: l, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n.sourceID) };if (r) for (const e of n.sortKeyRanges) {
                    const { sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: r } = e;t.push({ sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: r, parameters: E });
                } else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: n.symbolInstances.length, parameters: E });
            }attemptAnchorPlacement(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) {
                const { textOffset0: v, textOffset1: x, crossTileID: y } = u,
                      b = [v, x],
                      w = St(e, i, o, b, r),
                      T = this.collisionIndex.placeCollisionBox(d, r, t, Dt(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate);if (m) {
                    const e = d.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);if (0 === this.collisionIndex.placeCollisionBox(d, e, m, Dt(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate).box.length) return;
                }if (T.box.length > 0) {
                    let t;return this.prevPlacement && this.prevPlacement.variableOffsets[y] && this.prevPlacement.placements[y] && this.prevPlacement.placements[y].text && (t = this.prevPlacement.variableOffsets[y].anchor), this.variableOffsets[y] = { textOffset: b, width: i, height: o, anchor: e, textScale: r, prevAnchor: t }, this.markUsedJustification(d, e, u, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, u), this.placedOrientations[y] = p), { shift: w, placedGlyphBoxes: T };
                }
            }placeLayerBucketPart(t, i, o, r) {
                const { bucket: n, layout: s, posMatrix: a, textLabelPlaneMatrix: l, labelToScreenMatrix: c, clippingData: h, textPixelRatio: u, holdingForFade: _, collisionBoxArray: d, partiallyEvaluatedTextSize: p, partiallyEvaluatedIconSize: m, collisionGroup: f } = t.parameters,
                      g = s.get("text-optional"),
                      v = s.get("icon-optional"),
                      x = s.get("text-allow-overlap"),
                      y = s.get("icon-allow-overlap"),
                      b = "map" === s.get("text-rotation-alignment"),
                      w = "map" === s.get("text-pitch-alignment"),
                      T = "none" !== s.get("icon-text-fit"),
                      E = "viewport-y" === s.get("symbol-z-order");this.transform.setProjection(n.projection);let C = x && (y || !n.hasIconData() || v),
                    M = y && (x || !n.hasTextData() || g);!n.collisionArrays && d && n.deserializeCollisionBoxes(d), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, d);const I = (t, r, d) => {
                    const { crossTileID: E, numVerticalGlyphVertices: I } = t;if (h) {
                        const o = { zoom: this.transform.zoom, pitch: this.transform.pitch };let r = null;if (h.dynamicFilterNeedsFeature) {
                            const e = this.retainedQueryData[n.bucketInstanceId];r = h.featureIndex.loadFeature({ featureIndex: t.featureIndex, bucketIndex: e.bucketIndex, sourceLayerIndex: e.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                        }if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.pointGeometry(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[E] = new Et(!1, !1, !1, !0), void (i[E] = !0);
                    }if (i[E]) return;if (_) return void (this.placements[E] = new Et(!1, !1, !1));let S = !1,
                        D = !1,
                        L = !0,
                        A = !1,
                        z = !1,
                        P = null,
                        R = { box: null, offscreen: null, occluded: null },
                        O = { box: null, offscreen: null, occluded: null },
                        B = null,
                        k = null,
                        F = null,
                        U = 0,
                        N = 0,
                        G = 0;d.textFeatureIndex ? U = d.textFeatureIndex : t.useRuntimeCollisionCircles && (U = t.featureIndex), d.verticalTextFeatureIndex && (N = d.verticalTextFeatureIndex);const j = e => {
                        e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;const t = this.transform.elevation;(t || e.elevation) && (e.elevation = t ? t.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0);
                    },
                          Z = d.textBox;if (Z) {
                        j(Z);const i = i => {
                            let o = e.WritingMode.horizontal;if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                                const e = this.prevPlacement.placedOrientations[E];e && (this.placedOrientations[E] = e, o = e, this.markUsedOrientation(n, o, t));
                            }return o;
                        },
                              o = (t, i) => {
                            if (n.allowVerticalPlacement && I > 0 && d.verticalTextBox) {
                                for (const o of n.writingModes) if (o === e.WritingMode.vertical ? (R = i(), O = R) : R = t(), R && R.box && R.box.length) break;
                            } else R = t();
                        };if (s.get("text-variable-anchor")) {
                            let l = s.get("text-variable-anchor");if (this.prevPlacement && this.prevPlacement.variableOffsets[E]) {
                                const e = this.prevPlacement.variableOffsets[E];l.indexOf(e.anchor) > 0 && (l = l.filter(t => t !== e.anchor), l.unshift(e.anchor));
                            }const c = (e, i, o) => {
                                const s = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),
                                      c = (e.x2 - e.x1) * s + 2 * e.padding,
                                      h = (e.y2 - e.y1) * s + 2 * e.padding,
                                      _ = T && !y ? i : null;_ && j(_);let d = { box: [], offscreen: !1, occluded: !1 };const g = x ? 2 * l.length : l.length;for (let i = 0; i < g; ++i) {
                                    const g = this.attemptAnchorPlacement(l[i % l.length], e, c, h, s, b, w, u, a, f, i >= l.length, t, r, n, o, _, p, m);if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {
                                        S = !0, P = g.shift;break;
                                    }
                                }return d;
                            };o(() => c(Z, d.iconBox, e.WritingMode.horizontal), () => {
                                const t = d.verticalTextBox;return t && j(t), n.allowVerticalPlacement && !(R && R.box && R.box.length) && I > 0 && t ? c(t, d.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                            }), R && (S = R.box, L = R.offscreen, A = R.occluded);const h = i(R && R.box);if (!S && this.prevPlacement) {
                                const e = this.prevPlacement.variableOffsets[E];e && (this.variableOffsets[E] = e, this.markUsedJustification(n, e.anchor, t, h));
                            }
                        } else {
                            const s = (i, o) => {
                                const s = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),
                                      l = this.collisionIndex.placeCollisionBox(n, s, i, new e.pointGeometry(0, 0), x, u, a, f.predicate);return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t), this.placedOrientations[E] = o), l;
                            };o(() => s(Z, e.WritingMode.horizontal), () => {
                                const t = d.verticalTextBox;return n.allowVerticalPlacement && I > 0 && t ? (j(t), s(t, e.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                            }), i(R && R.box && R.box.length);
                        }
                    }if (B = R, S = B && B.box && B.box.length > 0, L = B && B.offscreen, A = B && B.occluded, t.useRuntimeCollisionCircles) {
                        const i = n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),
                              r = e.evaluateSizeForFeature(n.textSizeData, p, i),
                              h = s.get("text-padding");k = this.collisionIndex.placeCollisionCircles(n, x, i, n.lineVertexArray, n.glyphOffsetArray, r, a, l, c, o, w, f.predicate, t.collisionCircleDiameter * r / e.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID), S = x || k.circles.length > 0 && !k.collisionDetected, L = L && k.offscreen, A = k.occluded;
                    }if (d.iconFeatureIndex && (G = d.iconFeatureIndex), d.iconBox) {
                        const i = i => {
                            j(i);const o = T && P ? Dt(P.x, P.y, b, w, this.transform.angle) : new e.pointGeometry(0, 0),
                                  r = n.getSymbolInstanceIconSize(m, this.transform.zoom, t.placedIconSymbolIndex);return this.collisionIndex.placeCollisionBox(n, r, i, o, y, u, a, f.predicate);
                        };O && O.box && O.box.length && d.verticalIconBox ? (F = i(d.verticalIconBox), D = F.box.length > 0) : (F = i(d.iconBox), D = F.box.length > 0), L = L && F.offscreen, z = F.occluded;
                    }const V = g || 0 === t.numHorizontalGlyphVertices && 0 === I,
                          W = v || 0 === t.numIconVertices;if (V || W ? W ? V || (D = D && S) : S = D && S : D = S = D && S, S && B && B.box && this.collisionIndex.insertCollisionBox(B.box, s.get("text-ignore-placement"), n.bucketInstanceId, O && O.box && N ? N : U, f.ID), D && F && this.collisionIndex.insertCollisionBox(F.box, s.get("icon-ignore-placement"), n.bucketInstanceId, G, f.ID), k && (S && this.collisionIndex.insertCollisionCircles(k.circles, s.get("text-ignore-placement"), n.bucketInstanceId, U, f.ID), o)) {
                        const e = n.bucketInstanceId;let t = this.collisionCircleArrays[e];void 0 === t && (t = this.collisionCircleArrays[e] = new Ct());for (let e = 0; e < k.circles.length; e += 4) t.circles.push(k.circles[e + 0]), t.circles.push(k.circles[e + 1]), t.circles.push(k.circles[e + 2]), t.circles.push(k.collisionDetected ? 1 : 0);
                    }const X = "globe" !== n.projection.name;C = C && (X || !A), M = M && (X || !z), this.placements[E] = new Et(S || C, D || M, L || n.justReloaded), i[E] = !0;
                };if (E) {
                    const e = n.getSortedSymbolIndexes(this.transform.angle);for (let t = e.length - 1; t >= 0; --t) {
                        const i = e[t];I(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) I(n.symbolInstances.get(e), e, n.collisionArrays[e]);if (o && n.bucketInstanceId in this.collisionCircleArrays) {
                    const t = this.collisionCircleArrays[n.bucketInstanceId];e.invert(t.invProjMatrix, a), t.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }n.justReloaded = !1;
            }markUsedJustification(t, i, o, r) {
                const { leftJustifiedTextSymbolIndex: n, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: l, crossTileID: c } = o,
                      h = e.getAnchorJustification(i),
                      u = r === e.WritingMode.vertical ? l : "left" === h ? n : "center" === h ? s : "right" === h ? a : -1;n >= 0 && (t.text.placedSymbolArray.get(n).crossTileID = u >= 0 && n !== u ? 0 : c), s >= 0 && (t.text.placedSymbolArray.get(s).crossTileID = u >= 0 && s !== u ? 0 : c), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c), l >= 0 && (t.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c);
            }markUsedOrientation(t, i, o) {
                const r = i === e.WritingMode.horizontal || i === e.WritingMode.horizontalOnly ? i : 0,
                      n = i === e.WritingMode.vertical ? i : 0,
                      { leftJustifiedTextSymbolIndex: s, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c } = o,
                      h = t.text.placedSymbolArray;s >= 0 && (h.get(s).placedOrientation = r), a >= 0 && (h.get(a).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = n);
            }commit(e) {
                this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;const t = this.prevPlacement;let i = !1;this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;const o = t ? t.symbolFadeChange(e) : 1,
                      r = t ? t.opacities : {},
                      n = t ? t.variableOffsets : {},
                      s = t ? t.placedOrientations : {};for (const e in this.placements) {
                    const t = this.placements[e],
                          n = r[e];n ? (this.opacities[e] = new Tt(n, o, t.text, t.icon, null, t.clipped), i = i || t.text !== n.text.placed || t.icon !== n.icon.placed) : (this.opacities[e] = new Tt(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);
                }for (const e in r) {
                    const t = r[e];if (!this.opacities[e]) {
                        const r = new Tt(t, o, !1, !1);r.isHidden() || (this.opacities[e] = r, i = i || t.text.placed || t.icon.placed);
                    }
                }for (const e in n) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = n[e]);for (const e in s) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = s[e]);i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);
            }updateLayerOpacities(e, t) {
                const i = {};for (const o of t) {
                    const t = o.getBucket(e);t && o.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, i, o.collisionBoxArray);
                }
            }updateBucketOpacities(t, i, o) {
                t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();const r = t.layers[0].layout,
                      n = !!t.layers[0].dynamicFilter(),
                      s = new Tt(null, 0, !1, !1, !0),
                      a = r.get("text-allow-overlap"),
                      l = r.get("icon-allow-overlap"),
                      c = r.get("text-variable-anchor"),
                      h = "map" === r.get("text-rotation-alignment"),
                      u = "map" === r.get("text-pitch-alignment"),
                      _ = "none" !== r.get("icon-text-fit"),
                      d = new Tt(null, 0, a && (l || !t.hasIconData() || r.get("icon-optional")), l && (a || !t.hasTextData() || r.get("text-optional")), !0);!t.collisionArrays && o && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(o);const p = (e, t, i) => {
                    for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);
                };let m = 0;for (let o = 0; o < t.symbolInstances.length; o++) {
                    const r = t.symbolInstances.get(o),
                          { numHorizontalGlyphVertices: a, numVerticalGlyphVertices: l, crossTileID: f, numIconVertices: g } = r;let v = this.opacities[f];i[f] ? v = s : v || (v = d, this.opacities[f] = v), i[f] = !0;const x = a > 0 || l > 0,
                          y = g > 0,
                          b = this.placedOrientations[f],
                          w = b === e.WritingMode.vertical,
                          T = b === e.WritingMode.horizontal || b === e.WritingMode.horizontalOnly;if (!x && !y || v.isHidden() || m++, x) {
                        const e = Ut(v.text);p(t.text, a, w ? Nt : e), p(t.text, l, T ? Nt : e);const i = v.text.isHidden(),
                              { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: n, rightJustifiedTextSymbolIndex: s, verticalPlacedTextSymbolIndex: c } = r,
                              h = t.text.placedSymbolArray,
                              u = i || w ? 1 : 0;o >= 0 && (h.get(o).hidden = u), n >= 0 && (h.get(n).hidden = u), s >= 0 && (h.get(s).hidden = u), c >= 0 && (h.get(c).hidden = i || T ? 1 : 0);const _ = this.variableOffsets[f];_ && this.markUsedJustification(t, _.anchor, r, b);const d = this.placedOrientations[f];d && (this.markUsedJustification(t, "left", r, d), this.markUsedOrientation(t, d, r));
                    }if (y) {
                        const e = Ut(v.icon),
                              { placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: o } = r,
                              n = t.icon.placedSymbolArray,
                              s = v.icon.isHidden() ? 1 : 0;i >= 0 && (p(t.icon, g, w ? Nt : e), n.get(i).hidden = s), o >= 0 && (p(t.icon, r.numVerticalIconVertices, T ? Nt : e), n.get(o).hidden = s);
                    }if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                        const i = t.collisionArrays[o];if (i) {
                            let o = new e.pointGeometry(0, 0),
                                r = !0;if (i.textBox || i.verticalTextBox) {
                                if (c) {
                                    const e = this.variableOffsets[f];e ? (o = St(e.anchor, e.width, e.height, e.textOffset, e.textScale), h && o._rotate(u ? this.transform.angle : -this.transform.angle)) : r = !1;
                                }n && (r = !v.clipped), i.textBox && At(t.textCollisionBox.collisionVertexArray, v.text.placed, !r || w, o.x, o.y), i.verticalTextBox && At(t.textCollisionBox.collisionVertexArray, v.text.placed, !r || T, o.x, o.y);
                            }const s = r && Boolean(!T && i.verticalIconBox);i.iconBox && At(t.iconCollisionBox.collisionVertexArray, v.icon.placed, s, _ ? o.x : 0, _ ? o.y : 0), i.verticalIconBox && At(t.iconCollisionBox.collisionVertexArray, v.icon.placed, !s, _ ? o.x : 0, _ ? o.y : 0);
                        }
                    }
                }if (t.fullyClipped = 0 === m, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
                    const e = this.collisionCircleArrays[t.bucketInstanceId];t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
                }
            }symbolFadeChange(e) {
                return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }zoomAdjustment(e) {
                return Math.max(0, (this.transform.zoom - e) / 1.5);
            }hasTransitions(e) {
                return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
            }stillRecent(e, t) {
                const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;
            }setStale() {
                this.stale = !0;
            }
        }function At(e, t, i, o, r) {
            e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0);
        }const zt = Math.pow(2, 25),
              Pt = Math.pow(2, 24),
              Rt = Math.pow(2, 17),
              Ot = Math.pow(2, 16),
              Bt = Math.pow(2, 9),
              kt = Math.pow(2, 8),
              Ft = Math.pow(2, 1);function Ut(e) {
            if (0 === e.opacity && !e.placed) return 0;if (1 === e.opacity && e.placed) return 4294967295;const t = e.placed ? 1 : 0,
                  i = Math.floor(127 * e.opacity);return i * zt + t * Pt + i * Rt + t * Ot + i * Bt + t * kt + i * Ft + t;
        }const Nt = 0;class Gt {
            constructor(e) {
                this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }continuePlacement(e, t, i, o, r) {
                const n = this._bucketParts;for (; this._currentTileIndex < e.length;) if (t.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < n.length;) {
                    const e = n[this._currentPartIndex];if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0;
                }return !1;
            }
        }class jt {
            constructor(e, t, i, o, r, n, s, a) {
                this.placement = new Lt(e, r, n, s, a), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
            }isDone() {
                return this._done;
            }continuePlacement(t, i, o) {
                const r = e.exported.now(),
                      n = () => {
                    const t = e.exported.now() - r;return !this._forceFullPlacement && t > 2;
                };for (; this._currentPlacementIndex >= 0;) {
                    const e = i[t[this._currentPlacementIndex]],
                          r = this.placement.collisionIndex.transform.zoom;if ("symbol" === e.type && (!e.minzoom || e.minzoom <= r) && (!e.maxzoom || e.maxzoom > r)) {
                        if (this._inProgressLayer || (this._inProgressLayer = new Gt(e)), this._inProgressLayer.continuePlacement(o[e.source], this.placement, this._showCollisionBoxes, e, n)) return;delete this._inProgressLayer;
                    }this._currentPlacementIndex--;
                }this._done = !0;
            }commit(e) {
                return this.placement.commit(e), this.placement;
            }
        }const Zt = 512 / e.EXTENT / 2;class Vt {
            constructor(e, t, i) {
                this.tileID = e, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;for (let i = 0; i < t.length; i++) {
                    const o = t.get(i),
                          r = o.key;this.indexedSymbolInstances[r] || (this.indexedSymbolInstances[r] = []), this.indexedSymbolInstances[r].push({ crossTileID: o.crossTileID, coord: this.getScaledCoordinates(o, e) });
                }
            }getScaledCoordinates(t, i) {
                const o = Zt / Math.pow(2, i.canonical.z - this.tileID.canonical.z);return { x: Math.floor((i.canonical.x * e.EXTENT + t.tileAnchorX) * o), y: Math.floor((i.canonical.y * e.EXTENT + t.tileAnchorY) * o) };
            }findMatches(e, t, i) {
                const o = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);for (let r = 0; r < e.length; r++) {
                    const n = e.get(r);if (n.crossTileID) continue;const s = this.indexedSymbolInstances[n.key];if (!s) continue;const a = this.getScaledCoordinates(n, t);for (const e of s) if (Math.abs(e.coord.x - a.x) <= o && Math.abs(e.coord.y - a.y) <= o && !i[e.crossTileID]) {
                        i[e.crossTileID] = !0, n.crossTileID = e.crossTileID;break;
                    }
                }
            }
        }class Wt {
            constructor() {
                this.maxCrossTileID = 0;
            }generate() {
                return ++this.maxCrossTileID;
            }
        }class Xt {
            constructor() {
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }handleWrapJump(e) {
                const t = Math.round((e - this.lng) / 360);if (0 !== t) for (const e in this.indexes) {
                    const i = this.indexes[e],
                          o = {};for (const e in i) {
                        const r = i[e];r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), o[r.tileID.key] = r;
                    }this.indexes[e] = o;
                }this.lng = e;
            }addBucket(e, t, i) {
                if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                    if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
                }for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});const o = this.usedCrossTileIDs[e.overscaledZ];for (const i in this.indexes) {
                    const r = this.indexes[i];if (Number(i) > e.overscaledZ) for (const i in r) {
                        const n = r[i];n.tileID.isChildOf(e) && n.findMatches(t.symbolInstances, e, o);
                    } else {
                        const n = r[e.scaledTo(Number(i)).key];n && n.findMatches(t.symbolInstances, e, o);
                    }
                }for (let e = 0; e < t.symbolInstances.length; e++) {
                    const r = t.symbolInstances.get(e);r.crossTileID || (r.crossTileID = i.generate(), o[r.crossTileID] = !0);
                }return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Vt(e, t.symbolInstances, t.bucketInstanceId), !0;
            }removeBucketCrossTileIDs(e, t) {
                for (const i in t.indexedSymbolInstances) for (const o of t.indexedSymbolInstances[i]) delete this.usedCrossTileIDs[e][o.crossTileID];
            }removeStaleBuckets(e) {
                let t = !1;for (const i in this.indexes) {
                    const o = this.indexes[i];for (const r in o) e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t = !0);
                }return t;
            }
        }class qt {
            constructor() {
                this.layerIndexes = {}, this.crossTileIDs = new Wt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }addLayer(e, t, i, o) {
                let r = this.layerIndexes[e.id];void 0 === r && (r = this.layerIndexes[e.id] = new Xt());let n = !1;const s = {};"globe" !== o.name && r.handleWrapJump(i);for (const i of t) {
                    const t = i.getBucket(e);t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t, this.crossTileIDs) && (n = !0), s[t.bucketInstanceId] = !0);
                }return r.removeStaleBuckets(s) && (n = !0), n;
            }pruneUnusedLayers(e) {
                const t = {};e.forEach(e => {
                    t[e] = !0;
                });for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];
            }
        }const $t = (t, i) => e.emitValidationErrors(t, i && i.filter(e => "source.canvas" !== e.identifier)),
              Ht = e.pick(We, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]),
              Yt = e.pick(We, ["setCenter", "setZoom", "setBearing", "setPitch"]),
              Kt = { version: 8, layers: [], sources: {} },
              Jt = { fill: !0, line: !0, background: !0, hillshade: !0, raster: !0 };class Qt extends e.Evented {
            constructor(t, i = {}) {
                super(), this.map = t, this.dispatcher = new z(je(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t._requestManager, i.localFontFamily ? e.LocalGlyphMode.all : i.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i.localFontFamily || i.localIdeographFontFamily), this.crossTileSymbolIndex = new qt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());const o = this;this._rtlTextPluginCallback = Qt.registerForPluginStateChange(t => {
                    o.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t.pluginStatus, pluginURL: t.pluginURL }, (t, i) => {
                        if (e.triggerPluginCompletionEvent(t), i && i.every(e => e)) for (const e in o._sourceCaches) {
                            const t = o._sourceCaches[e],
                                  i = t.getSource().type;"vector" !== i && "geojson" !== i || t.reload();
                        }
                    });
                }), this.on("data", e => {
                    if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;const t = this.getSource(e.sourceId);if (t && t.vectorLayerIds) for (const e in this._layers) {
                        const i = this._layers[e];i.source === t.id && this._validateLayer(i);
                    }
                });
            }loadURL(t, i = {}) {
                this.fire(new e.Event("dataloading", { dataType: "style" }));const o = "boolean" == typeof i.validate ? i.validate : !e.isMapboxURL(t);t = this.map._requestManager.normalizeStyleURL(t, i.accessToken);const r = this.map._requestManager.transformRequest(t, e.ResourceType.Style);this._request = e.getJSON(r, (t, i) => {
                    this._request = null, t ? this.fire(new e.ErrorEvent(t)) : i && this._load(i, o);
                });
            }loadJSON(t, i = {}) {
                this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame(() => {
                    this._request = null, this._load(t, !1 !== i.validate);
                });
            }loadEmpty() {
                this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(Kt, !1);
            }_updateLayerCount(e, t) {
                const i = t ? 1 : -1;e.is3D() && (this._num3DLayers += i), "circle" === e.type && (this._numCircleLayers += i), "symbol" === e.type && (this._numSymbolLayers += i);
            }_load(t, i) {
                if (i && $t(this, e.validateStyle(t))) return;this._loaded = !0, this.stylesheet = e.clone$1(t), this._updateMapProjection();for (const e in t.sources) this.addSource(e, t.sources[e], { validate: !1 });this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t.glyphs);const o = Ve(this.stylesheet.layers);this._order = o.map(e => e.id), this._layers = {}, this._serializedLayers = {};for (let t of o) t = e.createStyleLayer(t), t.setEventedParent(this, { layer: { id: t.id } }), this._layers[t.id] = t, this._serializedLayers[t.id] = t.serialize(), this._updateLayerCount(t, !0);this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load"));
            }terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }setProjection(e) {
                e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this._updateMapProjection();
            }applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
            }_updateMapProjection() {
                this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
            }_loadSprite(t) {
                this._spriteRequest = function (t, i, o) {
                    let r, n, s;const a = e.exported.devicePixelRatio > 1 ? "@2x" : "";let l = e.getJSON(i.transformRequest(i.normalizeSpriteURL(t, a, ".json"), e.ResourceType.SpriteJSON), (e, t) => {
                        l = null, s || (s = e, r = t, h());
                    }),
                        c = e.getImage(i.transformRequest(i.normalizeSpriteURL(t, a, ".png"), e.ResourceType.SpriteImage), (e, t) => {
                        c = null, s || (s = e, n = t, h());
                    });function h() {
                        if (s) o(s);else if (r && n) {
                            const t = e.exported.getImageData(n),
                                  i = {};for (const o in r) {
                                const { width: n, height: s, x: a, y: l, sdf: c, pixelRatio: h, stretchX: u, stretchY: _, content: d } = r[o],
                                      p = new e.RGBAImage({ width: n, height: s });e.RGBAImage.copy(t, p, { x: a, y: l }, { x: 0, y: 0 }, { width: n, height: s }), i[o] = { data: p, pixelRatio: h, sdf: c, stretchX: u, stretchY: _, content: d };
                            }o(null, i);
                        }
                    }return { cancel() {
                            l && (l.cancel(), l = null), c && (c.cancel(), c = null);
                        } };
                }(t, this.map._requestManager, (t, i) => {
                    if (this._spriteRequest = null, t) this.fire(new e.ErrorEvent(t));else if (i) for (const e in i) this.imageManager.addImage(e, i[e]);this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e.Event("data", { dataType: "style" }));
                });
            }_validateLayer(t) {
                const i = this.getSource(t.source);if (!i) return;const o = t.sourceLayer;o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t.id}"`)));
            }loaded() {
                if (!this._loaded) return !1;if (Object.keys(this._updatedSources).length) return !1;for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;return !!this.imageManager.isLoaded();
            }_serializeLayers(e) {
                const t = [];for (const i of e) {
                    const e = this._layers[i];"custom" !== e.type && t.push(e.serialize());
                }return t;
            }hasTransitions() {
                if (this.light && this.light.hasTransition()) return !0;if (this.fog && this.fog.hasTransition()) return !0;for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;return !1;
            }get order() {
                return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
            }isLayerDraped(e) {
                return !!this.terrain && ("function" == typeof e.isLayerDraped ? e.isLayerDraped() : Jt[e.type]);
            }_checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }update(t) {
                if (!this._loaded) return;const i = this._changed;if (this._changed) {
                    const e = Object.keys(this._updatedLayers),
                          i = Object.keys(this._removedLayers);(e.length || i.length) && this._updateWorkerLayers(e, i);for (const e in this._updatedSources) {
                        const t = this._updatedSources[e];"reload" === t ? this._reloadSource(e) : "clear" === t && this._clearSource(e);
                    }this._updateTilesForChangedImages();for (const e in this._updatedPaintProps) this._layers[e].updateTransitions(t);this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates();
                }const o = {};for (const e in this._sourceCaches) {
                    const t = this._sourceCaches[e];o[e] = t.used, t.used = !1;
                }for (const e of this._order) {
                    const i = this._layers[e];if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {
                        const e = this._getLayerSourceCache(i);e && (e.used = !0);
                    }const o = this.map.painter;if (o) {
                        const e = i.getProgramIds();if (!e) continue;const r = i.getProgramConfiguration(t.zoom);for (const t of e) o.useProgram(t, r);
                    }
                }for (const t in o) {
                    const i = this._sourceCaches[t];o[t] !== i.used && i.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i.getSource().id }));
                }this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i && this.fire(new e.Event("data", { dataType: "style" }));
            }_updateTilesForChangedImages() {
                const e = Object.keys(this._changedImages);if (e.length) {
                    for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e);this._changedImages = {};
                }
            }_updateWorkerLayers(e, t) {
                this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e), removedIds: t });
            }_resetUpdates() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }setState(i) {
                if (this._checkLoaded(), $t(this, e.validateStyle(i))) return !1;(i = e.clone$1(i)).layers = Ve(i.layers);const o = function (e, i) {
                    if (!e) return [{ command: We.setStyle, args: [i] }];let o = [];try {
                        if (!t(e.version, i.version)) return [{ command: We.setStyle, args: [i] }];t(e.center, i.center) || o.push({ command: We.setCenter, args: [i.center] }), t(e.zoom, i.zoom) || o.push({ command: We.setZoom, args: [i.zoom] }), t(e.bearing, i.bearing) || o.push({ command: We.setBearing, args: [i.bearing] }), t(e.pitch, i.pitch) || o.push({ command: We.setPitch, args: [i.pitch] }), t(e.sprite, i.sprite) || o.push({ command: We.setSprite, args: [i.sprite] }), t(e.glyphs, i.glyphs) || o.push({ command: We.setGlyphs, args: [i.glyphs] }), t(e.transition, i.transition) || o.push({ command: We.setTransition, args: [i.transition] }), t(e.light, i.light) || o.push({ command: We.setLight, args: [i.light] }), t(e.fog, i.fog) || o.push({ command: We.setFog, args: [i.fog] }), t(e.projection, i.projection) || o.push({ command: We.setProjection, args: [i.projection] });const r = {},
                              n = [];!function (e, i, o, r) {
                            let n;for (n in i = i || {}, e = e || {}) e.hasOwnProperty(n) && (i.hasOwnProperty(n) || qe(n, o, r));for (n in i) i.hasOwnProperty(n) && (e.hasOwnProperty(n) ? t(e[n], i[n]) || ("geojson" === e[n].type && "geojson" === i[n].type && He(e, i, n) ? o.push({ command: We.setGeoJSONSourceData, args: [n, i[n].data] }) : $e(n, i, o, r)) : Xe(n, i, o));
                        }(e.sources, i.sources, n, r);const s = [];e.layers && e.layers.forEach(e => {
                            e.source && r[e.source] ? o.push({ command: We.removeLayer, args: [e.id] }) : s.push(e);
                        });let a = e.terrain;a && r[a.source] && (o.push({ command: We.setTerrain, args: [void 0] }), a = void 0), o = o.concat(n), t(a, i.terrain) || o.push({ command: We.setTerrain, args: [i.terrain] }), function (e, i, o) {
                            i = i || [];const r = (e = e || []).map(Ke),
                                  n = i.map(Ke),
                                  s = e.reduce(Je, {}),
                                  a = i.reduce(Je, {}),
                                  l = r.slice(),
                                  c = Object.create(null);let h, u, _, d, p, m, f;for (h = 0, u = 0; h < r.length; h++) _ = r[h], a.hasOwnProperty(_) ? u++ : (o.push({ command: We.removeLayer, args: [_] }), l.splice(l.indexOf(_, u), 1));for (h = 0, u = 0; h < n.length; h++) _ = n[n.length - 1 - h], l[l.length - 1 - h] !== _ && (s.hasOwnProperty(_) ? (o.push({ command: We.removeLayer, args: [_] }), l.splice(l.lastIndexOf(_, l.length - u), 1)) : u++, m = l[l.length - h], o.push({ command: We.addLayer, args: [a[_], m] }), l.splice(l.length - h, 0, _), c[_] = !0);for (h = 0; h < n.length; h++) if (_ = n[h], d = s[_], p = a[_], !c[_] && !t(d, p)) if (t(d.source, p.source) && t(d["source-layer"], p["source-layer"]) && t(d.type, p.type)) {
                                for (f in Ye(d.layout, p.layout, o, _, null, We.setLayoutProperty), Ye(d.paint, p.paint, o, _, null, We.setPaintProperty), t(d.filter, p.filter) || o.push({ command: We.setFilter, args: [_, p.filter] }), t(d.minzoom, p.minzoom) && t(d.maxzoom, p.maxzoom) || o.push({ command: We.setLayerZoomRange, args: [_, p.minzoom, p.maxzoom] }), d) d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Ye(d[f], p[f], o, _, f.slice(6), We.setPaintProperty) : t(d[f], p[f]) || o.push({ command: We.setLayerProperty, args: [_, f, p[f]] }));for (f in p) p.hasOwnProperty(f) && !d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Ye(d[f], p[f], o, _, f.slice(6), We.setPaintProperty) : t(d[f], p[f]) || o.push({ command: We.setLayerProperty, args: [_, f, p[f]] }));
                            } else o.push({ command: We.removeLayer, args: [_] }), m = l[l.lastIndexOf(_) + 1], o.push({ command: We.addLayer, args: [p, m] });
                        }(s, i.layers, o);
                    } catch (e) {
                        console.warn("Unable to compute style diff:", e), o = [{ command: We.setStyle, args: [i] }];
                    }return o;
                }(this.serialize(), i).filter(e => !(e.command in Yt));if (0 === o.length) return !1;const r = o.filter(e => !(e.command in Ht));if (r.length > 0) throw new Error(`Unimplemented: ${r.map(e => e.command).join(", ")}.`);return o.forEach(e => {
                    "setTransition" !== e.command && "setProjection" !== e.command && this[e.command].apply(this, e.args);
                }), this.stylesheet = i, this._updateMapProjection(), !0;
            }addImage(t, i) {
                return this.getImage(t) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, i), this._afterImageUpdated(t), this);
            }updateImage(e, t) {
                this.imageManager.updateImage(e, t);
            }getImage(e) {
                return this.imageManager.getImage(e);
            }removeImage(t) {
                return this.getImage(t) ? (this.imageManager.removeImage(t), this._afterImageUpdated(t), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
            }_afterImageUpdated(t) {
                this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" }));
            }listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }addSource(t, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.getSource(t)) throw new Error("There is already a source with this ID");if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(e.validateSource, `sources.${t}`, i, null, o)) return;this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);const r = Pe(t, i, this.dispatcher, this);r.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(t), source: r.serialize(), sourceId: t }));const n = i => {
                    const o = (i ? "symbol:" : "other:") + t,
                          n = this._sourceCaches[o] = new e.SourceCache(o, r, i);(i ? this._symbolSourceCaches : this._otherSourceCaches)[t] = n, n.style = this, n.onAdd(this.map);
                };n(!1), "vector" !== i.type && "geojson" !== i.type || n(!0), r.onAdd && r.onAdd(this.map), this._changed = !0;
            }removeSource(t) {
                this._checkLoaded();const i = this.getSource(t);if (!i) throw new Error("There is no source with this ID");for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${i}" is using it.`)));if (this.terrain && this.terrain.get().source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));const o = this._getSourceCaches(t);for (const t of o) delete this._sourceCaches[t.id], delete this._updatedSources[t.id], t.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t.getSource().id })), t.setEventedParent(null), t.clearTiles();return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changed = !0, this;
            }setGeoJSONSourceData(e, t) {
                this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0;
            }getSource(e) {
                const t = this._getSourceCache(e);return t && t.getSource();
            }_getSources() {
                const e = [];for (const t in this._otherSourceCaches) {
                    const i = this._getSourceCache(t);i && e.push(i.getSource());
                }return e;
            }addLayer(t, i, o = {}) {
                this._checkLoaded();const r = t.id;if (this.getLayer(r)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));let n;if ("custom" === t.type) {
                    if ($t(this, e.validateCustomStyleLayer(t))) return;n = e.createStyleLayer(t);
                } else {
                    if ("object" == typeof t.source && (this.addSource(r, t.source), t = e.clone$1(t), t = e.extend(t, { source: r })), this._validate(e.validateLayer, `layers.${r}`, t, { arrayIndex: -1 }, o)) return;n = e.createStyleLayer(t), this._validateLayer(n), n.setEventedParent(this, { layer: { id: r } }), this._serializedLayers[n.id] = n.serialize(), this._updateLayerCount(n, !0);
                }const s = i ? this._order.indexOf(i) : this._order.length;if (i && -1 === s) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));this._order.splice(s, 0, r), this._layerOrderChanged = !0, this._layers[r] = n;const a = this._getLayerSourceCache(n);if (this._removedLayers[r] && n.source && a && "custom" !== n.type) {
                    const e = this._removedLayers[r];delete this._removedLayers[r], e.type !== n.type ? this._updatedSources[n.source] = "clear" : (this._updatedSources[n.source] = "reload", a.pause());
                }this._updateLayer(n), n.onAdd && n.onAdd(this.map), this._updateDrapeFirstLayers();
            }moveLayer(t, i) {
                if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));if (t === i) return;const o = this._order.indexOf(t);this._order.splice(o, 1);const r = i ? this._order.indexOf(i) : this._order.length;i && -1 === r ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(r, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());
            }removeLayer(t) {
                this._checkLoaded();const i = this._layers[t];if (!i) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));i.setEventedParent(null), this._updateLayerCount(i, !1);const o = this._order.indexOf(t);this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = i, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i.onRemove && i.onRemove(this.map), this._updateDrapeFirstLayers();
            }getLayer(e) {
                return this._layers[e];
            }hasLayer(e) {
                return e in this._layers;
            }hasLayerType(e) {
                for (const t in this._layers) if (this._layers[t].type === e) return !0;return !1;
            }setLayerZoomRange(t, i, o) {
                this._checkLoaded();const r = this.getLayer(t);r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)));
            }setFilter(i, o, r = {}) {
                this._checkLoaded();const n = this.getLayer(i);if (n) {
                    if (!t(n.filter, o)) return null == o ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(e.validateFilter, `layers.${n.id}.filter`, o, { layerType: n.type }, r) || (n.filter = e.clone$1(o), this._updateLayer(n)));
                } else this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));
            }getFilter(t) {
                const i = this.getLayer(t);return i && e.clone$1(i.filter);
            }setLayoutProperty(i, o, r, n = {}) {
                this._checkLoaded();const s = this.getLayer(i);s ? t(s.getLayoutProperty(o), r) || (s.setLayoutProperty(o, r, n), this._updateLayer(s)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }getLayoutProperty(t, i) {
                const o = this.getLayer(t);if (o) return o.getLayoutProperty(i);this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)));
            }setPaintProperty(i, o, r, n = {}) {
                this._checkLoaded();const s = this.getLayer(i);s ? t(s.getPaintProperty(o), r) || (s.setPaintProperty(o, r, n) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[i] = !0) : this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }getPaintProperty(e, t) {
                const i = this.getLayer(e);return i && i.getPaintProperty(t);
            }setFeatureState(t, i) {
                this._checkLoaded();const o = t.source,
                      r = t.sourceLayer,
                      n = this.getSource(o);if (!n) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));const s = n.type;if ("geojson" === s && r) return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));if ("vector" === s && !r) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));const a = this._getSourceCaches(o);for (const e of a) e.setFeatureState(r, t.id, i);
            }removeFeatureState(t, i) {
                this._checkLoaded();const o = t.source,
                      r = this.getSource(o);if (!r) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));const n = r.type,
                      s = "vector" === n ? t.sourceLayer : void 0;if ("vector" === n && !s) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));if (i && "string" != typeof t.id && "number" != typeof t.id) return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));const a = this._getSourceCaches(o);for (const e of a) e.removeFeatureState(s, t.id, i);
            }getFeatureState(t) {
                this._checkLoaded();const i = t.source,
                      o = t.sourceLayer,
                      r = this.getSource(i);if (r) {
                    if ("vector" !== r.type || o) return void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i)[0].getFeatureState(o, t.id);this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                } else this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
            }getTransition() {
                return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }serialize() {
                const t = {};for (const e in this._sourceCaches) {
                    const i = this._sourceCaches[e].getSource();t[i.id] || (t[i.id] = i.serialize());
                }return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t, layers: this._serializeLayers(this._order) }, e => void 0 !== e);
            }_updateLayer(e) {
                this._updatedLayers[e.id] = !0;const t = this._getLayerSourceCache(e);e.source && !this._updatedSources[e.source] && t && "raster" !== t.getSource().type && (this._updatedSources[e.source] = "reload", t.pause()), this._changed = !0, e.invalidateCompiledFilter();
            }_flattenAndSortRenderedFeatures(e) {
                const t = e => "fill-extrusion" === this._layers[e].type,
                      i = {},
                      o = [];for (let r = this._order.length - 1; r >= 0; r--) {
                    const n = this._order[r];if (t(n)) {
                        i[n] = r;for (const t of e) {
                            const e = t[n];if (e) for (const t of e) o.push(t);
                        }
                    }
                }o.sort((e, t) => t.intersectionZ - e.intersectionZ);const r = [];for (let n = this._order.length - 1; n >= 0; n--) {
                    const s = this._order[n];if (t(s)) for (let e = o.length - 1; e >= 0; e--) {
                        const t = o[e].feature;if (i[t.layer.id] < n) break;r.push(t), o.pop();
                    } else for (const t of e) {
                        const e = t[s];if (e) for (const t of e) r.push(t.feature);
                    }
                }return r;
            }queryRenderedFeatures(t, i, o) {
                i && i.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);const r = {};if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];for (const t of i.layers) {
                        const i = this._layers[t];if (!i) return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];r[i.source] = !0;
                    }
                }const n = [];i.availableImages = this._availableImages;const s = i && i.layers ? i.layers.some(e => {
                    const t = this.getLayer(e);return t && t.is3D();
                }) : this.has3DLayers(),
                      a = R.createFromScreenPoints(t, o);for (const e in this._sourceCaches) {
                    const t = this._sourceCaches[e].getSource().id;i.layers && !r[t] || n.push(Oe(this._sourceCaches[e], this._layers, this._serializedLayers, a, i, o, s, !!this.map._showQueryGeometry));
                }return this.placement && n.push(function (e, t, i, o, r, n, s) {
                    const a = {},
                          l = n.queryRenderedSymbols(o),
                          c = [];for (const e of Object.keys(l).map(Number)) c.push(s[e]);c.sort(ke);for (const i of c) {
                        const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);for (const e in o) {
                            const t = a[e] = a[e] || [],
                                  r = o[e];r.sort((e, t) => {
                                const o = i.featureSortOrder;if (o) {
                                    const i = o.indexOf(e.featureIndex);return o.indexOf(t.featureIndex) - i;
                                }return t.featureIndex - e.featureIndex;
                            });for (const e of r) t.push(e);
                        }
                    }for (const t in a) a[t].forEach(o => {
                        const r = o.feature,
                              n = i(e[t]).getFeatureState(r.layer["source-layer"], r.id);r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = n;
                    });return a;
                }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n);
            }querySourceFeatures(t, i) {
                i && i.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i.filter, null, i);const o = this._getSourceCaches(t);let r = [];for (const e of o) r = r.concat(Be(e, i));return r;
            }addSourceType(e, t, i) {
                return Qt.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : (Qt.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e, url: t.workerSourceURL }, i) : i(null, null));
            }getLight() {
                return this.light.getLight();
            }setLight(e, i = {}) {
                this._checkLoaded();const o = this.light.getLight();let r = !1;for (const i in e) if (!t(e[i], o[i])) {
                    r = !0;break;
                }if (!r) return;const n = this._setTransitionParameters({ duration: 300, delay: 0 });this.light.setLight(e, i), this.light.updateTransitions(n);
            }getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }setTerrainForDraping() {
                this.setTerrain({ source: "", exaggeration: 0 }, 0);
            }setTerrain(i, o = 1) {
                if (this._checkLoaded(), !i) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);if (1 === o) {
                    if ("object" == typeof i.source) {
                        const t = "terrain-dem-src";this.addSource(t, i.source), i = e.clone$1(i), i = e.extend(i, { source: t });
                    }if (this._validate(e.validateTerrain, "terrain", i)) return;
                }if (!this.terrain || this.terrain && o !== this.terrain.drapeRenderMode) this._createTerrain(i, o);else {
                    const o = this.terrain,
                          r = o.get();for (const t of Object.keys(e.spec.terrain)) !i.hasOwnProperty(t) && e.spec.terrain[t].default && (i[t] = e.spec.terrain[t].default);for (const e in i) if (!t(i[e], r[e])) {
                        o.set(i), this.stylesheet.terrain = i;const e = this._setTransitionParameters({ duration: 0 });o.updateTransitions(e);break;
                    }
                }this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }_createFog(e) {
                const t = this.fog = new A(e, this.map.transform);this.stylesheet.fog = e;const i = this._setTransitionParameters({ duration: 0 });t.updateTransitions(i);
            }_updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(() => {
                    for (const e of this.map._markers) e._evaluateOpacity();
                });
            }getFog() {
                return this.fog ? this.fog.get() : null;
            }setFog(e) {
                if (this._checkLoaded(), !e) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);if (this.fog) {
                    const i = this.fog,
                          o = i.get();0 === Object.keys(e).length && i.set(e);for (const r in e) if (!t(e[r], o[r])) {
                        i.set(e), this.stylesheet.fog = e;const t = this._setTransitionParameters({ duration: 0 });i.updateTransitions(t);break;
                    }
                } else this._createFog(e);this._markersNeedUpdate = !0;
            }_setTransitionParameters(t) {
                return { now: e.exported.now(), transition: e.extend(t, this.stylesheet.transition) };
            }_updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain) return;const e = this._order.filter(e => this.isLayerDraped(this._layers[e])),
                      t = this._order.filter(e => !this.isLayerDraped(this._layers[e]));this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);
            }_createTerrain(e, t) {
                const i = this.terrain = new M(e, t);this.stylesheet.terrain = e, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();const o = this._setTransitionParameters({ duration: 0 });i.updateTransitions(o);
            }_force3DLayerUpdate() {
                for (const e in this._layers) {
                    const t = this._layers[e];"fill-extrusion" === t.type && this._updateLayer(t);
                }
            }_forceSymbolLayerUpdate() {
                for (const e in this._layers) {
                    const t = this._layers[e];"symbol" === t.type && this._updateLayer(t);
                }
            }_validate(t, i, o, r, n = {}) {
                return (!n || !1 !== n.validate) && $t(this, t.call(e.validateStyle, e.extend({ key: i, style: this.serialize(), value: o, styleSpec: e.spec }, r)));
            }_remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);for (const e in this._layers) this._layers[e].setEventedParent(null);for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles(), this._sourceCaches[e].setEventedParent(null);this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }_clearSource(e) {
                const t = this._getSourceCaches(e);for (const e of t) e.clearTiles();
            }_reloadSource(e) {
                const t = this._getSourceCaches(e);for (const e of t) e.resume(), e.reload();
            }_reloadSources() {
                for (const e of this._getSources()) e.reload && e.reload();
            }_updateSources(e) {
                for (const t in this._sourceCaches) this._sourceCaches[t].update(e);
            }_generateCollisionBoxes() {
                for (const e in this._sourceCaches) {
                    const t = this._sourceCaches[e];t.resume(), t.reload();
                }
            }_updatePlacement(t, i, o, r, n = !1) {
                let s = !1,
                    a = !1;const l = {};for (const e of this._order) {
                    const i = this._layers[e];if ("symbol" !== i.type) continue;if (!l[i.source]) {
                        const e = this._getLayerSourceCache(i);if (!e) continue;l[i.source] = e.getRenderableIds(!0).map(t => e.getTileByID(t)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));
                    }const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], t.center.lng, t.projection);s = s || o;
                }if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t.zoom)) && (this.pauseablePlacement = new jt(t, this._order, n, i, o, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a = !0), s && this.pauseablePlacement.placement.setStale()), a || s) for (const e of this._order) {
                    const t = this._layers[e];"symbol" === t.type && this.placement.updateLayerOpacities(t, l[t.source]);
                }return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
            }_releaseSymbolFadeTiles() {
                for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();
            }getImages(e, t, i) {
                this.imageManager.getImages(t.icons, i), this._updateTilesForChangedImages();const o = e => {
                    e && e.setDependencies(t.tileID.key, t.type, t.icons);
                };o(this._otherSourceCaches[t.source]), o(this._symbolSourceCaches[t.source]);
            }getGlyphs(e, t, i) {
                this.glyphManager.getGlyphs(t.stacks, i);
            }getResource(t, i, o) {
                return e.makeRequest(i, o);
            }_getSourceCache(e) {
                return this._otherSourceCaches[e];
            }_getLayerSourceCache(e) {
                return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
            }_getSourceCaches(e) {
                const t = [];return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;
            }_isSourceCacheLoaded(t) {
                const i = this._getSourceCaches(t);return 0 === i.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))), !1) : i.every(e => e.loaded());
            }has3DLayers() {
                return this._num3DLayers > 0;
            }hasSymbolLayers() {
                return this._numSymbolLayers > 0;
            }hasCircleLayers() {
                return this._numCircleLayers > 0;
            }_clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }destroy() {
                this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }Qt.getSourceType = function (e) {
            return ze[e];
        }, Qt.setSourceType = function (e, t) {
            ze[e] = t;
        }, Qt.registerForPluginStateChange = e.registerForPluginStateChange;var ei = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0",
            ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",
            ii = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",
            oi = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",
            ri = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";let ni = {},
            si = {};const ai = [];_i(ei, ai), _i(ii, ai), _i(oi, ai), _i(ri, ai), ni = di("", ii), si = di(ri, oi);const li = di("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."),
              ci = ei,
              hi = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";var ui = { background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };function _i(e, t) {
            const i = e.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");for (let e of i) if (e = e.trim(), "#" === e[0] && e.includes("if") && !e.includes("endif")) {
                e = e.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();const i = e.split(" ");for (const e of i) t.includes(e) || t.push(e);
            }
        }function di(e, t) {
            const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
                  o = t.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g),
                  r = {},
                  n = [...ai];return _i(e, n), _i(t, n), { fragmentSource: e = e.replace(i, (e, t, i, o, n) => (r[n] = !0, "define" === t ? `\n#ifndef HAS_UNIFORM_u_${n}\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = u_${n};\n#endif\n`)), vertexSource: t = t.replace(i, (e, t, i, o, n) => {
                    const s = "float" === o ? "vec2" : "vec4",
                          a = n.match(/color/) ? "color" : s;return r[n] ? "define" === t ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : "define" === t ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`;
                }), staticAttributes: o, usedDefines: n };
        }class pi {
            constructor() {
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }bind(e, t, i, o, r, n, s) {
                this.context = e;let a = this.boundPaintVertexBuffers.length !== o.length;for (let e = 0; !a && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (a = !0);let l = this.boundDynamicVertexBuffers.length !== s.length;for (let e = 0; !l && e < s.length; e++) this.boundDynamicVertexBuffers[e] !== s[e] && (l = !0);if (!e.extVertexArrayObject || !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== r || this.boundVertexOffset !== n) this.freshBind(t, i, o, r, n, s);else {
                    e.bindVertexArrayOES.set(this.vao);for (const e of s) e && e.bind();r && r.dynamicDraw && r.bind();
                }
            }freshBind(e, t, i, o, r, n) {
                let s;const a = e.numAttributes,
                      l = this.context,
                      c = l.gl;if (l.extVertexArrayObject) this.vao && this.destroy(), this.vao = l.extVertexArrayObject.createVertexArrayOES(), l.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = n;else {
                    s = l.currentNumAttributes || 0;for (let e = a; e < s; e++) c.disableVertexAttribArray(e);
                }t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);for (const t of i) t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);for (const t of n) t && (t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r));o && o.bind(), l.currentNumAttributes = a;
            }destroy() {
                this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
        }function mi(t, i) {
            const o = Math.pow(2, i.canonical.z),
                  r = i.canonical.y;return [new e.MercatorCoordinate(0, r / o).toLngLat().lat, new e.MercatorCoordinate(0, (r + 1) / o).toLngLat().lat];
        }function fi(t, i, o, r, n, s, a) {
            const l = t.context,
                  c = l.gl,
                  h = o.fbo;if (!h) return;t.prepareDrawTile();const u = t.useProgram("hillshade");l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());const _ = ((e, t, i, o) => {
                const r = i.paint.get("hillshade-shadow-color"),
                      n = i.paint.get("hillshade-highlight-color"),
                      s = i.paint.get("hillshade-accent-color");let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);"viewport" === i.paint.get("hillshade-illumination-anchor") && (a -= e.transform.angle);const l = !e.options.moving;return { u_matrix: o || e.transform.calculateProjMatrix(t.tileID.toUnwrapped(), l), u_image: 0, u_latrange: mi(0, t.tileID), u_light: [i.paint.get("hillshade-exaggeration"), a], u_shadow: r, u_highlight: n, u_accent: s };
            })(t, o, r, t.terrain ? i.projMatrix : null);t.prepareDrawProgram(l, u, i.toUnwrapped());const { tileBoundsBuffer: d, tileBoundsIndexBuffer: p, tileBoundsSegments: m } = t.getTileBoundsBuffers(o);u.draw(l, c.TRIANGLES, n, s, a, e.CullFaceMode.disabled, _, r.id, d, p, m);
        }function gi(t, i, o) {
            if (!i.needsDEMTextureUpload) return;const r = t.context,
                  n = r.gl;r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);const s = o.getPixels();i.demTexture ? i.demTexture.update(s, { premultiply: !1 }) : i.demTexture = new e.Texture(r, s, n.RGBA, { premultiply: !1 }), i.needsDEMTextureUpload = !1;
        }function vi(t, i, o, r, n, s) {
            const a = t.context,
                  l = a.gl;if (!i.dem) return;const c = i.dem;if (a.activeTexture.set(l.TEXTURE1), gi(t, i, c), !i.demTexture) return;i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);const h = c.dim;a.activeTexture.set(l.TEXTURE0);let u = i.fbo;if (!u) {
                const t = new e.Texture(a, { width: h, height: h, data: null }, l.RGBA);t.bind(l.LINEAR, l.CLAMP_TO_EDGE), u = i.fbo = a.createFramebuffer(h, h, !0), u.colorAttachment.set(t.texture);
            }a.bindFramebuffer.set(u.framebuffer), a.viewport.set([0, 0, h, h]);const { tileBoundsBuffer: _, tileBoundsIndexBuffer: d, tileBoundsSegments: p } = t.getMercatorTileBoundsBuffers();t.useProgram("hillshadePrepare").draw(a, l.TRIANGLES, r, n, s, e.CullFaceMode.disabled, ((t, i) => {
                const o = i.stride,
                      r = e.create();return e.ortho(r, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r, r, [0, -e.EXTENT, 0]), { u_matrix: r, u_image: 1, u_dimension: [o, o], u_zoom: t.overscaledZ, u_unpack: i.unpackVector };
            })(i.tileID, c), o.id, _, d, p), i.needsHillshadePrepare = !1;
        }const xi = t => ({ u_matrix: new e.UniformMatrix4f(t), u_image0: new e.Uniform1i(t), u_skirt_height: new e.Uniform1f(t) }),
              yi = (e, t) => ({ u_matrix: e, u_image0: 0, u_skirt_height: t }),
              bi = (e, t, i, o, r, n, s, a, l, c, h, u, _, d, p) => ({ u_proj_matrix: Float32Array.from(e), u_globe_matrix: t, u_normalize_matrix: Float32Array.from(o), u_merc_matrix: i, u_zoom_transition: r, u_merc_center: n, u_image0: 0, u_frustum_tl: s, u_frustum_tr: a, u_frustum_br: l, u_frustum_bl: c, u_globe_pos: h, u_globe_radius: u, u_viewport: _, u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9), u_skirt_height: d });function wi(e, t) {
            return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;
        }const Ti = new class {
            constructor() {
                this.operations = {};
            }newMorphing(e, t, i, o, r) {
                if (e in this.operations) {
                    const t = this.operations[e];t.to.tileID.key !== i.tileID.key && (t.queued = i);
                } else this.operations[e] = { startTime: o, phase: 0, duration: r, from: t, to: i, queued: null };
            }getMorphValuesForProxy(e) {
                if (!(e in this.operations)) return null;const t = this.operations[e];return { from: t.from, to: t.to, phase: t.phase };
            }update(e) {
                for (const t in this.operations) {
                    const i = this.operations[t];for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {
                        delete this.operations[t];break;
                    }
                }
            }_nextOp(e, t) {
                return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);
            }_validOp(e) {
                return e.from.hasData() && e.to.hasData();
            }
        }(),
              Ei = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };function Ci(e) {
            return 6 * Math.pow(1.5, 22 - e);
        }function Mi(e, t) {
            const i = 1 << e.z;return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;
        }const Ii = e => ({ u_matrix: e });function Si(t, i, o, r, n) {
            if (n > 0) {
                const s = e.exported.now(),
                      a = (s - t.timeAdded) / n,
                      l = i ? (s - i.timeAdded) / n : -1,
                      c = o.getSource(),
                      h = r.coveringZoomLevel({ tileSize: c.tileSize, roundZoom: c.roundZoom }),
                      u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),
                      _ = u && t.refreshedUponExpiration ? 1 : e.clamp(u ? a : 1 - l, 0, 1);return t.refreshedUponExpiration && a >= 1 && (t.refreshedUponExpiration = !1), i ? { opacity: 1, mix: 1 - _ } : { opacity: _, mix: 0 };
            }return { opacity: 1, mix: 0 };
        }class Di extends e.SourceCache {
            constructor(e) {
                const t = { type: "raster-dem", maxzoom: e.transform.maxZoom },
                      i = new z(je(), null),
                      o = Pe("mock-dem", t, i, e.style);super("mock-dem", o, !1), o.setEventedParent(this), this._sourceLoaded = !0;
            }_loadTile(e, t) {
                e.state = "loaded", t(null);
            }
        }class Li extends e.SourceCache {
            constructor(e) {
                const t = Pe("proxy", { type: "geojson", maxzoom: e.transform.maxZoom }, new z(je(), null), e.style);super("proxy", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }update(t, i, o) {
                if (t.freezeTileCoverage) return;this.transform = t;const r = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i, o) => {
                    if (i[o.key] = "", !this._tiles[o.key]) {
                        const i = new e.Tile(o, this._source.tileSize * o.overscaleFactor(), t.tileZoom);i.state = "loaded", this._tiles[o.key] = i;
                    }return i;
                }, {});for (const e in this._tiles) e in r || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);
            }freeFBO(e) {
                const t = this.proxyCachedFBO[e];if (void 0 !== t) {
                    const i = Object.values(t);this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];
                }
            }deallocRenderCache() {
                this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
        }class Ai extends e.OverscaledTileID {
            constructor(e, t, i) {
                super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;
            }
        }class zi extends e.Elevation {
            constructor(t, i) {
                super(), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};const [o, r, n] = function (t) {
                    const i = new e.StructArrayLayout2i4(),
                          o = new e.StructArrayLayout3ui6(),
                          r = 131;i.reserve(17161), o.reserve(33800);const n = e.EXTENT / 128,
                          s = e.EXTENT + n / 2,
                          a = s + n;for (let t = -n; t < a; t += n) for (let o = -n; o < a; o += n) {
                        const r = o < 0 || o > s || t < 0 || t > s ? 24575 : 0,
                              n = e.clamp(Math.round(o), 0, e.EXTENT),
                              a = e.clamp(Math.round(t), 0, e.EXTENT);i.emplaceBack(n + r, a);
                    }const l = (e, t) => {
                        const i = t * r + e;o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);
                    };for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);return [0, 129].forEach(e => {
                        for (let t = 0; t < 130; t++) l(t, e), l(e, t);
                    }), [i, o, 32768];
                }(),
                      s = t.context;this.gridBuffer = s.createVertexBuffer(o, e.posAttributes.members), this.gridIndexBuffer = s.createIndexBuffer(r), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o.length, n), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Li(i.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1);const a = s.gl;this._overlapStencilMode = new e.StencilMode({ func: a.GEQUAL, mask: 255 }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Di(i.map);
            }set style(e) {
                e.on("data", this._onStyleDataEvent.bind(this)), e.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
                    this._clearLineLayersFromRenderCache();
                });
            }update(t, i, o) {
                if (t && t.terrain) {
                    this._style !== t && (this.style = t), this.enabled = !0;const r = t.terrain.properties;this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(r.get("source")), this._exaggeration = r.get("exaggeration");const n = () => {
                        this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);const t = this.getScaledDemTileSize();this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n(), this._initializing = !0), n(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;
                } else this._disable();
            }resetTileLookupCache(e) {
                this._findCoveringTileCache[e] = {};
            }getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }_checkRenderCacheEfficiency() {
                const t = this.renderCacheEfficiency(this._style);this._style.map._optimizeForTerrain || 100 !== t.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
            }_onStyleDataEvent(e) {
                e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this._invalidateRenderCache = !0);
            }_disable() {
                if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._sourceCaches) this._style._sourceCaches[e].usedForTerrain = !1;
            }destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
            }_source() {
                return this.enabled ? this.sourceCache : null;
            }isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }exaggeration() {
                return this._exaggeration;
            }get visibleDemTiles() {
                return this._visibleDemTiles;
            }get drapeBufferSize() {
                const e = 2 * this.proxySourceCache.getSource().tileSize;return [e, e];
            }set useVertexMorphing(e) {
                this._useVertexMorphing = e;
            }updateTileBinding(t) {
                if (!this.enabled) return;this.prevTerrainTileForTile = this.terrainTileForTile;const i = this.proxySourceCache,
                      o = this.painter.transform;this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);const r = this.proxyCoords = i.getIds().map(e => {
                    const t = i.getTileByID(e).tileID;return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;
                });!function (t, i) {
                    const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),
                          r = new e.pointGeometry(o.x, o.y);t.sort((t, i) => {
                        if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;const o = new e.pointGeometry(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),
                              n = new e.pointGeometry(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),
                              s = r.mult(1 << t.canonical.z);return s.x -= .5, s.y -= .5, s.distSqr(o) - s.distSqr(n);
                    });
                }(r, this.painter), this._previousZoom = o.zoom;const n = this.proxyToSource || {};this.proxyToSource = {}, r.forEach(e => {
                    this.proxyToSource[e.key] = {};
                }), this.terrainTileForTile = {};const s = this._style._sourceCaches;for (const e in s) {
                    const i = s[e];if (!i.used) continue;if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], n), i.usedForTerrain) continue;const o = t[e];i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
                }this.proxiedCoords[i.id] = r.map(e => new Ai(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n), this.renderingToTexture = !1, this._updateTimestamp = e.exported.now();const a = {};this._visibleDemTiles = [];for (const e of this.proxyCoords) {
                    const t = this.terrainTileForTile[e.key];if (!t) continue;const i = t.tileID.key;i in a || (this._visibleDemTiles.push(t), a[i] = i);
                }
            }_assignTerrainTiles(e) {
                this._initializing || e.forEach(e => {
                    if (this.terrainTileForTile[e.key]) return;const t = this._findTileCoveringTileID(e, this.sourceCache);t && (this.terrainTileForTile[e.key] = t);
                });
            }_prepareDEMTextures() {
                const e = this.painter.context,
                      t = e.gl;for (const i in this.terrainTileForTile) {
                    const o = this.terrainTileForTile[i],
                          r = o.dem;!r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), gi(this.painter, o, r));
                }
            }_prepareDemTileUniforms(e, t, i, o) {
                if (!t || null == t.demTexture) return !1;const r = e.tileID.canonical,
                      n = Math.pow(2, t.tileID.canonical.z - r.z),
                      s = o || "";return i[`u_dem_tl${s}`] = [r.x * n % 1, r.y * n % 1], i[`u_dem_scale${s}`] = n, !0;
            }get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }get emptyDepthBufferTexture() {
                const t = this.painter.context,
                      i = t.gl;if (!this._emptyDepthBufferTexture) {
                    const o = new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));this._emptyDepthBufferTexture = new e.Texture(t, o, i.RGBA, { premultiply: !1 });
                }return this._emptyDepthBufferTexture;
            }_getLoadedAreaMinimum() {
                let e = 0;const t = this._visibleDemTiles.reduce((t, i) => {
                    if (!i.dem) return t;const o = i.dem.tree.minimums[0];return o > 0 && e++, t + o;
                }, 0);return e ? t / e : 0;
            }_updateEmptyDEMTexture() {
                const t = this.painter.context,
                      i = t.gl;t.activeTexture.set(i.TEXTURE2);const o = this._getLoadedAreaMinimum(),
                      r = new e.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e.DEMData.pack(o, this.sourceCache.getSource().encoding)));this._emptyDEMTextureDirty = !1;let n = this._emptyDEMTexture;return n ? n.update(r, { premultiply: !1 }) : n = this._emptyDEMTexture = new e.Texture(t, r, i.RGBA, { premultiply: !1 }), n;
            }setupElevationDraw(t, i, o) {
                const r = this.painter.context,
                      n = r.gl,
                      s = (a = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(a), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });var a;s.u_dem_size = this.sourceCache.getSource().tileSize, s.u_exaggeration = this.exaggeration();let l = null,
                    c = null,
                    h = 1;if (o && o.morphing && this._useVertexMorphing) {
                    const e = o.morphing.srcDemTile,
                          i = o.morphing.dstDemTile;h = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, s, "_prev") && (c = e), this._prepareDemTileUniforms(t, i, s) && (l = i));
                }if (c && l ? (r.activeTexture.set(n.TEXTURE2), l.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), r.activeTexture.set(n.TEXTURE4), c.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), s.u_dem_lerp = h) : (l = this.terrainTileForTile[t.tileID.key], r.activeTexture.set(n.TEXTURE2), (this._prepareDemTileUniforms(t, l, s) ? l.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE)), r.activeTexture.set(n.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), s.u_depth_size_inv = [1, 1]), o && o.useMeterToDem && l) {
                    const t = (1 << l.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;s.u_meter_to_dem = t;
                }if (o && o.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, s), "globe" === this.painter.transform.projection.name) {
                    const e = this.globeUniformValues(this.painter.transform, t.tileID.canonical, o && o.useDenormalizedUpVectorScale);i.setGlobeUniformValues(r, e);
                }
            }globeUniformValues(t, i, o) {
                const r = t.projection;return { u_tile_tl_up: r.upVector(i, 0, 0), u_tile_tr_up: r.upVector(i, e.EXTENT, 0), u_tile_br_up: r.upVector(i, e.EXTENT, e.EXTENT), u_tile_bl_up: r.upVector(i, 0, e.EXTENT), u_tile_up_scale: o ? e.globeMetersToEcef(1) : r.upVectorScale(i, t.center.lat, t.worldSize).metersToTile };
            }renderToBackBuffer(t) {
                const i = this.painter,
                      o = this.painter.context;0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (t, i, o, r, n) {
                    if ("globe" === t.transform.projection.name) !function (t, i, o, r, n) {
                        const s = t.context,
                              a = s.gl;let l, c;const h = t.options.showTerrainWireframe ? 2 : 0,
                              u = t.transform,
                              _ = e.globeUseCustomAntiAliasing(t, s, u),
                              d = (e, i) => {
                            if (c === e) return;const o = [Ei[e], "PROJECTION_GLOBE_VIEW"];_ && o.push("CUSTOM_ANTIALIASING"), i && o.push(Ei[h]), l = t.useProgram("globeRaster", null, o), c = e;
                        },
                              p = t.colorModeForRenderPass(),
                              m = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);Ti.update(n);const f = e.calculateGlobeMercatorMatrix(u),
                              g = [e.mercatorXfromLng(u.center.lng), e.mercatorYfromLat(u.center.lat)],
                              v = h ? [!1, !0] : [!1],
                              x = t.globeSharedBuffers,
                              y = [u.width * e.exported.devicePixelRatio, u.height * e.exported.devicePixelRatio],
                              b = Float32Array.from(u.globeMatrix),
                              w = { useDenormalizedUpVectorScale: !0 };if (v.forEach(h => {
                            const u = t.transform,
                                  _ = Ci(u.zoom) * i.exaggeration();c = -1;const v = h ? a.LINES : a.TRIANGLES;for (const c of r) {
                                const r = o.getTile(c),
                                      T = e.StencilMode.disabled,
                                      E = i.prevTerrainTileForTile[c.key],
                                      C = i.terrainTileForTile[c.key];wi(E, C) && Ti.newMorphing(c.key, E, C, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);const M = Ti.getMorphValuesForProxy(c.key),
                                      I = M ? 1 : 0;M && e.extend$1(w, { morphing: { srcDemTile: M.from, dstDemTile: M.to, phase: e.easeCubicInOut(M.phase) } });const S = e.tileCornersToBounds(c.canonical),
                                      D = e.getLatitudinalLod(S.getCenter().lat),
                                      L = e.getGridMatrix(c.canonical, S, D, u.worldSize / u._pixelsPerMercatorPixel),
                                      A = e.globeNormalizeECEF(e.globeTileBounds(c.canonical)),
                                      z = bi(u.projMatrix, b, f, A, e.globeToMercatorTransition(u.zoom), g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, _, L);if (d(I, h), i.setupElevationDraw(r, l, w), t.prepareDrawProgram(s, l, c.toUnwrapped()), x) {
                                    const [i, o, r] = h ? x.getWirefameBuffers(t.context, D) : x.getGridBuffers(D, 0 !== _);l.draw(s, v, m, T, p, e.CullFaceMode.backCCW, z, "globe_raster", i, o, r);
                                }
                            }
                        }), x) {
                            const n = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];_ && n.push("CUSTOM_ANTIALIASING"), l = t.useProgram("globeRaster", null, n);for (const n of r) {
                                const { x: r, y: c, z: h } = n.canonical,
                                      _ = 0 === c,
                                      d = c === (1 << h) - 1,
                                      [f, v, b, T] = x.getPoleBuffers(h);if (T && (_ || d)) {
                                    const c = o.getTile(n);s.activeTexture.set(a.TEXTURE0), c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);let x = e.globePoleMatrixForTile(h, r, u);const E = e.globeNormalizeECEF(e.globeTileBounds(n.canonical)),
                                          C = (t, i) => t.draw(s, a.TRIANGLES, m, e.StencilMode.disabled, p, e.CullFaceMode.disabled, bi(u.projMatrix, x, x, E, 0, g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, 0), "globe_pole_raster", i, b, T);i.setupElevationDraw(c, l, w), t.prepareDrawProgram(s, l, n.toUnwrapped()), _ && C(l, f), d && (x = e.scale(e.create(), x, [1, -1, 1]), C(l, v));
                                }
                            }
                        }
                    }(t, i, o, r, n);else {
                        const s = t.context,
                              a = s.gl;let l, c;const h = t.options.showTerrainWireframe ? 2 : 0,
                              u = (e, i) => {
                            if (c === e) return;const o = [Ei[e]];i && o.push(Ei[h]), l = t.useProgram("terrainRaster", null, o), c = e;
                        },
                              _ = t.colorModeForRenderPass(),
                              d = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);Ti.update(n);const p = t.transform,
                              m = Ci(p.zoom) * i.exaggeration();(h ? [!1, !0] : [!1]).forEach(h => {
                            c = -1;const f = h ? a.LINES : a.TRIANGLES,
                                  [g, v] = h ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];for (const c of r) {
                                const r = o.getTile(c),
                                      x = e.StencilMode.disabled,
                                      y = i.prevTerrainTileForTile[c.key],
                                      b = i.terrainTileForTile[c.key];wi(y, b) && Ti.newMorphing(c.key, y, b, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);const w = Ti.getMorphValuesForProxy(c.key),
                                      T = w ? 1 : 0;let E;w && (E = { morphing: { srcDemTile: w.from, dstDemTile: w.to, phase: e.easeCubicInOut(w.phase) } });const C = yi(c.projMatrix, Mi(c.canonical, p.renderWorldCopies) ? m / 10 : m);u(T, h), i.setupElevationDraw(r, l, E), t.prepareDrawProgram(s, l, c.toUnwrapped()), l.draw(s, f, d, x, _, e.CullFaceMode.backCCW, C, "terrain_raster", i.gridBuffer, g, v);
                            }
                        });
                    }
                }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));
            }renderBatch(t) {
                if (0 === this._drapedRenderBatches.length) return t + 1;this.renderingToTexture = !0;const i = this.painter,
                      o = this.painter.context,
                      r = this.proxySourceCache,
                      n = this.proxiedCoords[r.id],
                      s = this._drapedRenderBatches.shift(),
                      a = [],
                      l = i.style.order;let c = 0;for (const h of n) {
                    const n = r.getTileByID(h.proxyTileKey),
                          u = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t] : void 0,
                          _ = void 0 !== u ? r.renderCache[u] : this.pool[c++],
                          d = void 0 !== u;if (n.texture = _.tex, d && !_.dirty) {
                        a.push(n.tileID);continue;
                    }let p;o.bindFramebuffer.set(_.fb.framebuffer), this.renderedToTile = !1, _.dirty && (o.clear({ color: e.Color.transparent, stencil: 0 }), _.dirty = !1);for (let e = s.start; e <= s.end; ++e) {
                        const t = i.style._layers[l[e]];if (t.isHidden(i.transform.zoom)) continue;const r = i.style._getLayerSourceCache(t),
                              n = r ? this.proxyToSource[h.key][r.id] : [h];if (!n) continue;const s = n;o.viewport.set([0, 0, _.fb.width, _.fb.height]), p !== (r ? r.id : null) && (this._setupStencil(_, n, t, r), p = r ? r.id : null), i.renderLayer(i, r, t, s);
                    }this.renderedToTile ? (_.dirty = !0, a.push(n.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(a));
                }return this.renderToBackBuffer(a), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), s.end + 1;
            }postRender() {}renderCacheEfficiency(e) {
                const t = e.order.length;if (0 === t) return { efficiency: 100 };let i,
                    o = 0,
                    r = 0,
                    n = !1;for (let s = 0; s < t; ++s) {
                    const t = e._layers[e.order[s]];this._style.isLayerDraped(t) ? (n && ++o, ++r) : n || (n = !0, i = t.id);
                }return 0 === r ? { efficiency: 100 } : { efficiency: 100 * (1 - o / r), firstUndrapedLayer: i };
            }getMinElevationBelowMSL() {
                let e = 0;return this._visibleDemTiles.filter(e => e.dem).forEach(t => {
                    e = Math.min(e, t.dem.tree.minimums[0]);
                }), 0 === e ? e : (e - 30) * this._exaggeration;
            }raycast(e, t, i) {
                if (!this._visibleDemTiles) return null;const o = this._visibleDemTiles.filter(e => e.dem).map(o => {
                    const r = o.tileID,
                          n = 1 << r.overscaledZ,
                          { x: s, y: a } = r.canonical,
                          l = s / n,
                          c = (s + 1) / n,
                          h = a / n,
                          u = (a + 1) / n;return { minx: l, miny: h, maxx: c, maxy: u, t: o.dem.tree.raycastRoot(l, h, c, u, e, t, i), tile: o };
                });o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));for (const r of o) {
                    if (null == r.t) return null;const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t, i);if (null != o) return o;
                }return null;
            }_createFBO() {
                const t = this.painter.context,
                      i = t.gl,
                      o = this.drapeBufferSize;t.activeTexture.set(i.TEXTURE0);const r = new e.Texture(t, { width: o[0], height: o[1], data: null }, i.RGBA);r.bind(i.LINEAR, i.CLAMP_TO_EDGE);const n = t.createFramebuffer(o[0], o[1], !1);return n.colorAttachment.set(r.texture), n.depthAttachment = new Ee(t, n.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, n.depthAttachment.set(this._sharedDepthStencil), t.clear({ stencil: 0 })) : n.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && !t.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), { fb: n, tex: r, dirty: !1 };
            }_initFBOPool() {
                for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());
            }_shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition()) return !0;for (const e in this._style._sourceCaches) if (this._style._sourceCaches[e].hasTransition()) return !0;return this._style.order.some(e => {
                    const t = this._style._layers[e],
                          i = t.isHidden(this.painter.transform.zoom);return "custom" === t.type ? !i && t.shouldRedrape() : !i && t.hasTransition();
                });
            }_clearLineLayersFromRenderCache() {
                let t = !1;for (const e of this._style._getSources()) if (e instanceof Ie) {
                    t = !0;break;
                }if (!t) return;const i = {};for (let t = 0; t < this._style.order.length; ++t) {
                    const o = this._style._layers[this._style.order[t]],
                          r = this._style._getLayerSourceCache(o);if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && "line" === o.type && o.widthExpression() instanceof e.ZoomDependentExpression) {
                        i[r.id] = !0;for (const e of this.proxyCoords) {
                            const t = this.proxyToSource[e.key][r.id];if (t) for (const e of t) this._clearRenderCacheForTile(r.id, e);
                        }
                    }
                }
            }_clearRasterLayersFromRenderCache() {
                let e = !1;for (const t in this._style._sourceCaches) if (this._style._sourceCaches[t]._source instanceof Se) {
                    e = !0;break;
                }if (!e) return;const t = {};for (let e = 0; e < this._style.order.length; ++e) {
                    const i = this._style._layers[this._style.order[e]],
                          o = this._style._getLayerSourceCache(i);if (!o || t[o.id]) continue;if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;const r = i.paint.get("raster-fade-duration");for (const e of this.proxyCoords) {
                        const t = this.proxyToSource[e.key][o.id];if (t) for (const e of t) {
                            const t = Si(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);(1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);
                        }
                    }
                }
            }_setupDrapedRenderBatches() {
                const e = this._style.order,
                      t = e.length;if (0 === t) return;const i = [];let o,
                    r = 0,
                    n = this._style._layers[e[r]];for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < t;) n = this._style._layers[e[r]];for (; r < t; ++r) {
                    const t = this._style._layers[e[r]];t.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t) ? void 0 === o && (o = r) : void 0 !== o && (i.push({ start: o, end: r - 1 }), o = void 0));
                }void 0 !== o && i.push({ start: o, end: r - 1 }), this._drapedRenderBatches = i;
            }_setupRenderCache(e) {
                const t = this.proxySourceCache;if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                    if (this._invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {
                        const e = Object.values(t.proxyCachedFBO);t.proxyCachedFBO = {};for (let i = 0; i < e.length; ++i) {
                            const o = Object.values(e[i]);t.renderCachePool.push(...o);
                        }
                    }return;
                }this._clearRasterLayersFromRenderCache();const i = this.proxyCoords,
                      o = this._tilesDirty;for (let r = i.length - 1; r >= 0; r--) {
                    const n = i[r];if (t.getTileByID(n.key), void 0 !== t.proxyCachedFBO[n.key]) {
                        const i = e[n.key],
                              r = this.proxyToSource[n.key];let s = 0;for (const e in r) {
                            const t = r[e],
                                  n = i[e];if (!n || n.length !== t.length || t.some((t, i) => t !== n[i] || o[e] && o[e].hasOwnProperty(t.key))) {
                                s = -1;break;
                            }++s;
                        }for (const e in t.proxyCachedFBO[n.key]) t.renderCache[t.proxyCachedFBO[n.key][e]].dirty = s < 0 || s !== Object.values(i).length;
                    }
                }const r = [...this._drapedRenderBatches];r.sort((e, t) => t.end - t.start - (e.end - e.start));for (const e of r) for (const o of i) {
                    if (t.proxyCachedFBO[o.key]) continue;let i = t.renderCachePool.pop();void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);
                }this._tilesDirty = {};
            }_setupStencil(e, t, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));const r = this.painter.context,
                      n = r.gl;if (t.length <= 1) return void (this._overlapStencilType = !1);let s;if (i.isTileClipped()) s = t.length, this._overlapStencilMode.test = { func: n.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";else {
                    if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);s = 1, this._overlapStencilMode.test = { func: n.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
                }this._stencilRef + s > 255 && (r.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);
            }clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }stencilModeForRTTOverlap(t) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : e.StencilMode.disabled;
            }_renderTileClippingMasks(t, i) {
                const o = this.painter,
                      r = this.painter.context,
                      n = r.gl;o._tileClippingMaskIDs = {}, r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);const s = o.useProgram("clippingMask");for (const a of t) {
                    const t = o._tileClippingMaskIDs[a.key] = --i;s.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n.ALWAYS, mask: 0 }, t, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(a.projMatrix), "$clipping", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);
                }
            }pointCoordinate(t) {
                const i = this.painter.transform;if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;const o = [t.x, t.y, 1, 1];e.transformMat4$1(o, o, i.pixelMatrixInverse), e.scale$1(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;const r = i._camera.position,
                      n = e.mercatorZfromAltitude(1, i.center.lat),
                      s = [r[0], r[1], r[2] / n, 0],
                      a = e.subtract([], o.slice(0, 3), s);e.normalize(a, a);const l = this.raycast(s, a, this._exaggeration);return null !== l && l ? (e.scaleAndAdd(s, s, a, l), s[3] = s[2], s[2] *= n, s) : null;
            }drawDepth() {
                const t = this.painter,
                      i = t.context,
                      o = this.proxySourceCache,
                      r = Math.ceil(t.width),
                      n = Math.ceil(t.height);if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
                    const t = i.gl,
                          o = i.createFramebuffer(r, n, !0);i.activeTexture.set(t.TEXTURE0);const s = new e.Texture(i, { width: r, height: n, data: null }, t.RGBA);s.bind(t.NEAREST, t.CLAMP_TO_EDGE), o.colorAttachment.set(s.texture);const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, n);o.depthAttachment.set(a), this._depthFBO = o, this._depthTexture = s;
                }i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([0, 0, r, n]), function (t, i, o, r) {
                    if ("globe" === t.transform.projection.name) return;const n = t.context,
                          s = n.gl;n.clear({ depth: 1 });const a = t.useProgram("terrainDepth"),
                          l = new e.DepthMode(s.LESS, e.DepthMode.ReadWrite, t.depthRangeFor3D);for (const t of r) {
                        const r = o.getTile(t),
                              c = yi(t.projMatrix, 0);i.setupElevationDraw(r, a), a.draw(n, s.TRIANGLES, l, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);
                    }
                }(t, this, o, this.proxyCoords);
            }_setupProxiedCoordsForOrtho(e, t, i) {
                if (e.getSource() instanceof Ae) return this._setupProxiedCoordsForImageSource(e, t, i);this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {};const o = this.proxiedCoords[e.id] = [],
                      r = this.proxyCoords;for (let t = 0; t < r.length; t++) {
                    const n = r[t],
                          s = this._findTileCoveringTileID(n, e);if (s) {
                        const t = this._createProxiedId(n, s, i[n.key] && i[n.key][e.id]);o.push(t), this.proxyToSource[n.key][e.id] = [t];
                    }
                }let n = !1;for (let r = 0; r < t.length; r++) {
                    const s = e.getTile(t[r]);if (!s || !s.hasData()) continue;const a = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {
                        const t = this.proxyToSource[a.tileID.key][e.id],
                              r = this._createProxiedId(a.tileID, s, i[a.tileID.key] && i[a.tileID.key][e.id]);t ? t.splice(t.length - 1, 0, r) : this.proxyToSource[a.tileID.key][e.id] = [r], o.push(r), n = !0;
                    }
                }this._sourceTilesOverlap[e.id] = n;
            }_setupProxiedCoordsForImageSource(t, i, o) {
                if (!t.getSource().loaded()) return;const r = this.proxiedCoords[t.id] = [],
                      n = this.proxyCoords,
                      s = t.getSource(),
                      a = new e.pointGeometry(s.tileID.x, s.tileID.y)._div(1 << s.tileID.z),
                      l = s.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - a.x), e.min.y = Math.min(e.min.y, t.y - a.y), e.max.x = Math.max(e.max.x, t.x - a.x), e.max.y = Math.max(e.max.y, t.y - a.y), e), { min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }),
                      c = (t, i) => {
                    const o = t.wrap + t.canonical.x / (1 << t.canonical.z),
                          r = t.canonical.y / (1 << t.canonical.z),
                          n = e.EXTENT / (1 << t.canonical.z),
                          s = i.wrap + i.canonical.x / (1 << i.canonical.z),
                          a = i.canonical.y / (1 << i.canonical.z);return o + n < s + l.min.x || o > s + l.max.x || r + n < a + l.min.y || r > a + l.max.y;
                };for (let e = 0; e < n.length; e++) {
                    const s = n[e];for (let e = 0; e < i.length; e++) {
                        const n = t.getTile(i[e]);if (!n || !n.hasData()) continue;if (c(s, n.tileID)) continue;const a = this._createProxiedId(s, n, o[s.key] && o[s.key][t.id]),
                              l = this.proxyToSource[s.key][t.id];l ? l.push(a) : this.proxyToSource[s.key][t.id] = [a], r.push(a);
                    }
                }
            }_createProxiedId(t, i, o) {
                let r = this.orthoMatrix;if (o) {
                    const e = o.find(e => e.key === i.tileID.key);if (e) return e;
                }if (i.tileID.key !== t.key) {
                    const o = t.canonical.z - i.tileID.canonical.z;let n, s, a;r = e.create();const l = i.tileID.wrap - t.wrap << t.overscaledZ;o > 0 ? (n = e.EXTENT >> o, s = n * ((i.tileID.canonical.x << o) - t.canonical.x + l), a = n * ((i.tileID.canonical.y << o) - t.canonical.y)) : (n = e.EXTENT << -o, s = e.EXTENT * (i.tileID.canonical.x - (t.canonical.x + l << -o)), a = e.EXTENT * (i.tileID.canonical.y - (t.canonical.y << -o))), e.ortho(r, 0, n, 0, n, 0, 1), e.translate(r, r, [s, a, 0]);
                }return new Ai(i.tileID, t.key, r);
            }_findTileCoveringTileID(t, i) {
                let o = i.getTile(t);if (o && o.hasData()) return o;const r = this._findCoveringTileCache[i.id],
                      n = r[t.key];if (o = n ? i.getTileByID(n) : null, o && o.hasData() || null === n) return o;let s = o ? o.tileID : t,
                    a = s.overscaledZ;const l = i.getSource().minzoom,
                      c = [];if (!n) {
                    const r = i.getSource().maxzoom;if (t.canonical.z >= r) {
                        const o = t.canonical.z - r;i.getSource().reparseOverscaled ? (a = Math.max(t.canonical.z + 2, i.transform.tileZoom), s = new e.OverscaledTileID(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (a = r, s = new e.OverscaledTileID(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o));
                    }s.key !== t.key && (c.push(s.key), o = i.getTile(s));
                }const h = e => {
                    c.forEach(t => {
                        r[t] = e;
                    }), c.length = 0;
                };for (a -= 1; a >= l && (!o || !o.hasData()); a--) {
                    o && h(o.tileID.key);const e = s.calculateScaledKey(a);if (o = i.getTileByID(e), o && o.hasData()) break;const t = r[e];if (null === t) break;void 0 === t ? c.push(e) : o = i.getTileByID(t);
                }return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
            }findDEMTileFor(e) {
                return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
            }prepareDrawTile() {
                this.renderedToTile = !0;
            }_clearRenderCacheForTile(e, t) {
                let i = this._tilesDirty[e];i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;
            }getWirefameBuffer() {
                if (!this.wireframeSegments) {
                    const t = function (t) {
                        let i = 0;const o = new e.StructArrayLayout2ui4(),
                              r = 131;for (let e = 1; e < 129; e++) {
                            for (let t = 1; t < 129; t++) i = e * r + t, o.emplaceBack(i, i + 1), o.emplaceBack(i, i + r), o.emplaceBack(i + 1, i + r), 128 === e && o.emplaceBack(i + r, i + r + 1);o.emplaceBack(i + 1, i + 1 + r);
                        }return o;
                    }();this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t.length);
                }return [this.wireframeIndexBuffer, this.wireframeSegments];
            }
        }class Pi {
            static cacheKey(e, t, i, o) {
                let r = `${t}${o ? o.cacheKey : ""}`;for (const t of i) e.usedDefines.includes(t) && (r += `/${t}`);return r;
            }constructor(t, i, o, r, n, s) {
                const a = t.gl;this.program = a.createProgram();const l = function (e) {
                    const t = [];for (let i = 0; i < e.length; i++) {
                        if (null === e[i]) continue;const o = e[i].split(" ");t.push(o.pop());
                    }return t;
                }(o.staticAttributes),
                      c = r ? r.getBinderAttributes() : [],
                      h = l.concat(c);let u = r ? r.defines() : [];u = u.concat(s.map(e => `#define ${e}`));const _ = t.isWebGL2 ? "#version 300 es\n" : "",
                      d = _ + u.concat(t.extStandardDerivatives && 0 === _.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(hi) : hi, hi, ci, li.fragmentSource, si.fragmentSource, o.fragmentSource).join("\n"),
                      p = _ + u.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ci, li.vertexSource, si.vertexSource, ni.vertexSource, o.vertexSource).join("\n"),
                      m = a.createShader(a.FRAGMENT_SHADER);if (a.isContextLost()) return void (this.failedToCreate = !0);a.shaderSource(m, d), a.compileShader(m), a.attachShader(this.program, m);const f = a.createShader(a.VERTEX_SHADER);if (a.isContextLost()) this.failedToCreate = !0;else {
                    a.shaderSource(f, p), a.compileShader(f), a.attachShader(this.program, f), this.attributes = {}, this.numAttributes = h.length;for (let e = 0; e < this.numAttributes; e++) h[e] && (a.bindAttribLocation(this.program, e, h[e]), this.attributes[h[e]] = e);a.linkProgram(this.program), a.deleteShader(f), a.deleteShader(m), this.fixedUniforms = n(t), this.binderUniforms = r ? r.getUniforms(t) : [], s.includes("TERRAIN") && (this.terrainUniforms = (t => ({ u_dem: new e.Uniform1i(t), u_dem_prev: new e.Uniform1i(t), u_dem_unpack: new e.Uniform4f(t), u_dem_tl: new e.Uniform2f(t), u_dem_scale: new e.Uniform1f(t), u_dem_tl_prev: new e.Uniform2f(t), u_dem_scale_prev: new e.Uniform1f(t), u_dem_size: new e.Uniform1f(t), u_dem_lerp: new e.Uniform1f(t), u_exaggeration: new e.Uniform1f(t), u_depth: new e.Uniform1i(t), u_depth_size_inv: new e.Uniform2f(t), u_meter_to_dem: new e.Uniform1f(t), u_label_plane_matrix_inv: new e.UniformMatrix4f(t) }))(t)), s.includes("GLOBE") && (this.globeUniforms = (t => ({ u_tile_tl_up: new e.Uniform3f(t), u_tile_tr_up: new e.Uniform3f(t), u_tile_br_up: new e.Uniform3f(t), u_tile_bl_up: new e.Uniform3f(t), u_tile_up_scale: new e.Uniform1f(t) }))(t)), s.includes("FOG") && (this.fogUniforms = (t => ({ u_fog_matrix: new e.UniformMatrix4f(t), u_fog_range: new e.Uniform2f(t), u_fog_color: new e.Uniform4f(t), u_fog_horizon_blend: new e.Uniform1f(t), u_fog_temporal_offset: new e.Uniform1f(t), u_frustum_tl: new e.Uniform3f(t), u_frustum_tr: new e.Uniform3f(t), u_frustum_br: new e.Uniform3f(t), u_frustum_bl: new e.Uniform3f(t), u_globe_pos: new e.Uniform3f(t), u_globe_radius: new e.Uniform1f(t), u_globe_transition: new e.Uniform1f(t), u_is_globe: new e.Uniform1i(t), u_viewport: new e.Uniform2f(t) }))(t));
                }
            }setTerrainUniformValues(e, t) {
                if (!this.terrainUniforms) return;const i = this.terrainUniforms;if (!this.failedToCreate) {
                    e.program.set(this.program);for (const e in t) i[e] && i[e].set(this.program, e, t[e]);
                }
            }setGlobeUniformValues(e, t) {
                if (!this.globeUniforms) return;const i = this.globeUniforms;if (!this.failedToCreate) {
                    e.program.set(this.program);for (const e in t) i[e] && i[e].set(this.program, e, t[e]);
                }
            }setFogUniformValues(e, t) {
                if (!this.fogUniforms) return;const i = this.fogUniforms;if (!this.failedToCreate) {
                    e.program.set(this.program);for (const e in t) i[e].set(this.program, e, t[e]);
                }
            }draw(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p) {
                const m = e.gl;if (this.failedToCreate) return;e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(o), e.setColorMode(r), e.setCullFace(n);for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(this.program, e, s[e]);d && d.setUniforms(this.program, e, this.binderUniforms, u, { zoom: _ });const f = { [m.LINES]: 2, [m.TRIANGLES]: 3, [m.LINE_STRIP]: 1 }[t];for (const i of h.get()) {
                    const o = i.vaos || (i.vaos = {});(o[a] || (o[a] = new pi())).bind(e, this, l, d ? d.getPaintVertexBuffers() : [], c, i.vertexOffset, p || []), m.drawElements(t, i.primitiveLength * f, m.UNSIGNED_SHORT, i.primitiveOffset * f * 2);
                }
            }
        }function Ri(e, t) {
            const i = Math.pow(2, t.tileID.overscaledZ),
                  o = t.tileSize * Math.pow(2, e.transform.tileZoom) / i,
                  r = o * (t.tileID.canonical.x + t.tileID.wrap * i),
                  n = o * t.tileID.canonical.y;return { u_image: 0, u_texsize: t.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / P(t, 1, e.transform.tileZoom), u_pixel_coord_upper: [r >> 16, n >> 16], u_pixel_coord_lower: [65535 & r, 65535 & n] };
        }const Oi = e.create(),
              Bi = (t, i, o, r, n, s, a, l, c, h, u) => {
            const _ = i.style.light,
                  d = _.properties.get("position"),
                  p = [d.x, d.y, d.z],
                  m = e.create$1();"viewport" === _.properties.get("anchor") && (e.fromRotation(m, -i.transform.angle), e.transformMat3(p, p, m));const f = _.properties.get("color"),
                  g = i.transform,
                  v = { u_matrix: t, u_lightpos: p, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [f.r, f.g, f.b], u_vertical_gradient: +o, u_opacity: r, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Oi, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n, u_edge_radius: s };return "globe" === g.projection.name && (v.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z], v.u_zoom_transition = c, v.u_inv_rot_matrix = u, v.u_merc_center = h, v.u_up_dir = g.projection.upVector(new e.CanonicalTileID(0, 0, 0), h[0] * e.EXTENT, h[1] * e.EXTENT), v.u_height_lift = l), v;
        },
              ki = (t, i, o, r, n, s, a, l, c, h, u, _) => {
            const d = Bi(t, i, o, r, n, s, a, c, h, u, _),
                  p = { u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8 };return e.extend(d, Ri(i, l), p);
        },
              Fi = e => ({ u_matrix: e }),
              Ui = (t, i, o) => e.extend(Fi(t), Ri(i, o)),
              Ni = (e, t) => ({ u_matrix: e, u_world: t }),
              Gi = (t, i, o, r) => e.extend(Ui(t, i, o), { u_world: r }),
              ji = e.create(),
              Zi = (t, i, o, r, n, s) => {
            const a = t.transform,
                  l = "globe" === a.projection.name;let c;if ("map" === s.paint.get("circle-pitch-alignment")) {
                if (l) {
                    const t = e.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;c = Float32Array.from([t, 0, 0, t]);
                } else c = a.calculatePixelsToTileUnitsMatrix(o);
            } else c = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]);const h = { u_camera_to_center_distance: a.cameraToCenterDistance, u_matrix: t.translatePosMatrix(i.projMatrix, o, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: c, u_inv_rot_matrix: ji, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };if (l) {
                h.u_inv_rot_matrix = r, h.u_merc_center = n, h.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], h.u_zoom_transition = e.globeToMercatorTransition(a.zoom);const t = n[0] * e.EXTENT,
                      o = n[1] * e.EXTENT;h.u_up_dir = a.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, o);
            }return h;
        },
              Vi = e => {
            const t = [];return "map" === e.paint.get("circle-pitch-alignment") && t.push("PITCH_WITH_MAP"), "map" === e.paint.get("circle-pitch-scale") && t.push("SCALE_WITH_MAP"), t;
        },
              Wi = (t, i, o, r) => {
            const n = e.EXTENT / o.tileSize;return { u_matrix: t, u_camera_to_center_distance: i.getCameraToCenterDistance(r), u_extrude_scale: [i.pixelsToGLUnits[0] / n, i.pixelsToGLUnits[1] / n] };
        },
              Xi = (e, t, i = 1) => ({ u_matrix: e, u_color: t, u_overlay: 0, u_overlay_scale: i }),
              qi = e.create(),
              $i = (t, i, o, r, n, s, a) => {
            const l = t.transform,
                  c = "globe" === l.projection.name,
                  h = c ? e.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : P(o, 1, s),
                  u = { u_matrix: i.projMatrix, u_extrude_scale: h, u_intensity: a, u_inv_rot_matrix: qi, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };if (c) {
                u.u_inv_rot_matrix = r, u.u_merc_center = n, u.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], u.u_zoom_transition = e.globeToMercatorTransition(l.zoom);const t = n[0] * e.EXTENT,
                      o = n[1] * e.EXTENT;u.u_up_dir = l.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, o);
            }return u;
        },
              Hi = (e, t, i, o, r, n, s) => {
            const a = e.transform,
                  l = a.calculatePixelsToTileUnitsMatrix(t);return { u_matrix: Ji(e, t, i, o), u_pixels_to_tile_units: l, u_device_pixel_ratio: n, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: r, u_texsize: Qi(i) ? t.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ki(t, e.transform), u_alpha_discard_threshold: 0, u_trim_offset: s };
        },
              Yi = (e, t, i, o, r) => {
            const n = e.transform;return { u_matrix: Ji(e, t, i, o), u_texsize: t.imageAtlasTexture.size, u_pixels_to_tile_units: n.calculatePixelsToTileUnitsMatrix(t), u_device_pixel_ratio: r, u_image: 0, u_tile_units_to_pixels: Ki(t, n), u_units_to_pixels: [1 / n.pixelsToGLUnits[0], 1 / n.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
        };function Ki(e, t) {
            return 1 / P(e, 1, t.tileZoom);
        }function Ji(e, t, i, o) {
            return e.translatePosMatrix(o || t.tileID.projMatrix, t, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
        }function Qi(e) {
            const t = e.paint.get("line-dasharray").value;return t.value || "constant" !== t.kind;
        }const eo = (e, t, i, o, r, n) => {
            return { u_matrix: e, u_tl_parent: t, u_scale_parent: i, u_fade_t: o.mix, u_opacity: o.opacity * r.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r.paint.get("raster-brightness-min"), u_brightness_high: r.paint.get("raster-brightness-max"), u_saturation_factor: (a = r.paint.get("raster-saturation"), a > 0 ? 1 - 1 / (1.001 - a) : -a), u_contrast_factor: (s = r.paint.get("raster-contrast"), s > 0 ? 1 / (1 - s) : 1 + s), u_spin_weights: to(r.paint.get("raster-hue-rotate")), u_perspective_transform: n };var s, a;
        };function to(e) {
            e *= Math.PI / 180;const t = Math.sin(e),
                  i = Math.cos(e);return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];
        }const io = e.create(),
              oo = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f) => {
            const g = n.transform,
                  v = { u_is_size_zoom_constant: +("constant" === t || "source" === t), u_is_size_feature_constant: +("constant" === t || "camera" === t), u_size_t: i ? i.uSizeT : 0, u_size: i ? i.uSize : 0, u_camera_to_center_distance: g.cameraToCenterDistance, u_rotate_symbol: +o, u_aspect_ratio: g.width / g.height, u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1, u_matrix: s, u_label_plane_matrix: a, u_coord_matrix: l, u_is_text: +c, u_pitch_with_map: +r, u_texsize: h, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: io, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: io, u_up_vector: [0, -1, 0] };return "globe" === f.name && (v.u_tile_id = [u.canonical.x, u.canonical.y, 1 << u.canonical.z], v.u_zoom_transition = _, v.u_inv_rot_matrix = p, v.u_merc_center = d, v.u_camera_forward = g._camera.forward(), v.u_ecef_origin = e.globeECEFOrigin(g.globeMatrix, u.toUnwrapped()), v.u_tile_matrix = Float32Array.from(g.globeMatrix), v.u_up_vector = m), v;
        },
              ro = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) => e.extend(oo(t, i, o, r, n, s, a, l, c, h, _, d, p, m, f, g), { u_gamma_scale: r ? n.transform.cameraToCenterDistance * Math.cos(n.terrain ? 0 : n.transform._pitch) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +u }),
              no = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f) => e.extend(ro(t, i, o, r, n, s, a, l, !0, c, !0, u, _, d, p, m, f), { u_texsize_icon: h, u_texture_icon: 1 }),
              so = (e, t, i) => ({ u_matrix: e, u_opacity: t, u_color: i }),
              ao = (t, i, o, r, n) => e.extend(function (e, t, i) {
            const o = t.imageManager.getPattern(e.toString()),
                  { width: r, height: n } = t.imageManager.getPixelSize(),
                  s = Math.pow(2, i.tileID.overscaledZ),
                  a = i.tileSize * Math.pow(2, t.transform.tileZoom) / s,
                  l = a * (i.tileID.canonical.x + i.tileID.wrap * s),
                  c = a * i.tileID.canonical.y;return { u_image: 0, u_pattern_tl: o.tl, u_pattern_br: o.br, u_texsize: [r, n], u_pattern_size: o.displaySize, u_tile_units_to_pixels: 1 / P(i, 1, t.transform.tileZoom), u_pixel_coord_upper: [l >> 16, c >> 16], u_pixel_coord_lower: [65535 & l, 65535 & c] };
        }(r, o, n), { u_matrix: t, u_opacity: i }),
              lo = { fillExtrusion: t => ({ u_matrix: new e.UniformMatrix4f(t), u_lightpos: new e.Uniform3f(t), u_lightintensity: new e.Uniform1f(t), u_lightcolor: new e.Uniform3f(t), u_vertical_gradient: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t), u_edge_radius: new e.Uniform1f(t), u_ao: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_up_dir: new e.Uniform3f(t), u_height_lift: new e.Uniform1f(t) }), fillExtrusionPattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_lightpos: new e.Uniform3f(t), u_lightintensity: new e.Uniform1f(t), u_lightcolor: new e.Uniform3f(t), u_vertical_gradient: new e.Uniform1f(t), u_height_factor: new e.Uniform1f(t), u_edge_radius: new e.Uniform1f(t), u_ao: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_up_dir: new e.Uniform3f(t), u_height_lift: new e.Uniform1f(t), u_image: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t) }), fill: t => ({ u_matrix: new e.UniformMatrix4f(t) }), fillPattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_image: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t) }), fillOutline: t => ({ u_matrix: new e.UniformMatrix4f(t), u_world: new e.Uniform2f(t) }), fillOutlinePattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_world: new e.Uniform2f(t), u_image: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t) }), circle: t => ({ u_camera_to_center_distance: new e.Uniform1f(t), u_extrude_scale: new e.UniformMatrix2f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_up_dir: new e.Uniform3f(t) }), collisionBox: t => ({ u_matrix: new e.UniformMatrix4f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_extrude_scale: new e.Uniform2f(t) }), collisionCircle: t => ({ u_matrix: new e.UniformMatrix4f(t), u_inv_matrix: new e.UniformMatrix4f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_viewport_size: new e.Uniform2f(t) }), debug: t => ({ u_color: new e.UniformColor(t), u_matrix: new e.UniformMatrix4f(t), u_overlay: new e.Uniform1i(t), u_overlay_scale: new e.Uniform1f(t) }), clippingMask: t => ({ u_matrix: new e.UniformMatrix4f(t) }), heatmap: t => ({ u_extrude_scale: new e.Uniform1f(t), u_intensity: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_up_dir: new e.Uniform3f(t) }), heatmapTexture: t => ({ u_image: new e.Uniform1i(t), u_color_ramp: new e.Uniform1i(t), u_opacity: new e.Uniform1f(t) }), hillshade: t => ({ u_matrix: new e.UniformMatrix4f(t), u_image: new e.Uniform1i(t), u_latrange: new e.Uniform2f(t), u_light: new e.Uniform2f(t), u_shadow: new e.UniformColor(t), u_highlight: new e.UniformColor(t), u_accent: new e.UniformColor(t) }), hillshadePrepare: t => ({ u_matrix: new e.UniformMatrix4f(t), u_image: new e.Uniform1i(t), u_dimension: new e.Uniform2f(t), u_zoom: new e.Uniform1f(t), u_unpack: new e.Uniform4f(t) }), line: t => ({ u_matrix: new e.UniformMatrix4f(t), u_pixels_to_tile_units: new e.UniformMatrix2f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_units_to_pixels: new e.Uniform2f(t), u_dash_image: new e.Uniform1i(t), u_gradient_image: new e.Uniform1i(t), u_image_height: new e.Uniform1f(t), u_texsize: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t), u_alpha_discard_threshold: new e.Uniform1f(t), u_trim_offset: new e.Uniform2f(t) }), linePattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_texsize: new e.Uniform2f(t), u_pixels_to_tile_units: new e.UniformMatrix2f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_image: new e.Uniform1i(t), u_units_to_pixels: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t), u_alpha_discard_threshold: new e.Uniform1f(t) }), raster: t => ({ u_matrix: new e.UniformMatrix4f(t), u_tl_parent: new e.Uniform2f(t), u_scale_parent: new e.Uniform1f(t), u_fade_t: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t), u_image0: new e.Uniform1i(t), u_image1: new e.Uniform1i(t), u_brightness_low: new e.Uniform1f(t), u_brightness_high: new e.Uniform1f(t), u_saturation_factor: new e.Uniform1f(t), u_contrast_factor: new e.Uniform1f(t), u_spin_weights: new e.Uniform3f(t), u_perspective_transform: new e.Uniform2f(t) }), symbolIcon: t => ({ u_is_size_zoom_constant: new e.Uniform1i(t), u_is_size_feature_constant: new e.Uniform1i(t), u_size_t: new e.Uniform1f(t), u_size: new e.Uniform1f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_rotate_symbol: new e.Uniform1i(t), u_aspect_ratio: new e.Uniform1f(t), u_fade_change: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_label_plane_matrix: new e.UniformMatrix4f(t), u_coord_matrix: new e.UniformMatrix4f(t), u_is_text: new e.Uniform1i(t), u_pitch_with_map: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_camera_forward: new e.Uniform3f(t), u_tile_matrix: new e.UniformMatrix4f(t), u_up_vector: new e.Uniform3f(t), u_ecef_origin: new e.Uniform3f(t), u_texture: new e.Uniform1i(t) }), symbolSDF: t => ({ u_is_size_zoom_constant: new e.Uniform1i(t), u_is_size_feature_constant: new e.Uniform1i(t), u_size_t: new e.Uniform1f(t), u_size: new e.Uniform1f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_rotate_symbol: new e.Uniform1i(t), u_aspect_ratio: new e.Uniform1f(t), u_fade_change: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_label_plane_matrix: new e.UniformMatrix4f(t), u_coord_matrix: new e.UniformMatrix4f(t), u_is_text: new e.Uniform1i(t), u_pitch_with_map: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_texture: new e.Uniform1i(t), u_gamma_scale: new e.Uniform1f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_camera_forward: new e.Uniform3f(t), u_tile_matrix: new e.UniformMatrix4f(t), u_up_vector: new e.Uniform3f(t), u_ecef_origin: new e.Uniform3f(t), u_is_halo: new e.Uniform1i(t) }), symbolTextAndIcon: t => ({ u_is_size_zoom_constant: new e.Uniform1i(t), u_is_size_feature_constant: new e.Uniform1i(t), u_size_t: new e.Uniform1f(t), u_size: new e.Uniform1f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_rotate_symbol: new e.Uniform1i(t), u_aspect_ratio: new e.Uniform1f(t), u_fade_change: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_label_plane_matrix: new e.UniformMatrix4f(t), u_coord_matrix: new e.UniformMatrix4f(t), u_is_text: new e.Uniform1i(t), u_pitch_with_map: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_texsize_icon: new e.Uniform2f(t), u_texture: new e.Uniform1i(t), u_texture_icon: new e.Uniform1i(t), u_gamma_scale: new e.Uniform1f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_is_halo: new e.Uniform1i(t) }), background: t => ({ u_matrix: new e.UniformMatrix4f(t), u_opacity: new e.Uniform1f(t), u_color: new e.UniformColor(t) }), backgroundPattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_opacity: new e.Uniform1f(t), u_image: new e.Uniform1i(t), u_pattern_tl: new e.Uniform2f(t), u_pattern_br: new e.Uniform2f(t), u_texsize: new e.Uniform2f(t), u_pattern_size: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t) }), terrainRaster: xi, terrainDepth: xi, skybox: t => ({ u_matrix: new e.UniformMatrix4f(t), u_sun_direction: new e.Uniform3f(t), u_cubemap: new e.Uniform1i(t), u_opacity: new e.Uniform1f(t), u_temporal_offset: new e.Uniform1f(t) }), skyboxGradient: t => ({ u_matrix: new e.UniformMatrix4f(t), u_color_ramp: new e.Uniform1i(t), u_center_direction: new e.Uniform3f(t), u_radius: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t), u_temporal_offset: new e.Uniform1f(t) }), skyboxCapture: t => ({ u_matrix_3f: new e.UniformMatrix3f(t), u_sun_direction: new e.Uniform3f(t), u_sun_intensity: new e.Uniform1f(t), u_color_tint_r: new e.Uniform4f(t), u_color_tint_m: new e.Uniform4f(t), u_luminance: new e.Uniform1f(t) }), globeRaster: t => ({ u_proj_matrix: new e.UniformMatrix4f(t), u_globe_matrix: new e.UniformMatrix4f(t), u_normalize_matrix: new e.UniformMatrix4f(t), u_merc_matrix: new e.UniformMatrix4f(t), u_zoom_transition: new e.Uniform1f(t), u_merc_center: new e.Uniform2f(t), u_image0: new e.Uniform1i(t), u_grid_matrix: new e.UniformMatrix3f(t), u_skirt_height: new e.Uniform1f(t), u_frustum_tl: new e.Uniform3f(t), u_frustum_tr: new e.Uniform3f(t), u_frustum_br: new e.Uniform3f(t), u_frustum_bl: new e.Uniform3f(t), u_globe_pos: new e.Uniform3f(t), u_globe_radius: new e.Uniform1f(t), u_viewport: new e.Uniform2f(t) }), globeAtmosphere: t => ({ u_frustum_tl: new e.Uniform3f(t), u_frustum_tr: new e.Uniform3f(t), u_frustum_br: new e.Uniform3f(t), u_frustum_bl: new e.Uniform3f(t), u_horizon: new e.Uniform1f(t), u_transition: new e.Uniform1f(t), u_fadeout_range: new e.Uniform1f(t), u_color: new e.Uniform4f(t), u_high_color: new e.Uniform4f(t), u_space_color: new e.Uniform4f(t), u_star_intensity: new e.Uniform1f(t), u_star_density: new e.Uniform1f(t), u_star_size: new e.Uniform1f(t), u_temporal_offset: new e.Uniform1f(t), u_horizon_angle: new e.Uniform1f(t), u_rotation_matrix: new e.UniformMatrix4f(t) }) };let co;function ho(t, i, o, r, n, s, a) {
            const l = t.context,
                  c = l.gl,
                  h = t.transform,
                  u = t.useProgram("collisionBox"),
                  _ = [];let d = 0,
                p = 0;for (let m = 0; m < r.length; m++) {
                const f = r[m],
                      g = i.getTile(f),
                      v = g.getBucket(o);if (!v) continue;const x = yt(f, v, h);let y = x;0 === n[0] && 0 === n[1] || (y = t.translatePosMatrix(x, g, n, s));const b = a ? v.textCollisionBox : v.iconCollisionBox,
                      w = v.collisionCircleArray;if (w.length > 0) {
                    const t = e.create(),
                          i = y;e.mul(t, v.placementInvProjMatrix, h.glCoordMatrix), e.mul(t, t, v.placementViewportMatrix), _.push({ circleArray: w, circleOffset: p, transform: i, invTransform: t, projection: v.getProjection() }), d += w.length / 4, p = d;
                }b && (t.terrain && t.terrain.setupElevationDraw(g, u), u.draw(l, c.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, Wi(y, h, g, v.getProjection()), o.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, h.zoom, null, [b.collisionVertexBuffer, b.collisionVertexBufferExt]));
            }if (!a || !_.length) return;const m = t.useProgram("collisionCircle"),
                  f = new e.StructArrayLayout2f1f2i16();f.resize(4 * d), f._trim();let g = 0;for (const e of _) for (let t = 0; t < e.circleArray.length / 4; t++) {
                const i = 4 * t,
                      o = e.circleArray[i + 0],
                      r = e.circleArray[i + 1],
                      n = e.circleArray[i + 2],
                      s = e.circleArray[i + 3];f.emplace(g++, o, r, n, s, 0), f.emplace(g++, o, r, n, s, 1), f.emplace(g++, o, r, n, s, 2), f.emplace(g++, o, r, n, s, 3);
            }(!co || co.length < 2 * d) && (co = function (t) {
                const i = 2 * t,
                      o = new e.StructArrayLayout3ui6();o.resize(i), o._trim();for (let e = 0; e < i; e++) {
                    const t = 6 * e;o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;
                }return o;
            }(d));const v = l.createIndexBuffer(co, !0),
                  x = l.createVertexBuffer(f, e.collisionCircleLayout.members, !0);for (const i of _) {
                const r = { u_matrix: i.transform, u_inv_matrix: i.invTransform, u_camera_to_center_distance: (y = h).getCameraToCenterDistance(i.projection), u_viewport_size: [y.width, y.height] };m.draw(l, c.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, r, o.id, x, v, e.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }var y;x.destroy(), v.destroy();
        }const uo = e.create();function _o({ width: t, height: i, anchor: o, textOffset: r, textScale: n }, s) {
            const { horizontalAlign: a, verticalAlign: l } = e.getAnchorAlignment(o),
                  c = -(a - .5) * t,
                  h = -(l - .5) * i,
                  u = e.evaluateVariableOffset(o, r);return new e.pointGeometry((c / n + u[0]) * s, (h / n + u[1]) * s);
        }function po(t, i, o, r, n, s, a, l, c, h, u) {
            const _ = t.text.placedSymbolArray,
                  d = t.text.dynamicLayoutVertexArray,
                  p = t.icon.dynamicLayoutVertexArray,
                  m = {},
                  f = t.getProjection(),
                  g = bt(l, f, s),
                  v = s.elevation,
                  x = f.upVectorScale(l.canonical, s.center.lat, s.worldSize).metersToTile;d.clear();for (let p = 0; p < _.length; p++) {
                const y = _.get(p),
                      { tileAnchorX: b, tileAnchorY: w, numGlyphs: T } = y,
                      E = t.allowVerticalPlacement && !y.placedOrientation,
                      C = y.hidden || !y.crossTileID || E ? null : r[y.crossTileID];if (C) {
                    let r = 0,
                        _ = 0,
                        p = 0;if (v) {
                        const e = v ? v.getAtTileOffset(l, b, w) : 0,
                              [t, i, o] = f.upVector(l.canonical, b, w);r = e * t * x, _ = e * i * x, p = e * o * x;
                    }let [E, M, I, S] = nt(y.projectedAnchorX + r, y.projectedAnchorY + _, y.projectedAnchorZ + p, o ? g : a);const D = st(s.getCameraToCenterDistance(f), S);let L = n.evaluateSizeForFeature(t.textSizeData, h, y) * D / e.ONE_EM;o && (L *= t.tilePixelRatio / c);const A = _o(C, L);o ? (({ x: E, y: M, z: I } = f.projectTilePoint(b + A.x, w + A.y, l.canonical)), [E, M, I] = nt(E + r, M + _, I + p, a)) : (i && A._rotate(-s.angle), E += A.x, M += A.y, I = 0);const z = t.allowVerticalPlacement && y.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;for (let t = 0; t < T; t++) e.addDynamicAttributes(d, E, M, I, z);u && y.associatedIconIndex >= 0 && (m[y.associatedIconIndex] = { x: E, y: M, z: I, angle: z });
                } else mt(T, d);
            }if (u) {
                p.clear();const i = t.icon.placedSymbolArray;for (let t = 0; t < i.length; t++) {
                    const o = i.get(t),
                          { numGlyphs: r } = o,
                          n = m[t];if (o.hidden || !n) mt(r, p);else {
                        const { x: t, y: i, z: o, angle: s } = n;for (let n = 0; n < r; n++) e.addDynamicAttributes(p, t, i, o, s);
                    }
                }t.icon.dynamicLayoutVertexBuffer.updateData(p);
            }t.text.dynamicLayoutVertexBuffer.updateData(d);
        }function mo(e, t, i) {
            return i.iconsInText && t ? "symbolTextAndIcon" : e ? "symbolSDF" : "symbolIcon";
        }function fo(t, i, o, r, n, s, a, l, c, h, u, _) {
            const d = t.context,
                  p = d.gl,
                  m = t.transform,
                  f = "map" === l,
                  g = "map" === c,
                  v = f && "point" !== o.layout.get("symbol-placement"),
                  x = f && !g && !v,
                  y = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);let b = !1;const w = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
                  T = [e.mercatorXfromLng(m.center.lng), e.mercatorYfromLat(m.center.lat)],
                  E = o.layout.get("text-variable-anchor"),
                  C = "globe" === m.projection.name,
                  M = [],
                  I = [0, -1, 0];let S = I;!C && !m.mercatorFromTransition || f || (S = function (t) {
                const i = t._camera.getWorldToCamera(t.worldSize, 1),
                      o = e.multiply([], i, t.globeMatrix);e.invert(o, o);const r = [0, 0, 0],
                      n = [0, 1, 0, 0];return e.transformMat4$1(n, n, o), r[0] = n[0], r[1] = n[1], r[2] = n[2], e.normalize(r, r), r;
            }(m));for (const l of r) {
                const r = i.getTile(l),
                      c = r.getBucket(o);if (!c) continue;if ("mercator" === c.projection.name && C) continue;const u = n ? c.text : c.icon;if (!u || c.fullyClipped || !u.segments.get().length) continue;const _ = u.programConfigurations.get(o.id),
                      d = n || c.sdfIcons,
                      w = n ? c.textSizeData : c.iconSizeData,
                      D = g || 0 !== m.pitch,
                      L = e.evaluateSizeForZoom(w, m.zoom);let A,
                    z,
                    P,
                    R,
                    O = [0, 0],
                    B = null;if (n) {
                    if (z = r.glyphAtlasTexture, P = p.LINEAR, A = r.glyphAtlasTexture.size, c.iconsInText) {
                        O = r.imageAtlasTexture.size, B = r.imageAtlasTexture;const e = "composite" === w.kind || "camera" === w.kind;R = D || t.options.rotating || t.options.zooming || e ? p.LINEAR : p.NEAREST;
                    }
                } else {
                    const e = 1 !== o.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;z = r.imageAtlasTexture, P = d || t.options.rotating || t.options.zooming || e || D ? p.LINEAR : p.NEAREST, A = r.imageAtlasTexture.size;
                }const k = "globe" === c.projection.name,
                      F = k ? S : I,
                      U = k ? e.globeToMercatorTransition(m.zoom) : 0,
                      N = bt(l, c.getProjection(), m),
                      G = m.calculatePixelsToTileUnitsMatrix(r),
                      j = it(N, r.tileID.canonical, g, f, m, c.getProjection(), G),
                      Z = t.terrain && g && v ? e.invert(e.create(), j) : uo,
                      V = rt(N, r.tileID.canonical, g, f, m, c.getProjection(), G),
                      W = E && c.hasTextData(),
                      X = "none" !== o.layout.get("icon-text-fit") && W && c.hasIconData();if (v) {
                    const e = m.elevation,
                          i = e ? e.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, c.getProjection()) : null,
                          o = ot(N, r.tileID.canonical, g, f, m, c.getProjection(), G);lt(c, N, t, n, o, V, g, h, i, l);
                }const q = v || n && E || X,
                      $ = t.translatePosMatrix(N, r, s, a),
                      H = q ? uo : j,
                      Y = t.translatePosMatrix(V, r, s, a, !0),
                      K = c.getProjection().createInversionMatrix(m, l.canonical),
                      J = [];t.terrainRenderModeElevated() && g && J.push("PITCH_WITH_MAP_TERRAIN"), k && J.push("PROJECTION_GLOBE_VIEW"), q && J.push("PROJECTED_POS_ON_VIEWPORT");const Q = d && 0 !== o.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1);let ee;ee = d ? c.iconsInText ? no(w.kind, L, x, g, t, $, H, Y, A, O, l, U, T, K, F, c.getProjection()) : ro(w.kind, L, x, g, t, $, H, Y, n, A, !0, l, U, T, K, F, c.getProjection()) : oo(w.kind, L, x, g, t, $, H, Y, n, A, l, U, T, K, F, c.getProjection());const te = { program: t.useProgram(mo(d, n, c), _, J), buffers: u, uniformValues: ee, atlasTexture: z, atlasTextureIcon: B, atlasInterpolation: P, atlasInterpolationIcon: R, isSDF: d, hasHalo: Q, tile: r, labelPlaneMatrixInv: Z };if (y && c.canOverlap) {
                    b = !0;const t = u.segments.get();for (const i of t) M.push({ segments: new e.SegmentVector([i]), sortKey: i.sortKey, state: te });
                } else M.push({ segments: u.segments, sortKey: 0, state: te });
            }b && M.sort((e, t) => e.sortKey - t.sortKey);for (const e of M) {
                const i = e.state;if (t.terrain && t.terrain.setupElevationDraw(i.tile, i.program, { useDepthForOcclusion: !C, labelPlaneMatrixInv: i.labelPlaneMatrixInv }), d.activeTexture.set(p.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE), i.atlasTextureIcon && (d.activeTexture.set(p.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), i.isSDF) {
                    const r = i.uniformValues;i.hasHalo && (r.u_is_halo = 1, go(i.buffers, e.segments, o, t, i.program, w, u, _, r)), r.u_is_halo = 0;
                }go(i.buffers, e.segments, o, t, i.program, w, u, _, i.uniformValues);
            }
        }function go(t, i, o, r, n, s, a, l, c) {
            const h = r.context,
                  u = [t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer, t.globeExtVertexBuffer];n.draw(h, h.gl.TRIANGLES, s, a, l, e.CullFaceMode.disabled, c, o.id, t.layoutVertexBuffer, t.indexBuffer, i, o.paint, r.transform.zoom, t.programConfigurations.get(o.id), u);
        }function vo(t, i, o, r, n, s, a) {
            const l = t.context.gl,
                  c = o.paint.get("fill-pattern"),
                  h = c && c.constantOr(1);let u, _, d, p, m;a ? (_ = h && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u = l.LINES) : (_ = h ? "fillPattern" : "fill", u = l.TRIANGLES);for (const f of r) {
                const r = i.getTile(f);if (h && !r.patternsLoaded()) continue;const g = r.getBucket(o);if (!g) continue;t.prepareDrawTile();const v = g.programConfigurations.get(o.id),
                      x = t.useProgram(_, v);h && (t.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers());const y = c.constantOr(null);if (y && r.imageAtlas) {
                    const e = r.imageAtlas.patternPositions[y.toString()];e && v.setConstantPatternPositions(e);
                }const b = t.translatePosMatrix(f.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));if (a) {
                    p = g.indexBuffer2, m = g.segments2;const e = t.terrain && t.terrain.renderingToTexture ? t.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];d = "fillOutlinePattern" === _ && h ? Gi(b, t, r, e) : Ni(b, e);
                } else p = g.indexBuffer, m = g.segments, d = h ? Ui(b, t, r) : Fi(b);t.prepareDrawProgram(t.context, x, f.toUnwrapped()), x.draw(t.context, u, n, t.stencilModeForClipping(f), s, e.CullFaceMode.disabled, d, o.id, g.layoutVertexBuffer, p, m, o.paint, t.transform.zoom, v);
            }
        }function xo(t, i, o, r, n, s, a) {
            const l = t.context,
                  c = l.gl,
                  h = t.transform,
                  u = o.paint.get("fill-extrusion-pattern"),
                  _ = u.constantOr(1),
                  d = o.paint.get("fill-extrusion-opacity"),
                  p = [o.paint.get("fill-extrusion-ambient-occlusion-intensity"), o.paint.get("fill-extrusion-ambient-occlusion-radius")],
                  m = o.layout.get("fill-extrusion-edge-radius"),
                  f = "globe" === h.projection.name ? e.fillExtrusionHeightLift() : 0,
                  g = "globe" === h.projection.name,
                  v = g ? e.globeToMercatorTransition(h.zoom) : 0,
                  x = [e.mercatorXfromLng(h.center.lng), e.mercatorYfromLat(h.center.lat)],
                  y = [];g && y.push("PROJECTION_GLOBE_VIEW"), p[0] > 0 && y.push("FAUX_AO");for (const b of r) {
                const r = i.getTile(b),
                      w = r.getBucket(o);if (!w || w.projection.name !== h.projection.name) continue;const T = w.programConfigurations.get(o.id),
                      E = t.useProgram(_ ? "fillExtrusionPattern" : "fillExtrusion", T, y);if (t.terrain) {
                    const e = t.terrain;if (t.style.terrainSetForDrapingOnly()) e.setupElevationDraw(r, E, { useMeterToDem: !0 });else {
                        if (!w.enableTerrain) continue;if (e.setupElevationDraw(r, E, { useMeterToDem: !0 }), yo(l, i, b, w, o, e), !w.centroidVertexBuffer) {
                            const e = E.attributes.a_centroid_pos;void 0 !== e && c.vertexAttrib2f(e, 0, 0);
                        }
                    }
                }_ && (t.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), T.updatePaintBuffers());const C = u.constantOr(null);if (C && r.imageAtlas) {
                    const e = r.imageAtlas.patternPositions[C.toString()];e && T.setConstantPatternPositions(e);
                }const M = t.translatePosMatrix(b.projMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")),
                      I = h.projection.createInversionMatrix(h, b.canonical),
                      S = o.paint.get("fill-extrusion-vertical-gradient"),
                      D = _ ? ki(M, t, S, d, p, m, b, r, f, v, x, I) : Bi(M, t, S, d, p, m, b, f, v, x, I);t.prepareDrawProgram(l, E, b.toUnwrapped());const L = [];t.terrain && L.push(w.centroidVertexBuffer), g && L.push(w.layoutVertexExtBuffer), E.draw(l, l.gl.TRIANGLES, n, s, a, e.CullFaceMode.backCCW, D, o.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, o.paint, t.transform.zoom, T, L);
            }
        }function yo(t, i, o, r, n, s) {
            const a = [t => {
                let i = t.canonical.x - 1,
                    o = t.wrap;return i < 0 && (i = (1 << t.canonical.z) - 1, o--), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);
            }, t => {
                let i = t.canonical.x + 1,
                    o = t.wrap;return i === 1 << t.canonical.z && (i = 0, o++), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);
            }, t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)],
                  l = e => {
                const t = i.getSource().minzoom,
                      o = e => {
                    const t = i.getTileByID(e);if (t && t.hasData()) return t.getBucket(n);
                },
                      r = [0, -1, 1];for (const i of r) {
                    if (e.overscaledZ + i < t) continue;const r = o(e.calculateScaledKey(e.overscaledZ + i));if (r) return r;
                }
            },
                  c = [0, 0, 0],
                  h = (t, i) => (c[0] = Math.min(t.min.y, i.min.y), c[1] = Math.max(t.max.y, i.max.y), c[2] = e.EXTENT - i.min.x > t.max.x ? i.min.x - e.EXTENT : t.max.x, c),
                  u = (t, i) => (c[0] = Math.min(t.min.x, i.min.x), c[1] = Math.max(t.max.x, i.max.x), c[2] = e.EXTENT - i.min.y > t.max.y ? i.min.y - e.EXTENT : t.max.y, c),
                  _ = [(e, t) => h(e, t), (e, t) => h(t, e), (e, t) => u(e, t), (e, t) => u(t, e)],
                  d = new e.pointGeometry(0, 0);let p, m, f;const g = (t, i, r, n, a) => {
                const l = [[n ? r : t, n ? t : r, 0], [n ? r : i, n ? i : r, 0]],
                      c = a < 0 ? e.EXTENT + a : a,
                      h = [n ? c : (t + i) / 2, n ? (t + i) / 2 : c, 0];return 0 === r && a < 0 || 0 !== r && a > 0 ? s.getForTilePoints(f, [h], !0, m) : l.push(h), s.getForTilePoints(o, l, !0, p), Math.max(l[0][2], l[1][2], h[2]) / s.exaggeration();
            };for (let t = 0; t < 4; t++) {
                const i = (t < 2 ? 1 : 5) - t,
                      n = r.borders[t];if (0 === n.length) continue;const c = f = a[t](o),
                      h = l(c);if (!(h && h instanceof e.FillExtrusionBucket && h.enableTerrain)) continue;if (r.borderDoneWithNeighborZ[t] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z) continue;if (m = s.findDEMTileFor(c), !m || !m.dem) continue;if (!p) {
                    const e = s.findDEMTileFor(o);if (!e || !e.dem) return;p = e;
                }const u = h.borders[i];let v = 0;const x = h.borderDoneWithNeighborZ[i] !== r.canonical.z;if (r.canonical.z === h.canonical.z) {
                    for (let o = 0; o < n.length; o++) {
                        const s = r.featuresOnBorder[n[o]],
                              a = s.borders[t];let l;for (; v < u.length && (l = h.featuresOnBorder[u[v]], !(l.borders[i][1] > a[0] + 3));) x && h.encodeCentroid(void 0, l, !1), v++;if (l && v < u.length) {
                            const o = v;let n = 0;for (; !(l.borders[i][0] > a[1] - 3) && (n++, ++v !== u.length);) l = h.featuresOnBorder[u[v]];if (l = h.featuresOnBorder[u[o]], s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {
                                1 !== n && (v = o), r.encodeCentroid(void 0, s, !1), x && h.encodeCentroid(void 0, l, !1);continue;
                            }const c = _[t](s, l),
                                  p = t % 2 ? e.EXTENT - 1 : 0;d.x = g(c[0], Math.min(e.EXTENT - 1, c[1]), p, t < 2, c[2]), d.y = 0, r.encodeCentroid(d, s, !1), x && h.encodeCentroid(d, l, !1);
                        } else r.encodeCentroid(void 0, s, !1);
                    }r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0, x && (h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0);
                } else {
                    for (const e of n) r.encodeCentroid(void 0, r.featuresOnBorder[e], !1);if (x) {
                        for (const e of u) h.encodeCentroid(void 0, h.featuresOnBorder[e], !1);h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0;
                    }r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0;
                }
            }(r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t);
        }const bo = new e.Color(1, 0, 0, 1),
              wo = new e.Color(0, 1, 0, 1),
              To = new e.Color(0, 0, 1, 1),
              Eo = new e.Color(1, 0, 1, 1),
              Co = new e.Color(0, 1, 1, 1);function Mo(t, i, o) {
            const r = t.context,
                  n = t.transform,
                  s = r.gl,
                  a = "globe" === n.projection.name,
                  l = a ? ["PROJECTION_GLOBE_VIEW"] : null;let c = o.projMatrix;if (a && e.globeToMercatorTransition(n.zoom) > 0) {
                const t = e.transitionTileAABBinECEF(o.canonical, n),
                      i = e.globeDenormalizeECEF(t);c = e.multiply(new Float32Array(16), n.globeMatrix, i), e.multiply(c, n.projMatrix, c);
            }const h = t.useProgram("debug", null, l),
                  u = i.getTileByID(o.key);t.terrain && t.terrain.setupElevationDraw(u, h);const _ = e.DepthMode.disabled,
                  d = e.StencilMode.disabled,
                  p = t.colorModeForRenderPass(),
                  m = "$debug";r.activeTexture.set(s.TEXTURE0), t.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), a ? u._makeGlobeTileDebugBuffers(t.context, n) : u._makeDebugTileBoundsBuffers(t.context, n.projection);const f = u._tileDebugBuffer || t.debugBuffer,
                  g = u._tileDebugIndexBuffer || t.debugIndexBuffer,
                  v = u._tileDebugSegments || t.debugSegments;h.draw(r, s.LINE_STRIP, _, d, p, e.CullFaceMode.disabled, Xi(c, e.Color.red), m, f, g, v, null, null, null, [u._globeTileDebugBorderBuffer]);const x = u.latestRawTileData,
                  y = Math.floor((x && x.byteLength || 0) / 1024),
                  b = i.getTile(o).tileSize,
                  w = 512 / Math.min(b, 512) * (o.overscaledZ / n.zoom) * .5;let T = o.canonical.toString();o.overscaledZ !== o.canonical.z && (T += ` => ${o.overscaledZ}`), T += ` ${y}kb`, function (e, t) {
                e.initDebugOverlayCanvas();const i = e.debugOverlayCanvas,
                      o = e.context.gl,
                      r = e.debugOverlayCanvas.getContext("2d");r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t, 5, 5), r.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }(t, T);const E = u._tileDebugTextBuffer || t.debugBuffer,
                  C = u._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,
                  M = u._tileDebugTextSegments || t.debugSegments;h.draw(r, s.TRIANGLES, _, d, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Xi(c, e.Color.transparent, w), m, E, C, M, null, null, null, [u._globeTileDebugTextBuffer]);
        }function Io(e, t, i, o) {
            Do(e, 0, t + i / 2, e.transform.width, i, o);
        }function So(e, t, i, o) {
            Do(e, t - i / 2, 0, i, e.transform.height, o);
        }function Do(t, i, o, r, n, s) {
            const a = t.context,
                  l = a.gl;l.enable(l.SCISSOR_TEST), l.scissor(i * e.exported.devicePixelRatio, o * e.exported.devicePixelRatio, r * e.exported.devicePixelRatio, n * e.exported.devicePixelRatio), a.clear({ color: s }), l.disable(l.SCISSOR_TEST);
        }const Lo = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]),
              { members: Ao } = Lo;function zo(e, t, i, o) {
            e.emplaceBack(t, i, o);
        }class Po {
            constructor(t) {
                this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), zo(this.vertexArray, -1, -1, 1), zo(this.vertexArray, 1, -1, 1), zo(this.vertexArray, -1, 1, 1), zo(this.vertexArray, 1, 1, 1), zo(this.vertexArray, -1, -1, -1), zo(this.vertexArray, 1, -1, -1), zo(this.vertexArray, -1, 1, -1), zo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, Ao), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
            }
        }function Ro(t, i, o, r, n, s) {
            const a = t.gl,
                  l = i.paint.get("sky-atmosphere-color"),
                  c = i.paint.get("sky-atmosphere-halo-color"),
                  h = i.paint.get("sky-atmosphere-sun-intensity"),
                  u = ((e, t, i, o, r) => ({ u_matrix_3f: e, u_sun_direction: t, u_sun_intensity: i, u_color_tint_r: [o.r, o.g, o.b, o.a], u_color_tint_m: [r.r, r.g, r.b, r.a], u_luminance: 5e-5 }))(e.fromMat4(e.create$1(), r), n, h, l, c);a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0), o.draw(t, a.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }const Oo = e.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);class Bo {
            constructor(t) {
                const i = new e.StructArrayLayout5f20();i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);const o = new e.StructArrayLayout3ui6();o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(i, Oo.members), this.indexBuffer = t.createIndexBuffer(o), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            }destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }const ko = { symbol: function (t, i, o, r, n) {
                if ("translucent" !== t.renderPass) return;const s = e.StencilMode.disabled,
                      a = t.colorModeForRenderPass();o.layout.get("text-variable-anchor") && function (t, i, o, r, n, s, a) {
                    const l = i.transform,
                          c = "map" === n,
                          h = "map" === s;for (const i of t) {
                        const t = r.getTile(i),
                              n = t.getBucket(o);if (!n || !n.text || !n.text.segments.get().length) continue;const s = e.evaluateSizeForZoom(n.textSizeData, l.zoom),
                              u = bt(i, n.getProjection(), l),
                              _ = l.calculatePixelsToTileUnitsMatrix(t),
                              d = it(u, t.tileID.canonical, h, c, l, n.getProjection(), _),
                              p = "none" !== o.layout.get("icon-text-fit") && n.hasIconData();if (s) {
                            const o = Math.pow(2, l.zoom - t.tileID.overscaledZ);po(n, c, h, a, e.symbolSize, l, d, i, o, s, p);
                        }
                    }
                }(r, t, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), n), 0 !== o.paint.get("icon-opacity").constantOr(1) && fo(t, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), s, a), 0 !== o.paint.get("text-opacity").constantOr(1) && fo(t, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), s, a), i.map.showCollisionBoxes && (ho(t, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), ho(t, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            }, circle: function (t, i, o, r) {
                if ("translucent" !== t.renderPass) return;const n = o.paint.get("circle-opacity"),
                      s = o.paint.get("circle-stroke-width"),
                      a = o.paint.get("circle-stroke-opacity"),
                      l = void 0 !== o.layout.get("circle-sort-key").constantOr(1);if (0 === n.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1))) return;const c = t.context,
                      h = c.gl,
                      u = t.transform,
                      _ = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
                      d = e.StencilMode.disabled,
                      p = t.colorModeForRenderPass(),
                      m = "globe" === u.projection.name,
                      f = [e.mercatorXfromLng(u.center.lng), e.mercatorYfromLat(u.center.lat)],
                      g = [];for (let n = 0; n < r.length; n++) {
                    const s = r[n],
                          a = i.getTile(s),
                          c = a.getBucket(o);if (!c || c.projection.name !== u.projection.name) continue;const h = c.programConfigurations.get(o.id),
                          _ = Vi(o);m && _.push("PROJECTION_GLOBE_VIEW");const d = t.useProgram("circle", h, _),
                          p = c.layoutVertexBuffer,
                          v = c.globeExtVertexBuffer,
                          x = c.indexBuffer,
                          y = u.projection.createInversionMatrix(u, s.canonical),
                          b = { programConfiguration: h, program: d, layoutVertexBuffer: p, globeExtVertexBuffer: v, indexBuffer: x, uniformValues: Zi(t, s, a, y, f, o), tile: a };if (l) {
                        const t = c.segments.get();for (const i of t) g.push({ segments: new e.SegmentVector([i]), sortKey: i.sortKey, state: b });
                    } else g.push({ segments: c.segments, sortKey: 0, state: b });
                }l && g.sort((e, t) => e.sortKey - t.sortKey);const v = { useDepthForOcclusion: !m };for (const i of g) {
                    const { programConfiguration: r, program: n, layoutVertexBuffer: s, globeExtVertexBuffer: a, indexBuffer: l, uniformValues: m, tile: f } = i.state,
                          g = i.segments;t.terrain && t.terrain.setupElevationDraw(f, n, v), t.prepareDrawProgram(c, n, f.tileID.toUnwrapped()), n.draw(c, h.TRIANGLES, _, d, p, e.CullFaceMode.disabled, m, o.id, s, l, g, o.paint, u.zoom, r, [a]);
                }
            }, heatmap: function (t, i, o, r) {
                if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === t.renderPass) {
                    const n = t.context,
                          s = n.gl,
                          a = e.StencilMode.disabled,
                          l = new e.ColorMode([s.ONE, s.ONE], e.Color.transparent, [!0, !0, !0, !0]);!function (e, t, i, o) {
                        const r = e.gl,
                              n = t.width * o,
                              s = t.height * o;e.activeTexture.set(r.TEXTURE1), e.viewport.set([0, 0, n, s]);let a = i.heatmapFbo;if (!a || a && (a.width !== n || a.height !== s)) {
                            a && a.destroy();const t = r.createTexture();r.bindTexture(r.TEXTURE_2D, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), a = i.heatmapFbo = e.createFramebuffer(n, s, !1), function (e, t, i, o, r, n) {
                                const s = e.gl;s.texImage2D(s.TEXTURE_2D, 0, e.isWebGL2 && e.extRenderToTextureHalfFloat ? s.RGBA16F : s.RGBA, r, n, 0, s.RGBA, e.extRenderToTextureHalfFloat ? e.isWebGL2 ? s.HALF_FLOAT : e.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
                            }(e, 0, t, a, n, s);
                        } else r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer);
                    }(n, t, o, "globe" === t.transform.projection.name ? .5 : .25), n.clear({ color: e.Color.transparent });const c = t.transform,
                          h = "globe" === c.projection.name,
                          u = h ? ["PROJECTION_GLOBE_VIEW"] : null,
                          _ = h ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled,
                          d = [e.mercatorXfromLng(c.center.lng), e.mercatorYfromLat(c.center.lat)];for (let p = 0; p < r.length; p++) {
                        const m = r[p];if (i.hasRenderableParent(m)) continue;const f = i.getTile(m),
                              g = f.getBucket(o);if (!g || g.projection.name !== c.projection.name) continue;const v = g.programConfigurations.get(o.id),
                              x = t.useProgram("heatmap", v, u),
                              { zoom: y } = t.transform;t.terrain && t.terrain.setupElevationDraw(f, x), t.prepareDrawProgram(n, x, m.toUnwrapped());const b = c.projection.createInversionMatrix(c, m.canonical);x.draw(n, s.TRIANGLES, e.DepthMode.disabled, a, l, _, $i(t, m, f, b, d, y, o.paint.get("heatmap-intensity")), o.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, o.paint, t.transform.zoom, v, h ? [g.globeExtVertexBuffer] : null);
                    }n.viewport.set([0, 0, t.width, t.height]);
                } else "translucent" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {
                    const o = t.context,
                          r = o.gl,
                          n = i.heatmapFbo;if (!n) return;o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);let s = i.colorRampTexture;s || (s = i.colorRampTexture = new e.Texture(o, i.colorRamp, r.RGBA)), s.bind(r.LINEAR, r.CLAMP_TO_EDGE), t.useProgram("heatmapTexture").draw(o, r.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e, t, i, o) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t.paint.get("heatmap-opacity") }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);
                }(t, o));
            }, line: function (t, i, o, r) {
                if ("translucent" !== t.renderPass) return;const n = o.paint.get("line-opacity"),
                      s = o.paint.get("line-width");if (0 === n.constantOr(1) || 0 === s.constantOr(1)) return;const a = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
                      l = t.colorModeForRenderPass(),
                      c = t.terrain && t.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio,
                      h = o.paint.get("line-dasharray"),
                      u = h.constantOr(1),
                      _ = o.layout.get("line-cap"),
                      d = o.paint.get("line-pattern"),
                      p = d.constantOr(1),
                      m = o.paint.get("line-gradient"),
                      f = p ? "linePattern" : "line",
                      g = t.context,
                      v = g.gl,
                      x = (e => {
                    const t = [];Qi(e) && t.push("RENDER_LINE_DASH"), e.paint.get("line-gradient") && t.push("RENDER_LINE_GRADIENT");const i = e.paint.get("line-trim-offset");0 === i[0] && 0 === i[1] || t.push("RENDER_LINE_TRIM_OFFSET");const o = e.paint.get("line-pattern").constantOr(1),
                          r = 1 !== e.paint.get("line-opacity").constantOr(1);return !o && r && t.push("RENDER_LINE_ALPHA_DISCARD"), t;
                })(o);let y = x.includes("RENDER_LINE_ALPHA_DISCARD");t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (y = !1);for (const n of r) {
                    const r = i.getTile(n);if (p && !r.patternsLoaded()) continue;const s = r.getBucket(o);if (!s) continue;t.prepareDrawTile();const b = s.programConfigurations.get(o.id),
                          w = t.useProgram(f, b, x),
                          T = d.constantOr(null);if (T && r.imageAtlas) {
                        const e = r.imageAtlas.patternPositions[T.toString()];e && b.setConstantPatternPositions(e);
                    }const E = h.constantOr(null),
                          C = _.constantOr(null);if (!p && E && C && r.lineAtlas) {
                        const e = r.lineAtlas.getDash(E, C);e && b.setConstantPatternPositions(e);
                    }let [M, I] = o.paint.get("line-trim-offset");if ("round" === C || "square" === C) {
                        const e = 1;M !== I && (0 === M && (M -= e), 1 === I && (I += e));
                    }const S = t.terrain ? n.projMatrix : null,
                          D = p ? Yi(t, r, o, S, c) : Hi(t, r, o, S, s.lineClipsArray.length, c, [M, I]);if (m) {
                        const r = s.gradients[o.id];let a = r.texture;if (o.gradientVersion !== r.version) {
                            let l = 256;if (o.stepInterpolant) {
                                const o = i.getSource().maxzoom,
                                      r = n.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - n.canonical.z) : 1;l = e.clamp(e.nextPowerOfTwo(s.maxLineLength / e.EXTENT * 1024 * r), 256, g.maxTextureSize);
                            }r.gradient = e.renderColorRamp({ expression: o.gradientExpression(), evaluationKey: "lineProgress", resolution: l, image: r.gradient || void 0, clips: s.lineClipsArray }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.Texture(g, r.gradient, v.RGBA), r.version = o.gradientVersion, a = r.texture;
                        }g.activeTexture.set(v.TEXTURE1), a.bind(o.stepInterpolant ? v.NEAREST : v.LINEAR, v.CLAMP_TO_EDGE);
                    }u && (g.activeTexture.set(v.TEXTURE0), r.lineAtlasTexture.bind(v.LINEAR, v.REPEAT), b.updatePaintBuffers()), p && (g.activeTexture.set(v.TEXTURE0), r.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), b.updatePaintBuffers()), t.prepareDrawProgram(g, w, n.toUnwrapped());const L = i => {
                        w.draw(g, v.TRIANGLES, a, i, l, e.CullFaceMode.disabled, D, o.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, o.paint, t.transform.zoom, b, [s.layoutVertexBuffer2]);
                    };if (y) {
                        const i = t.stencilModeForClipping(n).ref;0 === i && t.terrain && g.clear({ stencil: 0 });const o = { func: v.EQUAL, mask: 255 };D.u_alpha_discard_threshold = .8, L(new e.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.INVERT)), D.u_alpha_discard_threshold = 0, L(new e.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.KEEP));
                    } else L(t.stencilModeForClipping(n));
                }y && (t.resetStencilClippingMasks(), t.terrain && g.clear({ stencil: 0 }));
            }, fill: function (t, i, o, r) {
                const n = o.paint.get("fill-color"),
                      s = o.paint.get("fill-opacity");if (0 === s.constantOr(1)) return;const a = t.colorModeForRenderPass(),
                      l = o.paint.get("fill-pattern"),
                      c = t.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(e.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent";if (t.renderPass === c) {
                    const n = t.depthModeForSublayer(1, "opaque" === t.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);vo(t, i, o, r, n, a, !1);
                }if ("translucent" === t.renderPass && o.paint.get("fill-antialias")) {
                    const n = t.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);vo(t, i, o, r, n, a, !0);
                }
            }, "fill-extrusion": function (t, i, o, r) {
                const n = o.paint.get("fill-extrusion-opacity");if (0 !== n && "translucent" === t.renderPass) {
                    const s = new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);if (1 !== n || o.paint.get("fill-extrusion-pattern").constantOr(1)) xo(t, i, o, r, s, e.StencilMode.disabled, e.ColorMode.disabled), xo(t, i, o, r, s, t.stencilModeFor3D(), t.colorModeForRenderPass()), t.resetStencilClippingMasks();else {
                        const n = t.colorModeForRenderPass();xo(t, i, o, r, s, e.StencilMode.disabled, n);
                    }
                }
            }, hillshade: function (t, i, o, r) {
                if ("offscreen" !== t.renderPass && "translucent" !== t.renderPass) return;const n = t.context,
                      s = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
                      a = t.colorModeForRenderPass(),
                      l = t.terrain && t.terrain.renderingToTexture,
                      [c, h] = "translucent" !== t.renderPass || l ? [{}, r] : t.stencilConfigForOverlap(r);for (const r of h) {
                    const n = i.getTile(r);if (n.needsHillshadePrepare && "offscreen" === t.renderPass) vi(t, n, o, s, e.StencilMode.disabled, a);else if ("translucent" === t.renderPass) {
                        const e = l && t.terrain ? t.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];fi(t, r, n, o, s, e, a);
                    }
                }n.viewport.set([0, 0, t.width, t.height]), t.resetStencilClippingMasks();
            }, raster: function (t, i, o, r, n, s) {
                if ("translucent" !== t.renderPass) return;if (0 === o.paint.get("raster-opacity")) return;if (!r.length) return;const a = t.context,
                      l = a.gl,
                      c = i.getSource(),
                      h = t.useProgram("raster"),
                      u = t.colorModeForRenderPass(),
                      _ = t.terrain && t.terrain.renderingToTexture,
                      [d, p] = c instanceof Ae || _ ? [{}, r] : t.stencilConfigForOverlap(r),
                      m = p[p.length - 1].overscaledZ,
                      f = !t.options.moving;for (const r of p) {
                    const n = _ ? e.DepthMode.disabled : t.depthModeForSublayer(r.overscaledZ - m, 1 === o.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l.LESS),
                          p = r.toUnwrapped(),
                          g = i.getTile(r);if (_ && (!g || !g.hasData())) continue;const v = _ ? r.projMatrix : t.transform.calculateProjMatrix(p, f),
                          x = t.terrain && _ ? t.terrain.stencilModeForRTTOverlap(r) : d[r.overscaledZ],
                          y = s ? 0 : o.paint.get("raster-fade-duration");g.registerFadeDuration(y);const b = i.findLoadedParent(r, 0),
                          w = Si(g, b, i, t.transform, y);let T, E;t.terrain && t.terrain.prepareDrawTile();const C = "nearest" === o.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;a.activeTexture.set(l.TEXTURE0), g.texture.bind(C, l.CLAMP_TO_EDGE), a.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(C, l.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), E = [g.tileID.canonical.x * T % 1, g.tileID.canonical.y * T % 1]) : g.texture.bind(C, l.CLAMP_TO_EDGE);const M = eo(v, E || [0, 0], T || 1, w, o, c instanceof Ae ? c.perspectiveTransform : [0, 0]);if (t.prepareDrawProgram(a, h, p), c instanceof Ae) c.boundsBuffer && c.boundsSegments && h.draw(a, l.TRIANGLES, n, e.StencilMode.disabled, u, e.CullFaceMode.disabled, M, o.id, c.boundsBuffer, t.quadTriangleIndexBuffer, c.boundsSegments);else {
                        const { tileBoundsBuffer: i, tileBoundsIndexBuffer: r, tileBoundsSegments: s } = t.getTileBoundsBuffers(g);h.draw(a, l.TRIANGLES, n, x, u, e.CullFaceMode.disabled, M, o.id, i, r, s);
                    }
                }t.resetStencilClippingMasks();
            }, background: function (t, i, o, r) {
                const n = o.paint.get("background-color"),
                      s = o.paint.get("background-opacity");if (0 === s) return;const a = t.context,
                      l = a.gl,
                      c = t.transform,
                      h = c.tileSize,
                      u = o.paint.get("background-pattern");if (t.isPatternMissing(u)) return;const _ = !u && 1 === n.a && 1 === s && t.opaquePassEnabledForLayer() ? "opaque" : "translucent";if (t.renderPass !== _) return;const d = e.StencilMode.disabled,
                      p = t.depthModeForSublayer(0, "opaque" === _ ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly),
                      m = t.colorModeForRenderPass(),
                      f = t.useProgram(u ? "backgroundPattern" : "background");let g,
                    v = r;v || (g = t.getBackgroundTiles(), v = Object.values(g).map(e => e.tileID)), u && (a.activeTexture.set(l.TEXTURE0), t.imageManager.bind(t.context));for (const _ of v) {
                    const v = _.toUnwrapped(),
                          x = r ? _.projMatrix : t.transform.calculateProjMatrix(v);t.prepareDrawTile();const y = i ? i.getTile(_) : g ? g[_.key] : new e.Tile(_, h, c.zoom, t),
                          b = u ? ao(x, s, t, u, { tileID: _, tileSize: h }) : so(x, s, n);t.prepareDrawProgram(a, f, v);const { tileBoundsBuffer: w, tileBoundsIndexBuffer: T, tileBoundsSegments: E } = t.getTileBoundsBuffers(y);f.draw(a, l.TRIANGLES, p, d, m, e.CullFaceMode.disabled, b, o.id, w, T, E);
                }
            }, sky: function (t, i, o) {
                const r = t.transform,
                      n = "mercator" === r.projection.name || "globe" === r.projection.name ? 1 : e.smoothstep(7, 8, r.zoom),
                      s = o.paint.get("sky-opacity") * n;if (0 === s) return;const a = t.context,
                      l = o.paint.get("sky-type"),
                      c = new e.DepthMode(a.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),
                      h = t.frameCounter / 1e3 % 1;"atmosphere" === l ? "offscreen" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, r) {
                    const n = t.context,
                          s = n.gl;let a = i.skyboxFbo;if (!a) {
                        a = i.skyboxFbo = n.createFramebuffer(32, 32, !1), i.skyboxGeometry = new Po(n), i.skyboxTexture = n.gl.createTexture(), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);for (let e = 0; e < 6; ++e) s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null);
                    }n.bindFramebuffer.set(a.framebuffer), n.viewport.set([0, 0, 32, 32]);const l = i.getCenter(t, !0),
                          c = t.useProgram("skyboxCapture"),
                          h = new Float64Array(16);e.identity(h), e.rotateY(h, h, .5 * -Math.PI), Ro(n, i, c, h, l, 0), e.identity(h), e.rotateY(h, h, .5 * Math.PI), Ro(n, i, c, h, l, 1), e.identity(h), e.rotateX(h, h, .5 * -Math.PI), Ro(n, i, c, h, l, 2), e.identity(h), e.rotateX(h, h, .5 * Math.PI), Ro(n, i, c, h, l, 3), e.identity(h), Ro(n, i, c, h, l, 4), e.identity(h), e.rotateY(h, h, Math.PI), Ro(n, i, c, h, l, 5), n.viewport.set([0, 0, t.width, t.height]);
                }(t, o), o.markSkyboxValid(t)) : "sky" === t.renderPass && function (t, i, o, r, n) {
                    const s = t.context,
                          a = s.gl,
                          l = t.transform,
                          c = t.useProgram("skybox");s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);const h = ((e, t, i, o, r) => ({ u_matrix: e, u_sun_direction: t, u_cubemap: 0, u_opacity: o, u_temporal_offset: r }))(l.skyboxMatrix, i.getCenter(t, !1), 0, r, n);t.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t, o, c, s, h) : "gradient" === l && "sky" === t.renderPass && function (t, i, o, r, n) {
                    const s = t.context,
                          a = s.gl,
                          l = t.transform,
                          c = t.useProgram("skyboxGradient");i.skyboxGeometry || (i.skyboxGeometry = new Po(s)), s.activeTexture.set(a.TEXTURE0);let h = i.colorRampTexture;h || (h = i.colorRampTexture = new e.Texture(s, i.colorRamp, a.RGBA)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);const u = ((t, i, o, r, n) => ({ u_matrix: t, u_color_ramp: 0, u_center_direction: i, u_radius: e.degToRad(o), u_opacity: r, u_temporal_offset: n }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get("sky-gradient-radius"), r, n);t.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, u, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t, o, c, s, h);
            }, debug: function (e, t, i) {
                for (let o = 0; o < i.length; o++) Mo(e, t, i[o]);
            }, custom: function (t, i, o, r) {
                const n = t.context,
                      s = o.implementation;if (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes("custom") || t.terrain && (t.terrain.renderingToTexture || "offscreen" === t.renderPass) && o.isLayerDraped()) {
                    if ("offscreen" === t.renderPass) {
                        const i = s.prerender;if (i) {
                            if (t.setCustomLayerDefaults(), n.setColorMode(t.colorModeForRenderPass()), "globe" === t.transform.projection.name) {
                                const o = t.transform.pointMerc;i.call(s, n.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [o.x, o.y], t.transform.pixelsPerMeterRatio);
                            } else i.call(s, n.gl, t.transform.customLayerMatrix());n.setDirty(), t.setBaseState();
                        }
                    } else if ("translucent" === t.renderPass) {
                        if (t.terrain && t.terrain.renderingToTexture) {
                            const i = s.renderToTile;if (i) {
                                const o = r[0].canonical,
                                      a = new e.MercatorCoordinate(o.x + r[0].wrap * (1 << o.z), o.y, o.z);n.setDepthMode(e.DepthMode.disabled), n.setStencilMode(e.StencilMode.disabled), n.setColorMode(t.colorModeForRenderPass()), t.setCustomLayerDefaults(), i.call(s, n.gl, a), n.setDirty(), t.setBaseState();
                            }return;
                        }t.setCustomLayerDefaults(), n.setColorMode(t.colorModeForRenderPass()), n.setStencilMode(e.StencilMode.disabled);const i = "3d" === s.renderingMode ? new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, e.DepthMode.ReadOnly);if (n.setDepthMode(i), "globe" === t.transform.projection.name) {
                            const i = t.transform.pointMerc;s.render(n.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [i.x, i.y], t.transform.pixelsPerMeterRatio);
                        } else s.render(n.gl, t.transform.customLayerMatrix());n.setDirty(), t.setBaseState(), n.bindFramebuffer.set(null);
                    }
                } else e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
            } };class Fo {
            constructor(t, i, o = !1) {
                this.context = new Me(t, o), this.transform = i, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new qt(), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
            }updateTerrain(e, t) {
                const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;if (!(i || this._terrain && this._terrain.enabled)) return;this._terrain || (this._terrain = new zi(this, e));const o = this._terrain;this.transform.elevation = i ? o : null, o.update(e, this.transform, t);
            }_updateFog(e) {
                const t = e.fog;if (!t || "globe" === this.transform.projection.name || t.getOpacity(this.transform.pitch) < 1 || t.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);const [i, o] = t.getFovAdjustedRange(this.transform._fov);if (i > o) return void (this.transform.fogCullDistSq = null);const r = i + .78 * (o - i);this.transform.fogCullDistSq = r * r;
            }get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
            }resize(t, i) {
                if (this.width = t * e.exported.devicePixelRatio, this.height = i * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._layers[e].resize();
            }setup() {
                const t = this.context,
                      i = new e.StructArrayLayout2i4();i.emplaceBack(0, 0), i.emplaceBack(e.EXTENT, 0), i.emplaceBack(0, e.EXTENT), i.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(i, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);const o = new e.StructArrayLayout2i4();o.emplaceBack(0, 0), o.emplaceBack(e.EXTENT, 0), o.emplaceBack(0, e.EXTENT), o.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t.createVertexBuffer(o, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);const r = new e.StructArrayLayout2i4();r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(r, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);const n = new e.StructArrayLayout4i8();n.emplaceBack(0, 0, 0, 0), n.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t.createVertexBuffer(n, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);const s = new e.StructArrayLayout3ui6();s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(s);const a = new e.StructArrayLayout1ui2();for (const e of [0, 1, 3, 2, 0]) a.emplaceBack(e);this.debugIndexBuffer = t.createIndexBuffer(a), this.emptyTexture = new e.Texture(t, new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA), this.identityMat = e.create();const l = this.context.gl;this.stencilClearMode = new e.StencilMode({ func: l.ALWAYS, mask: 0 }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Bo(this.context);
            }getMercatorTileBoundsBuffers() {
                return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
            }getTileBoundsBuffers(e) {
                return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? { tileBoundsBuffer: e._tileBoundsBuffer, tileBoundsIndexBuffer: e._tileBoundsIndexBuffer, tileBoundsSegments: e._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
            }clearStencil() {
                const t = this.context,
                      i = t.gl;this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t, i.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }_renderTileClippingMasks(t, i, o) {
                if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !o || 0 === o.length) return;if (this._tileClippingMaskIDs && !this.terrain) {
                    let e = !1;for (const t of o) if (void 0 === this._tileClippingMaskIDs[t.key]) {
                        e = !0;break;
                    }if (!e) return;
                }this.currentStencilSource = i.id;const r = this.context,
                      n = r.gl;this.nextStencilID + o.length > 256 && this.clearStencil(), r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);const s = this.useProgram("clippingMask");this._tileClippingMaskIDs = {};for (const t of o) {
                    const o = i.getTile(t),
                          a = this._tileClippingMaskIDs[t.key] = this.nextStencilID++,
                          { tileBoundsBuffer: l, tileBoundsIndexBuffer: c, tileBoundsSegments: h } = this.getTileBoundsBuffers(o);s.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n.ALWAYS, mask: 0 }, a, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(t.projMatrix), "$clipping", l, c, h);
                }
            }stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();const t = this.nextStencilID++,
                      i = this.context.gl;return new e.StencilMode({ func: i.NOTEQUAL, mask: 255 }, t, 255, i.KEEP, i.KEEP, i.REPLACE);
            }stencilModeForClipping(t) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);const i = this.context.gl;return new e.StencilMode({ func: i.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, i.KEEP, i.KEEP, i.REPLACE);
            }stencilConfigForOverlap(t) {
                const i = this.context.gl,
                      o = t.sort((e, t) => t.overscaledZ - e.overscaledZ),
                      r = o[o.length - 1].overscaledZ,
                      n = o[0].overscaledZ - r + 1;if (n > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + n > 256 && this.clearStencil();const t = {};for (let o = 0; o < n; o++) t[o + r] = new e.StencilMode({ func: i.GEQUAL, mask: 255 }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);return this.nextStencilID += n, [t, o];
                }return [{ [r]: e.StencilMode.disabled }, o];
            }colorModeForRenderPass() {
                const t = this.context.gl;if (this._showOverdrawInspector) {
                    const i = 1 / 8;return new e.ColorMode([t.CONSTANT_COLOR, t.ONE], new e.Color(i, i, i, 0), [!0, !0, !0, !0]);
                }return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
            }depthModeForSublayer(t, i, o) {
                if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled;const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;return new e.DepthMode(o || this.context.gl.LEQUAL, i, [r, r]);
            }opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }render(t, i) {
                this.style = t, this.options = i, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();const o = this.style.order,
                      r = this.style._sourceCaches;for (const e in r) {
                    const t = r[e];t.used && t.prepare(this.context);
                }const n = {},
                      s = {},
                      a = {};for (const e in r) {
                    const t = r[e];n[e] = t.getVisibleCoordinates(), s[e] = n[e].slice().reverse(), a[e] = t.getVisibleCoordinates(!0).reverse();
                }this.opaquePassCutoff = 1 / 0;for (let e = 0; e < o.length; e++) if (this.style._layers[o[e]].is3D()) {
                    this.opaquePassCutoff = e;break;
                }if (this.terrain && (this.terrain.updateTileBinding(a), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), e.isMapAuthenticated(this.context.gl)) {
                    this.renderPass = "offscreen";for (const e of o) {
                        const i = this.style._layers[e],
                              o = t._getLayerSourceCache(i);if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom)) continue;const r = o ? s[o.id] : void 0;("custom" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, o, i, r);
                    }if (this.depthRangeFor3D = [0, 1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i.showOverdrawInspector ? e.Color.black : e.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for (this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                        const e = this.style._layers[o[this.currentLayer]],
                              i = t._getLayerSourceCache(e);if (e.isSky()) continue;const r = i ? s[i.id] : void 0;this._renderTileClippingMasks(e, i, r), this.renderLayer(this, i, e, r);
                    }if (this.style.fog && this.transform.projection.supportsFog && function (t, i) {
                        const o = t.context,
                              r = o.gl,
                              n = t.transform,
                              s = new e.DepthMode(r.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),
                              a = t.useProgram("globeAtmosphere", null, "globe" === n.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]),
                              l = e.globeToMercatorTransition(n.zoom),
                              c = i.properties.get("color").toArray01(),
                              h = i.properties.get("high-color").toArray01(),
                              u = i.properties.get("space-color").toArray01PremultipliedAlpha(),
                              _ = e.identity$1([]);e.rotateY$1(_, _, -e.degToRad(n._center.lng)), e.rotateX$1(_, _, e.degToRad(n._center.lat)), e.rotateZ$1(_, _, n.angle), e.rotateX$1(_, _, -n._pitch);const d = e.fromQuat(new Float32Array(16), _),
                              p = e.mapValue(i.properties.get("star-intensity"), 0, 1, 0, .25),
                              m = 5e-4,
                              f = e.mapValue(i.properties.get("horizon-blend"), 0, 1, m, .25),
                              g = e.globeUseCustomAntiAliasing(t, o, n) && f === m ? n.worldSize / (2 * Math.PI * 1.025) - 1 : n.globeRadius,
                              v = t.frameCounter / 1e3 % 1,
                              x = e.length(n.globeCenterInViewSpace),
                              y = Math.sqrt(Math.pow(x, 2) - Math.pow(g, 2)),
                              b = Math.acos(y / x),
                              w = ((t, i, o, r, n, s, a, l, c, h, u, _, d, p) => ({ u_frustum_tl: t, u_frustum_tr: i, u_frustum_br: o, u_frustum_bl: r, u_horizon: n, u_transition: s, u_fadeout_range: a, u_color: l, u_high_color: c, u_space_color: h, u_star_intensity: u, u_star_size: 5 * e.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: _, u_horizon_angle: d, u_rotation_matrix: p }))(n.frustumCorners.TL, n.frustumCorners.TR, n.frustumCorners.BR, n.frustumCorners.BL, n.frustumCorners.horizon, l, f, c, h, u, p, v, b, d);t.prepareDrawProgram(o, a);const T = t.atmosphereBuffer;T && a.draw(o, r.TRIANGLES, s, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w, "skybox", T.vertexBuffer, T.indexBuffer, T.segments);
                    }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++) {
                        const e = this.style._layers[o[this.currentLayer]],
                              i = t._getLayerSourceCache(e);e.isSky() && this.renderLayer(this, i, e, i ? s[i.id] : void 0);
                    }for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o.length;) {
                        const e = this.style._layers[o[this.currentLayer]],
                              i = t._getLayerSourceCache(e);if (e.isSky()) {
                            ++this.currentLayer;continue;
                        }if (this.terrain && this.style.isLayerDraped(e)) {
                            if (e.isHidden(this.transform.zoom)) {
                                ++this.currentLayer;continue;
                            }this.currentLayer = this.terrain.renderBatch(this.currentLayer);continue;
                        }const r = i ? ("symbol" === e.type ? a : s)[i.id] : void 0;this._renderTileClippingMasks(e, i, i ? n[i.id] : void 0), this.renderLayer(this, i, e, r), ++this.currentLayer;
                    }if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                        let i = null;e.values(this.style._layers).forEach(e => {
                            const o = t._getLayerSourceCache(e);o && !e.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
                        }), i && this.options.showTileBoundaries && ko.debug(this, i, i.getVisibleCoordinates());
                    }this.options.showPadding && function (e) {
                        const t = e.transform.padding;Io(e, e.transform.height - (t.top || 0), 3, bo), Io(e, t.bottom || 0, 3, wo), So(e, t.left || 0, 3, To), So(e, e.transform.width - (t.right || 0), 3, Eo);const i = e.transform.centerPoint;!function (e, t, i, o) {
                            Do(e, t - 1, i - 10, 2, 20, o), Do(e, t - 10, i - 1, 20, 2, o);
                        }(e, i.x, e.transform.height - i.y, Co);
                    }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
                }
            }renderLayer(e, t, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), (!e.transform.projection.unsupportedLayers || !e.transform.projection.unsupportedLayers.includes(i.type) || e.terrain && "custom" === i.type) && ko[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }gpuTimingStart(e) {
                if (!this.options.gpuTiming) return;const t = this.context.extTimerQuery;let i = this.gpuTimers[e.id];i || (i = this.gpuTimers[e.id] = { calls: 0, cpuTime: 0, query: t.createQueryEXT() }), i.calls++, t.beginQueryEXT(t.TIME_ELAPSED_EXT, i.query);
            }gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e = this.context.extTimerQuery,
                          t = e.createQueryEXT();this.deferredRenderGpuTimeQueries.push(t), e.beginQueryEXT(e.TIME_ELAPSED_EXT, t);
                }
            }gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender) return;const e = this.context.extTimerQuery;e.endQueryEXT(e.TIME_ELAPSED_EXT);
            }gpuTimingEnd() {
                if (!this.options.gpuTiming) return;const e = this.context.extTimerQuery;e.endQueryEXT(e.TIME_ELAPSED_EXT);
            }collectGpuTimers() {
                const e = this.gpuTimers;return this.gpuTimers = {}, e;
            }collectDeferredRenderGpuQueries() {
                const e = this.deferredRenderGpuTimeQueries;return this.deferredRenderGpuTimeQueries = [], e;
            }queryGpuTimers(e) {
                const t = {};for (const i in e) {
                    const o = e[i],
                          r = this.context.extTimerQuery,
                          n = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;r.deleteQueryEXT(o.query), t[i] = n;
                }return t;
            }queryGpuTimeDeferredRender(e) {
                if (!this.options.gpuTimingDeferredRender) return 0;const t = this.context.extTimerQuery;let i = 0;for (const o of e) i += t.getQueryObjectEXT(o, t.QUERY_RESULT_EXT) / 1e6, t.deleteQueryEXT(o);return i;
            }translatePosMatrix(t, i, o, r, n) {
                if (!o[0] && !o[1]) return t;const s = n ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;if (s) {
                    const e = Math.sin(s),
                          t = Math.cos(s);o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];
                }const a = [n ? o[0] : P(i, o[0], this.transform.zoom), n ? o[1] : P(i, o[1], this.transform.zoom), 0],
                      l = new Float32Array(16);return e.translate(l, t, a), l;
            }saveTileTexture(e) {
                const t = this._tileTextures[e.size[0]];t ? t.push(e) : this._tileTextures[e.size[0]] = [e];
            }getTileTexture(e) {
                const t = this._tileTextures[e];return t && t.length > 0 ? t.pop() : null;
            }isPatternMissing(e) {
                return null === e || void 0 !== e && !this.imageManager.getPattern(e.toString());
            }terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
            }currentGlobalDefines() {
                const e = this.terrain && this.terrain.renderingToTexture,
                      t = this.terrain && 0 === this.terrain.exaggeration(),
                      i = this.style && this.style.fog,
                      o = [];return this.terrainRenderModeElevated() && o.push("TERRAIN"), "globe" === this.transform.projection.name && o.push("GLOBE"), t && o.push("ZERO_EXAGGERATION"), i && !e && 0 !== i.getOpacity(this.transform.pitch) && o.push("FOG"), e && o.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o.push("OVERDRAW_INSPECTOR"), o;
            }useProgram(e, t, i) {
                this.cache = this.cache || {};const o = i || [],
                      r = this.currentGlobalDefines().concat(o),
                      n = Pi.cacheKey(ui[e], e, r, t);return this.cache[n] || (this.cache[n] = new Pi(this.context, e, ui[e], t, lo[e], r)), this.cache[n];
            }setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }setBaseState() {
                const e = this.context.gl;this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
            }initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }destroy() {
                this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
            }prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }prepareDrawProgram(t, i, o) {
                if (this.terrain && this.terrain.renderingToTexture) return;const r = this.style.fog;if (r) {
                    const n = r.getOpacity(this.transform.pitch),
                          s = ((t, i, o, r, n, s, a, l, c, h, u) => {
                        const _ = t.transform,
                              d = i.properties.get("color").toArray01();d[3] = r;const p = t.frameCounter / 1e3 % 1;return { u_fog_matrix: o ? _.calculateFogTileMatrix(o) : t.identityMat, u_fog_range: i.getFovAdjustedRange(_._fov), u_fog_color: d, u_fog_horizon_blend: i.properties.get("horizon-blend"), u_fog_temporal_offset: p, u_frustum_tl: n, u_frustum_tr: s, u_frustum_br: a, u_frustum_bl: l, u_globe_pos: c, u_globe_radius: h, u_viewport: u, u_globe_transition: e.globeToMercatorTransition(_.zoom), u_is_globe: +("globe" === _.projection.name) };
                    })(this, r, o, n, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);i.setFogUniformValues(t, s);
                }
            }setTileLoadedFlag(e) {
                this.tileLoaded = e;
            }saveCanvasCopy() {
                const e = this.canvasCopy();e && (this.frameCopies.push(e), this.tileLoaded = !1);
            }canvasCopy() {
                const e = this.context.gl,
                      t = e.createTexture();return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;
            }getCanvasCopiesAndTimestamps() {
                return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
            }averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;const e = this.style && this.style.fog;return !!e && 0 !== e.getOpacity(this.transform.pitch);
            }getBackgroundTiles() {
                const t = this._backgroundTiles,
                      i = this._backgroundTiles = {},
                      o = this.transform.coveringTiles({ tileSize: 512 });for (const r of o) i[r.key] = t[r.key] || new e.Tile(r, 512, this.transform.tileZoom, this);return i;
            }clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
        }class Uo {
            constructor(e = 0, t = 0, i = 0, o = 0) {
                if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");this.top = e, this.bottom = t, this.left = i, this.right = o;
            }interpolate(t, i, o) {
                return null != i.top && null != t.top && (this.top = e.number(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.number(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.number(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.number(t.right, i.right, o)), this;
            }getCenter(t, i) {
                const o = e.clamp((this.left + t - this.right) / 2, 0, t),
                      r = e.clamp((this.top + i - this.bottom) / 2, 0, i);return new e.pointGeometry(o, r);
            }equals(e) {
                return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
            }clone() {
                return new Uo(this.top, this.bottom, this.left, this.right);
            }toJSON() {
                return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
        }function No(t, i) {
            const o = e.getColumn(t, 3);e.fromQuat(t, i), e.setColumn(t, 3, o);
        }function Go(t, i) {
            const o = e.identity$1([]);return e.rotateZ$1(o, o, -i), e.rotateX$1(o, o, -t), o;
        }function jo(t, i) {
            const o = [t[0], t[1], 0],
                  r = [i[0], i[1], 0];if (e.length(o) >= 1e-15) {
                const t = e.normalize([], o);e.scale$2(r, t, e.dot(r, t)), i[0] = r[0], i[1] = r[1];
            }const n = e.cross([], i, t);if (e.len(n) < 1e-15) return null;const s = Math.atan2(-n[1], n[0]);return Go(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), s);
        }class Zo {
            constructor(e, t) {
                this.position = e, this.orientation = t;
            }get position() {
                return this._position;
            }set position(t) {
                if (t) {
                    const i = t instanceof e.MercatorCoordinate ? t : new e.MercatorCoordinate(t[0], t[1], t[2]);this._renderWorldCopies && (i.x = e.wrap(i.x, 0, 1)), this._position = i;
                } else this._position = null;
            }lookAtPoint(t, i) {
                if (this.orientation = null, !this.position) return;const o = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)) : 0,
                      r = this.position,
                      n = e.MercatorCoordinate.fromLngLat(t, o),
                      s = [n.x - r.x, n.y - r.y, n.z - r.z];i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = jo(s, i);
            }setPitchBearing(t, i) {
                this.orientation = Go(e.degToRad(t), e.degToRad(-i));
            }
        }class Vo {
            constructor(t, i) {
                this._transform = e.identity([]), this.orientation = i, this.position = t;
            }get mercatorPosition() {
                const t = this.position;return new e.MercatorCoordinate(t[0], t[1], t[2]);
            }get position() {
                const t = e.getColumn(this._transform, 3);return [t[0], t[1], t[2]];
            }set position(t) {
                var i;t && e.setColumn(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);
            }get orientation() {
                return this._orientation;
            }set orientation(t) {
                this._orientation = t || e.identity$1([]), t && No(this._transform, this._orientation);
            }getPitchBearing() {
                const e = this.forward(),
                      t = this.right();return { bearing: Math.atan2(-t[1], t[0]), pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2]) };
            }setPitchBearing(e, t) {
                this._orientation = Go(e, t), No(this._transform, this._orientation);
            }forward() {
                const t = e.getColumn(this._transform, 2);return [-t[0], -t[1], -t[2]];
            }up() {
                const t = e.getColumn(this._transform, 1);return [-t[0], -t[1], -t[2]];
            }right() {
                const t = e.getColumn(this._transform, 0);return [t[0], t[1], t[2]];
            }getCameraToWorld(t, i) {
                const o = new Float64Array(16);return e.invert(o, this.getWorldToCamera(t, i)), o;
            }getWorldToCameraPosition(t, i, o) {
                const r = this.position;e.scale$2(r, r, -t);const n = new Float64Array(16);return e.fromScaling(n, [o, o, o]), e.translate(n, n, r), n[10] *= i, n;
            }getWorldToCamera(t, i) {
                const o = new Float64Array(16),
                      r = new Float64Array(4),
                      n = this.position;return e.conjugate(r, this._orientation), e.scale$2(n, n, -t), e.fromQuat(o, r), e.translate(o, o, n), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
            }getCameraToClipPerspective(t, i, o, r) {
                const n = new Float64Array(16);return e.perspective(n, t, i, o, r), n;
            }getDistanceToElevation(t, i = !1) {
                const o = 0 === t ? 0 : e.mercatorZfromAltitude(t, i ? e.latFromMercatorY(this.position[1]) : this.position[1]),
                      r = this.forward();return (o - this.position[2]) / r[2];
            }clone() {
                return new Vo([...this.position], [...this.orientation]);
            }
        }function Wo(t, i) {
            const o = qo(t.projection, t.zoom, t.width, t.height),
                  r = function (t, i, o, r, n) {
                const s = new e.LngLat(o.lng - 180 * $o, o.lat),
                      a = new e.LngLat(o.lng + 180 * $o, o.lat),
                      l = t.project(s.lng, s.lat),
                      c = t.project(a.lng, a.lat),
                      h = -Math.atan2(c.y - l.y, c.x - l.x),
                      u = e.MercatorCoordinate.fromLngLat(o);u.y = e.clamp(u.y, -.999975, .999975);const _ = u.toLngLat(),
                      d = t.project(_.lng, _.lat),
                      p = e.MercatorCoordinate.fromLngLat(_);p.x += $o;const m = p.toLngLat(),
                      f = t.project(m.lng, m.lat),
                      g = Yo(f.x - d.x, f.y - d.y, h),
                      v = e.MercatorCoordinate.fromLngLat(_);v.y += $o;const x = v.toLngLat(),
                      y = t.project(x.lng, x.lat),
                      b = Yo(y.x - d.x, y.y - d.y, h),
                      w = Math.abs(g.x) / Math.abs(b.y),
                      T = e.identity([]);e.rotateZ(T, T, -h * (1 - (n ? 0 : r)));const E = e.identity([]);return e.scale(E, E, [1, 1 - (1 - w) * r, 1]), E[4] = -b.x / b.y * r, e.rotateZ(E, E, h), e.multiply(E, T, E), E;
            }(t.projection, 0, t.center, o, i),
                  n = Xo(t);return e.scale(r, r, [n, n, 1]), r;
        }function Xo(t) {
            const i = t.projection,
                  o = qo(t.projection, t.zoom, t.width, t.height),
                  r = Ho(i, t.center),
                  n = Ho(i, e.LngLat.convert(i.center));return Math.pow(2, r * o + (1 - o) * n);
        }function qo(t, i, o, r, n = 1 / 0) {
            const s = t.range;if (!s) return 0;const a = Math.min(n, Math.max(o, r)),
                  l = Math.log(a / 1024) / Math.LN2;return e.smoothstep(s[0] + l, s[1] + l, i);
        }const $o = 1 / 4e4;function Ho(t, i) {
            const o = e.clamp(i.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
                  r = new e.LngLat(i.lng - 180 * $o, o),
                  n = new e.LngLat(i.lng + 180 * $o, o),
                  s = t.project(r.lng, o),
                  a = t.project(n.lng, o),
                  l = e.MercatorCoordinate.fromLngLat(r),
                  c = e.MercatorCoordinate.fromLngLat(n),
                  h = a.x - s.x,
                  u = a.y - s.y,
                  _ = c.x - l.x,
                  d = c.y - l.y,
                  p = Math.sqrt((_ * _ + d * d) / (h * h + u * u));return Math.log(p) / Math.LN2;
        }function Yo(e, t, i) {
            const o = Math.cos(i),
                  r = Math.sin(i);return { x: e * o - t * r, y: e * r + t * o };
        }class Ko {
            constructor(t, i, o, r, n, s, a) {
                this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(s), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Uo(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Vo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = .1;
            }clone() {
                const e = new Ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e;
            }get elevation() {
                return this._elevation;
            }set elevation(e) {
                this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
            }updateElevation(e, t = !1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;(null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t), this._calcMatrices();
            }getProjection() {
                return e.pick(this.projection, ["name", "center", "parallels"]);
            }setProjection(i) {
                this.projectionOptions = i || { name: "mercator" };const o = this.projection ? this.getProjection() : void 0;this.projection = e.getProjection(this.projectionOptions);const r = !t(o, this.getProjection());return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;
            }setMercatorFromTransition() {
                const t = this.projection.name;this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = e.getProjection({ name: "mercator" });const i = t !== this.projection.name;return i && this._calcMatrices(), i;
            }get minZoom() {
                return this._minZoom;
            }set minZoom(e) {
                this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
            }get maxZoom() {
                return this._maxZoom;
            }set maxZoom(e) {
                this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
            }get minPitch() {
                return this._minPitch;
            }set minPitch(e) {
                this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
            }get maxPitch() {
                return this._maxPitch;
            }set maxPitch(e) {
                this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
            }get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }set renderWorldCopies(e) {
                void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
            }get worldSize() {
                return this.tileSize * this.scale;
            }get cameraWorldSizeForFog() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }get cameraWorldSize() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }get cameraPixelsPerMeter() {
                return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
            }get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }get size() {
                return new e.pointGeometry(this.width, this.height);
            }get bearing() {
                return e.wrap(this.rotation, -180, 180);
            }set bearing(e) {
                this.rotation = e;
            }get rotation() {
                return -this.angle / Math.PI * 180;
            }set rotation(t) {
                const i = -t * Math.PI / 180;var o;this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function (e, t, i) {
                    var o = t[0],
                        r = t[1],
                        n = t[2],
                        s = t[3],
                        a = Math.sin(i),
                        l = Math.cos(i);e[0] = o * l + n * a, e[1] = r * l + s * a, e[2] = o * -a + n * l, e[3] = r * -a + s * l;
                }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }get pitch() {
                return this._pitch / Math.PI * 180;
            }set pitch(t) {
                const i = e.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI;this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }get aspect() {
                return this.width / this.height;
            }get fovX() {
                return this._fov;
            }get fovY() {
                const e = 1 / Math.tan(.5 * this.fovX);return 2 * Math.atan(1 / this.aspect / e);
            }set fov(t) {
                t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e.degToRad(t), this._calcMatrices());
            }get averageElevation() {
                return this._averageElevation;
            }set averageElevation(e) {
                this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }get zoom() {
                return this._zoom;
            }set zoom(e) {
                const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }_setZoom(e) {
                this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
            }_updateCameraOnTerrain() {
                if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);const e = this._elevation;this._centerAltitude = e.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e.exaggeration(), this._updateSeaLevelZoom();
            }_updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }sampleAverageElevation() {
                if (!this._elevation) return 0;const t = this._elevation,
                      i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],
                      o = this.horizonLineFromTop();let r = 0,
                    n = 0;for (let s = 0; s < i.length; s++) {
                    const a = new e.pointGeometry(i[s][0] * this.width, o + i[s][1] * (this.height - o)),
                          l = t.pointCoordinate(a);if (!l) continue;const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);r += l[3] * c, n += c;
                }return 0 === n ? NaN : r / n;
            }get center() {
                return this._center;
            }set center(e) {
                e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }_updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;const e = this._seaLevelZoom,
                      t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),
                      i = this.pixelsPerMeter / this.worldSize * t,
                      o = this._mercatorZfromZoom(e),
                      r = this._mercatorZfromZoom(this._maxZoom),
                      n = Math.max(o - i, r);this._setZoom(this._zoomFromMercatorZ(n));
            }get padding() {
                return this._edgeInsets.toJSON();
            }set padding(e) {
                this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
            }computeZoomRelativeTo(t) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));let o;o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];const r = e.length(e.sub([], this._camera.position, o));return e.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
            }setFreeCameraOptions(t) {
                if (!this.height) return;if (!t.position && !t.orientation) return;this._updateCameraState();let i = !1;if (t.orientation && !e.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {
                    const o = [t.position.x, t.position.y, t.position.z];e.exactEquals$1(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
                }i && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }getFreeCameraOptions() {
                this._updateCameraState();const t = this._camera.position,
                      i = new Zo();return i.position = new e.MercatorCoordinate(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
            }_setCameraOrientation(t) {
                if (!e.length$1(t)) return !1;e.normalize$1(t, t);const i = e.transformQuat([], [0, 0, -1], t),
                      o = e.transformQuat([], [0, -1, 0], t);if (o[2] < 0) return !1;const r = jo(i, o);return !!r && (this._camera.orientation = r, !0);
            }_setCameraPosition(t) {
                const i = this.zoomScale(this.minZoom) * this.tileSize,
                      o = this.zoomScale(this.maxZoom) * this.tileSize,
                      r = this.cameraToCenterDistance;t[2] = e.clamp(t[2], r / o, r / i), this._camera.position = t;
            }get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height);
            }isPaddingEqual(e) {
                return this._edgeInsets.equals(e);
            }interpolatePadding(e, t, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();
            }coveringZoomLevel(e) {
                const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));return Math.max(0, t);
            }getVisibleUnwrappedCoordinates(t) {
                const i = [new e.UnwrappedTileID(0, t)];if (this.renderWorldCopies) {
                    const o = this.pointCoordinate(new e.pointGeometry(0, 0)),
                          r = this.pointCoordinate(new e.pointGeometry(this.width, 0)),
                          n = this.pointCoordinate(new e.pointGeometry(this.width, this.height)),
                          s = this.pointCoordinate(new e.pointGeometry(0, this.height)),
                          a = Math.floor(Math.min(o.x, r.x, n.x, s.x)),
                          l = Math.floor(Math.max(o.x, r.x, n.x, s.x)),
                          c = 1;for (let o = a - c; o <= l + c; o++) 0 !== o && i.push(new e.UnwrappedTileID(o, t));
                }return i;
            }coveringTiles(t) {
                let i = this.coveringZoomLevel(t);const o = i,
                      r = this.elevation && !t.isTerrainDEM,
                      n = "mercator" === this.projection.name;if (void 0 !== t.minzoom && i < t.minzoom) return [];void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);const s = this.locationCoordinate(this.center),
                      a = this.center.lat,
                      l = 1 << i,
                      c = [l * s.x, l * s.y, 0],
                      h = "globe" === this.projection.name,
                      u = !h,
                      _ = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u),
                      d = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),
                      p = l * e.mercatorZfromAltitude(1, this.center.lat),
                      m = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat),
                      f = [l * d.x, l * d.y, m * (u ? 1 : p)],
                      g = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),
                      v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0,
                      x = t.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude,
                      y = t.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,
                      b = this.projection.isReprojectedInTileSpace ? Xo(this) : 1,
                      w = t => {
                    const i = 1 / 4e4,
                          o = new e.MercatorCoordinate(t.x + i, t.y, t.z),
                          r = new e.MercatorCoordinate(t.x, t.y + i, t.z),
                          n = t.toLngLat(),
                          s = o.toLngLat(),
                          a = r.toLngLat(),
                          l = this.locationCoordinate(n),
                          c = this.locationCoordinate(s),
                          h = this.locationCoordinate(a),
                          u = Math.hypot(c.x - l.x, c.y - l.y),
                          _ = Math.hypot(h.x - l.x, h.y - l.y);return Math.sqrt(u * _) * b / i;
                },
                      T = t => {
                    const i = x,
                          o = y;return { aabb: e.tileAABB(this, l, 0, 0, 0, t, o, i, this.projection), zoom: 0, x: 0, y: 0, minZ: o, maxZ: i, wrap: t, fullyVisible: !1 };
                },
                      E = [];let C = [];const M = i,
                      I = t.reparseOverscaled ? o : i,
                      S = e => e * e,
                      D = S((m - this._centerAltitude) * p),
                      L = e => {
                    if (!this._elevation || !e.tileID || !n) return;const t = this._elevation.getMinMaxForTile(e.tileID),
                          i = e.aabb;t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = A(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                },
                      A = t => {
                    if (t.zoom < v) return !0;if (t.zoom === M) return !1;if (null != t.shouldSplit) return t.shouldSplit;const i = t.aabb.distanceX(f),
                          n = t.aabb.distanceY(f);let s = D,
                        l = 1;if (h) {
                        s = S(t.aabb.distanceZ(f));const i = Math.pow(2, t.zoom),
                              o = e.latFromMercatorY((t.y + 1) / i),
                              r = e.latFromMercatorY(t.y / i),
                              n = Math.min(Math.max(a, o), r),
                              c = e.circumferenceAtLatitude(n) / e.circumferenceAtLatitude(a);if (l = n === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t.zoom === M - 1 && c >= .9) return !0;
                    } else if (r && (s = S(t.aabb.distanceZ(f) * p)), this.projection.isReprojectedInTileSpace && o <= 5) {
                        const i = Math.pow(2, t.zoom),
                              o = w(new e.MercatorCoordinate((t.x + .5) / i, (t.y + .5) / i));l = o > .85 ? 1 : o;
                    }const c = i * i + n * n + s,
                          u = S((1 << M - t.zoom) * g * l * ((e, t) => {
                        if (t * S(.707) < e) return 1;const i = Math.sqrt(t / e);return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                    })(Math.max(s, D), c));return c < u;
                };if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) E.push(T(-e)), E.push(T(e));for (E.push(T(0)); E.length > 0;) {
                    const o = E.pop(),
                          s = o.x,
                          a = o.y;let u = o.fullyVisible;if (!u) {
                        const e = o.aabb.intersects(_);if (0 === e) continue;u = 2 === e;
                    }if (o.zoom !== M && A(o)) for (let t = 0; t < 4; t++) {
                        const i = (s << 1) + t % 2,
                              c = (a << 1) + (t >> 1),
                              _ = { aabb: n ? o.aabb.quadrant(t) : e.tileAABB(this, l, o.zoom + 1, i, c, o.wrap, o.minZ, o.maxZ, this.projection), zoom: o.zoom + 1, x: i, y: c, wrap: o.wrap, fullyVisible: u, tileID: void 0, shouldSplit: void 0, minZ: o.minZ, maxZ: o.maxZ };r && !h && (_.tileID = new e.OverscaledTileID(o.zoom + 1 === M ? I : o.zoom + 1, o.wrap, o.zoom + 1, i, c), L(_)), E.push(_);
                    } else {
                        const r = o.zoom === M ? I : o.zoom;if (t.minzoom && t.minzoom > r) continue;const n = c[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom),
                              l = c[1] - .5 - a,
                              h = o.tileID ? o.tileID : new e.OverscaledTileID(r, o.wrap, o.zoom, s, a);C.push({ tileID: h, distanceSq: n * n + l * l });
                    }
                }if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq,
                          o = this.horizonLineFromTop();C = C.filter(r => {
                        const n = [0, 0, 0, 1],
                              s = [e.EXTENT, e.EXTENT, 0, 1],
                              a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());e.transformMat4$1(n, n, a), e.transformMat4$1(s, s, a);const l = e.getAABBPointSquareDist(n, s);if (0 === l) return !0;let c = !1;const h = this._elevation;if (h && l > i && 0 !== o) {
                            const i = this.calculateProjMatrix(r.tileID.toUnwrapped());let n;t.isTerrainDEM || (n = h.getMinMaxForTile(r.tileID)), n || (n = { min: y, max: x });const s = e.furthestTileCorner(this.rotation),
                                  a = [s[0] * e.EXTENT, s[1] * e.EXTENT, n.max];e.transformMat4(a, a, i), c = (1 - a[1]) * this.height * .5 < o;
                        }return l < i || c;
                    });
                }return C.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);
            }resize(e, t) {
                this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();
            }get unmodified() {
                return this._unmodified;
            }zoomScale(e) {
                return Math.pow(2, e);
            }scaleZoom(e) {
                return Math.log(e) / Math.LN2;
            }project(t) {
                const i = e.clamp(t.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
                      o = this.projection.project(t.lng, i);return new e.pointGeometry(o.x * this.worldSize, o.y * this.worldSize);
            }unproject(e) {
                return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
            }get point() {
                return this.project(this.center);
            }get pointMerc() {
                return this.point._div(this.worldSize);
            }get pixelsPerMeterRatio() {
                return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
            }setLocationAtPoint(t, i) {
                let o, r;const n = this.centerPoint;if ("globe" === this.projection.name) {
                    const e = this.worldSize;o = (i.x - n.x) / e, r = (i.y - n.y) / e;
                } else {
                    const e = this.pointCoordinate(i),
                          t = this.pointCoordinate(n);o = e.x - t.x, r = e.y - t.y;
                }const s = this.locationCoordinate(t);this.setLocation(new e.MercatorCoordinate(s.x - o, s.y - r));
            }setLocation(e) {
                this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
            }locationPoint(e) {
                return this.projection.locationPoint(this, e);
            }locationPoint3D(e) {
                return this.projection.locationPoint(this, e, !0);
            }pointLocation(e) {
                return this.coordinateLocation(this.pointCoordinate(e));
            }pointLocation3D(e) {
                return this.coordinateLocation(this.pointCoordinate3D(e));
            }locationCoordinate(t, i) {
                const o = i ? e.mercatorZfromAltitude(i, t.lat) : void 0,
                      r = this.projection.project(t.lng, t.lat);return new e.MercatorCoordinate(r.x, r.y, o);
            }coordinateLocation(e) {
                return this.projection.unproject(e.x, e.y);
            }pointRayIntersection(t, i) {
                const o = null != i ? i : this._centerAltitude,
                      r = [t.x, t.y, 0, 1],
                      n = [t.x, t.y, 1, 1];e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(n, n, this.pixelMatrixInverse);const s = n[3];e.scale$1(r, r, 1 / r[3]), e.scale$1(n, n, 1 / s);const a = r[2],
                      l = n[2];return { p0: r, p1: n, t: a === l ? 0 : (o - a) / (l - a) };
            }screenPointToMercatorRay(t) {
                const i = [t.x, t.y, 0, 1],
                      o = [t.x, t.y, 1, 1];return e.transformMat4$1(i, i, this.pixelMatrixInverse), e.transformMat4$1(o, o, this.pixelMatrixInverse), e.scale$1(i, i, 1 / i[3]), e.scale$1(o, o, 1 / o[3]), i[2] = e.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, o[2] = e.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, e.scale$1(i, i, 1 / this.worldSize), e.scale$1(o, o, 1 / this.worldSize), new e.Ray([i[0], i[1], i[2]], e.normalize([], e.sub([], o, i)));
            }rayIntersectionCoordinate(t) {
                const { p0: i, p1: o, t: r } = t,
                      n = e.mercatorZfromAltitude(i[2], this._center.lat),
                      s = e.mercatorZfromAltitude(o[2], this._center.lat);return new e.MercatorCoordinate(e.number(i[0], o[0], r) / this.worldSize, e.number(i[1], o[1], r) / this.worldSize, e.number(n, s, r));
            }pointCoordinate(e, t = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e.x, e.y, t);
            }pointCoordinate3D(t) {
                if (!this.elevation) return this.pointCoordinate(t);let i = this.projection.pointCoordinate3D(this, t.x, t.y);if (i) return new e.MercatorCoordinate(i[0], i[1], i[2]);let o = 0,
                    r = this.horizonLineFromTop();if (t.y > r) return this.pointCoordinate(t);const n = .02 * r,
                      s = t.clone();for (let t = 0; t < 10 && r - o > n; t++) {
                    s.y = e.number(o, r, .66);const t = this.projection.pointCoordinate3D(this, s.x, s.y);t ? (r = s.y, i = t) : o = s.y;
                }return i ? new e.MercatorCoordinate(i[0], i[1], i[2]) : this.pointCoordinate(t);
            }isPointAboveHorizon(e) {
                return this.projection.isPointAboveHorizon(this, e);
            }_coordinatePoint(t, i) {
                const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,
                      r = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];return e.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e.pointGeometry(r[0] / r[3], r[1] / r[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
            }_getBoundsNonRectangular() {
                const { top: t, left: i } = this._edgeInsets,
                      o = this.height - this._edgeInsets.bottom,
                      r = this.width - this._edgeInsets.right,
                      n = this.pointLocation3D(new e.pointGeometry(i, t)),
                      s = this.pointLocation3D(new e.pointGeometry(r, t)),
                      a = this.pointLocation3D(new e.pointGeometry(r, o)),
                      l = this.pointLocation3D(new e.pointGeometry(i, o));let c = Math.min(n.lng, s.lng, a.lng, l.lng),
                    h = Math.max(n.lng, s.lng, a.lng, l.lng),
                    u = Math.min(n.lat, s.lat, a.lat, l.lat),
                    _ = Math.max(n.lat, s.lat, a.lat, l.lat);const d = Math.pow(2, -this.zoom) / 16 * 270,
                      p = "globe" === this.projection.name ? 1 : 4,
                      m = (t, i, o, r, n) => {
                    const s = (t + o) / 2,
                          a = (i + r) / 2,
                          l = new e.pointGeometry(s, a),
                          { lng: f, lat: g } = this.pointLocation3D(l),
                          v = Math.max(0, c - f, u - g, f - h, g - _);c = Math.min(c, f), h = Math.max(h, f), u = Math.min(u, g), _ = Math.max(_, g), (n < p || v > d) && (m(t, i, s, a, n + 1), m(s, a, o, r, n + 1));
                };if (m(i, t, r, t, 1), m(r, t, r, o, 1), m(r, o, i, o, 1), m(i, o, i, t, 1), "globe" === this.projection.name) {
                    const [t, i] = e.polesInViewport(this);t ? (_ = 90, h = 180, c = -180) : i && (u = -90, h = 180, c = -180);
                }return new e.LngLatBounds(new e.LngLat(c, u), new e.LngLat(h, _));
            }_getBoundsRectangular(t, i) {
                const { top: o, left: r } = this._edgeInsets,
                      n = this.height - this._edgeInsets.bottom,
                      s = this.width - this._edgeInsets.right,
                      a = new e.pointGeometry(r, o),
                      l = new e.pointGeometry(s, o),
                      c = new e.pointGeometry(s, n),
                      h = new e.pointGeometry(r, n);let u = this.pointCoordinate(a, t),
                    _ = this.pointCoordinate(l, t);const d = this.pointCoordinate(c, i),
                      p = this.pointCoordinate(h, i),
                      m = (e, t) => (t.y - e.y) / (t.x - e.x);return u.y > 1 && _.y >= 0 ? u = new e.MercatorCoordinate((1 - p.y) / m(p, u) + p.x, 1) : u.y < 0 && _.y <= 1 && (u = new e.MercatorCoordinate(-p.y / m(p, u) + p.x, 0)), _.y > 1 && u.y >= 0 ? _ = new e.MercatorCoordinate((1 - d.y) / m(d, _) + d.x, 1) : _.y < 0 && u.y <= 1 && (_ = new e.MercatorCoordinate(-d.y / m(d, _) + d.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(u)).extend(this.coordinateLocation(_)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(d));
            }_getBoundsRectangularTerrain() {
                const e = this.elevation;if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);const t = e.visibleDemTiles.reduce((e, t) => {
                    if (t.dem) {
                        const i = t.dem.tree;e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);
                    }return e;
                }, { min: Number.MAX_VALUE, max: 0 });return this._getBoundsRectangular(t.min * e.exaggeration(), t.max * e.exaggeration());
            }getBounds() {
                return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }horizonLineFromTop(e = !0) {
                const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y,
                      i = this.height / 2 - t * (1 - this._horizonShift);return e ? Math.max(0, i) : i;
            }getMaxBounds() {
                return this.maxBounds;
            }setMaxBounds(t) {
                this.maxBounds = t, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
            }calculatePosMatrix(e, t) {
                return this.projection.createTileMatrix(this, t, e);
            }calculateDistanceTileData(t) {
                const i = t.key,
                      o = this._distanceTileDataCache;if (o[i]) return o[i];const r = t.canonical,
                      n = 1 / this.height,
                      s = this.cameraWorldSize,
                      a = s / this.zoomScale(r.z),
                      l = (r.x + Math.pow(2, r.z) * t.wrap) * a,
                      c = r.y * a,
                      h = this.point;h.x *= s / this.worldSize, h.y *= s / this.worldSize;const u = this.angle,
                      _ = Math.sin(-u),
                      d = -Math.cos(-u);return o[i] = { bearing: [_, d], center: [(h.x - l) * n, (h.y - c) * n], scale: a / e.EXTENT * n }, o[i];
            }calculateFogTileMatrix(t) {
                const i = t.key,
                      o = this._fogTileMatrixCache;if (o[i]) return o[i];const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);return e.multiply(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];
            }calculateProjMatrix(t, i = !1) {
                const o = t.key,
                      r = i ? this._alignedProjMatrixCache : this._projMatrixCache;if (r[o]) return r[o];const n = this.calculatePosMatrix(t, this.worldSize);return e.multiply(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n), r[o] = new Float32Array(n), r[o];
            }calculatePixelsToTileUnitsMatrix(t) {
                const i = t.tileID.key,
                      o = this._pixelsToTileUnitsCache;if (o[i]) return o[i];const r = function (t, i) {
                    const { scale: o } = t.tileTransform,
                          r = o * e.EXTENT / (t.tileSize * Math.pow(2, i.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));return n = new Float32Array(4), l = (s = i.inverseAdjustmentMatrix)[1], c = s[2], h = s[3], _ = (a = [r, r])[1], n[0] = s[0] * (u = a[0]), n[1] = l * u, n[2] = c * _, n[3] = h * _, n;var n, s, a, l, c, h, u, _;
                }(t, this);return o[i] = r, o[i];
            }customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                    const t = 1 / this.worldSize,
                          i = e.fromScaling([], [t, t, t]);return e.multiply(i, i, this.globeMatrix), i;
                }
            }recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;const t = this._elevation;this._updateCameraState();const i = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
                      o = this._computeCameraPosition(i),
                      r = this._camera.forward(),
                      n = e.mercatorZfromAltitude(1, this._center.lat);o[2] /= n, r[2] /= n, e.normalize(r, r);const s = t.raycast(o, r, t.exaggeration());if (s) {
                    const t = e.scaleAndAdd([], o, r, s),
                          i = new e.MercatorCoordinate(t[0], t[1], e.mercatorZfromAltitude(t[2], e.latFromMercatorY(t[1]))),
                          a = (i.z + e.length([i.x - o[0], i.y - o[1], i.z - o[2] * n])) * this._pixelsPerMercatorPixel;this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }_constrainCamera(t = !1) {
                if (!this._elevation) return;const i = this._elevation,
                      o = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
                      r = this._computeCameraPosition(o),
                      n = i.getAtPointOrZero(new e.MercatorCoordinate(...r)),
                      s = this.pixelsPerMeter / this.worldSize * n,
                      a = this._minimumHeightOverTerrain(),
                      l = r[2] - s;if (l <= a) if (l < 0 || t) {
                    const t = this.locationCoordinate(this._center, this._centerAltitude),
                          i = [r[0], r[1], t.z - r[2]],
                          o = e.length(i);i[2] -= (a - l) / this._pixelsPerMercatorPixel;const n = e.length(i);if (0 === n) return;e.scale$2(i, i, o / n * this._pixelsPerMercatorPixel), this._camera.position = [r[0], r[1], t.z * this._pixelsPerMercatorPixel - i[2]], this._updateStateFromCamera();
                } else this._isCameraConstrained = !0;
            }_constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;this._constraining = !0;const t = "globe" === this.projection.name || this.mercatorFromTransition;if (this.projection.isReprojectedInTileSpace || t) {
                    const i = this.center;return i.lat = e.clamp(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (i.lng = e.clamp(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
                }const i = this._unmodified,
                      { x: o, y: r } = this.point;let n = 0,
                    s = o,
                    a = r;const l = this.width / 2,
                      c = this.height / 2,
                      h = this.worldMinY * this.scale,
                      u = this.worldMaxY * this.scale;if (r - c < h && (a = h + c), r + c > u && (a = u - c), u - h < this.height && (n = Math.max(n, this.height / (u - h)), a = (u + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e = this.worldMinX * this.scale,
                          t = this.worldMaxX * this.scale,
                          i = this.worldSize / 2 - (e + t) / 2;s = (o + i + this.worldSize) % this.worldSize - i, s - l < e && (s = e + l), s + l > t && (s = t - l), t - e < this.width && (n = Math.max(n, this.width / (t - e)), s = (t + e) / 2);
                }s === o && a === r || (this.center = this.unproject(new e.pointGeometry(s, a))), n && (this.zoom += this.scaleZoom(n)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
            }_minZoomForBounds() {
                let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;
            }_maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }_calcMatrices() {
                if (!this.height) return;const t = this.centerOffset,
                      i = this.pixelsPerMeter;"globe" === this.projection.name && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));const o = qo(this.projection, this.zoom, this.width, this.height, 1024);this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;const r = "meters" === this.projection.zAxisUnit ? i : 1,
                      n = this._camera.getWorldToCamera(this.worldSize, r),
                      s = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);s[8] = 2 * -t.x / this.width, s[9] = 2 * t.y / this.height;let a = e.mul([], s, n);if (this.projection.isReprojectedInTileSpace) {
                    const t = this.locationCoordinate(this.center),
                          i = e.identity([]);e.translate(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.multiply(i, i, Wo(this)), e.translate(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.multiply(a, a, i), this.inverseAdjustmentMatrix = function (e) {
                        const t = Wo(e, !0);return v([], [t[0], t[1], t[4], t[5]]);
                    }(this);
                } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];this.mercatorMatrix = e.scale([], a, [this.worldSize, this.worldSize, this.worldSize / r, 1]), this.projMatrix = a, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);const l = e.invert([], s);this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(l, this.horizonLineFromTop(), this.height);const c = new Float32Array(16);e.identity(c), e.scale(c, c, [1, -1, 1]), e.rotateX(c, c, this._pitch), e.rotateZ(c, c, this.angle);const h = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ),
                      u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;h[8] = 2 * -t.x / this.width, h[9] = 2 * (t.y + u) / this.height, this.skyboxMatrix = e.multiply(c, h, c);const _ = this.point,
                      d = _.x,
                      p = _.y,
                      m = this.width % 2 / 2,
                      f = this.height % 2 / 2,
                      g = Math.cos(this.angle),
                      x = Math.sin(this.angle),
                      y = d - Math.round(d) + g * m + x * f,
                      b = p - Math.round(p) + g * f + x * m,
                      w = new Float64Array(a);if (e.translate(w, w, [y > .5 ? y - 1 : y, b > .5 ? b - 1 : b, 0]), this.alignedProjMatrix = w, a = e.create(), e.scale(a, a, [this.width / 2, -this.height / 2, 1]), e.translate(a, a, [1, -1, 0]), this.labelPlaneMatrix = a, a = e.create(), e.scale(a, a, [1, -1, 1]), e.translate(a, a, [-1, -1, 0]), e.scale(a, a, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error("failed to invert matrix");if (this.pixelMatrixInverse = a, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e.calculateGlobeMatrix(this);const t = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];this.globeCenterInViewSpace = e.transformMat4(t, t, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = a;this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
            }_calcFogMatrices() {
                this._fogTileMatrixCache = {};const t = this.cameraWorldSizeForFog,
                      i = this.cameraPixelsPerMeter,
                      o = this._camera.position,
                      r = 1 / this.height / this._pixelsPerMercatorPixel,
                      n = [t, t, i];e.scale$2(n, n, r), e.scale$2(o, o, -1), e.multiply$2(o, o, n);const s = e.create();e.translate(s, s, o), e.scale(s, s, n), this.mercatorFogMatrix = s, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, r);
            }_computeCameraPosition(e) {
                const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,
                      i = this._camera.forward(),
                      o = this.point,
                      r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;return [o.x / this.worldSize - i[0] * r, o.y / this.worldSize - i[1] * r, e / this.worldSize * this._centerAltitude - i[2] * r];
            }_updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }_translateCameraConstrained(t) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),
                      o = this._camera.position[2],
                      r = t[2];let n = 1;this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (n = Math.min((i - o) / r, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t, n), this._updateStateFromCamera();
            }_updateStateFromCamera() {
                const t = this._camera.position,
                      i = this._camera.forward(),
                      { pitch: o, bearing: r } = this._camera.getPitchBearing(),
                      n = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,
                      s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)),
                      a = Math.max((t[2] - n) / Math.cos(o), s),
                      l = this._zoomFromMercatorZ(a);e.scaleAndAdd(t, t, i, a), this._pitch = e.clamp(o, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r, -Math.PI, Math.PI), this._setZoom(e.clamp(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }_worldSizeFromZoom(e) {
                return Math.pow(2, e) * this.tileSize;
            }_mercatorZfromZoom(e) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
            }_minimumHeightOverTerrain() {
                const e = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);return this._mercatorZfromZoom(e);
            }_zoomFromMercatorZ(e) {
                return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));
            }zoomFromMercatorZAdjusted(t) {
                let i = 0,
                    o = e.GLOBE_ZOOM_THRESHOLD_MAX,
                    r = 0,
                    n = 1 / 0;for (; o - i > 1e-6 && o > i;) {
                    const e = i + .5 * (o - i),
                          s = this.tileSize * Math.pow(2, e),
                          a = this.getCameraToCenterDistance(this.projection, e, s),
                          l = this.scaleZoom(a / (t * this.tileSize)),
                          c = Math.abs(e - l);c < n && (n = c, r = e), e < l ? i = e : o = e;
                }return r;
            }_terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }anyCornerOffEdge(t, i) {
                const o = Math.min(t.x, i.x),
                      r = Math.max(t.x, i.x),
                      n = Math.min(t.y, i.y),
                      s = Math.max(t.y, i.y);if (n < this.horizonLineFromTop(!1)) return !0;if ("mercator" !== this.projection.name) return !1;const a = [new e.pointGeometry(o, n), new e.pointGeometry(r, s), new e.pointGeometry(o, s), new e.pointGeometry(r, n)],
                      l = this.renderWorldCopies ? -3 : 0,
                      c = this.renderWorldCopies ? 4 : 1;for (const e of a) {
                    const t = this.pointRayIntersection(e);if (t.t < 0) return !0;const i = this.rayIntersectionCoordinate(t);if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
                }return !1;
            }isHorizonVisible() {
                return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
            }zoomDeltaToMovement(t, i) {
                const o = e.length(e.sub([], this._camera.position, t)),
                      r = this._zoomFromMercatorZ(o) + i;return o - this._mercatorZfromZoom(r);
            }getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t = function ([t, i, o], r) {
                        const n = [t, i, o, 1];e.transformMat4$1(n, n, r);const s = n[3] = Math.max(n[3], 1e-6);return n[0] /= s, n[1] /= s, n[2] /= s, n;
                    }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);return new e.pointGeometry(t[0], t[1]);
                }{
                    const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);return this.centerPoint.add(new e.pointGeometry(0, t));
                }
            }getCameraToCenterDistance(e, t = this.zoom, i = this.worldSize) {
                const o = qo(e, t, this.width, this.height, 1024),
                      r = e.pixelSpaceConversion(this.center.lat, i, o);return .5 / Math.tan(.5 * this._fov) * this.height * r;
            }getWorldToCameraMatrix() {
                const t = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);return "globe" === this.projection.name && e.multiply(t, t, this.globeMatrix), t;
            }
        }function Jo(e, t) {
            let i = !1,
                o = null;const r = () => {
                o = null, i && (e(), o = setTimeout(r, t), i = !1);
            };return () => (i = !0, o || r(), o);
        }class Qo {
            constructor(t) {
                this._hashName = t && encodeURIComponent(t), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Jo(this._updateHashUnthrottled.bind(this), 300);
            }addTo(t) {
                return this._map = t, e.window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
            }remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }getHashString() {
                const t = this._map;if (!t) return "";const i = er(t);if (this._hashName) {
                    const t = this._hashName;let o = !1;const r = e.window.location.hash.slice(1).split("&").map(e => {
                        const r = e.split("=")[0];return r === t ? (o = !0, `${r}=${i}`) : e;
                    }).filter(e => e);return o || r.push(`${t}=${i}`), `#${r.join("&")}`;
                }return `#${i}`;
            }_getCurrentHash() {
                const t = e.window.location.hash.replace("#", "");if (this._hashName) {
                    let e;return t.split("&").map(e => e.split("=")).forEach(t => {
                        t[0] === this._hashName && (e = t);
                    }), (e && e[1] || "").split("/");
                }return t.split("/");
            }_onHashChange() {
                const e = this._map;if (!e) return !1;const t = this._getCurrentHash();if (t.length >= 3 && !t.some(e => isNaN(e))) {
                    const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();return e.jumpTo({ center: [+t[2], +t[1]], zoom: +t[0], bearing: i, pitch: +(t[4] || 0) }), !0;
                }return !1;
            }_updateHashUnthrottled() {
                const t = e.window.location.href.replace(/(#.+)?$/, this.getHashString());e.window.history.replaceState(e.window.history.state, null, t);
            }
        }function er(e, t) {
            const i = e.getCenter(),
                  o = Math.round(100 * e.getZoom()) / 100,
                  r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
                  n = Math.pow(10, r),
                  s = Math.round(i.lng * n) / n,
                  a = Math.round(i.lat * n) / n,
                  l = e.getBearing(),
                  c = e.getPitch();let h = t ? `/${s}/${a}/${o}` : `${o}/${a}/${s}`;return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
        }const tr = { linearity: .3, easing: e.bezier(0, 0, .3, 1) },
              ir = e.extend({ deceleration: 2500, maxSpeed: 1400 }, tr),
              or = e.extend({ deceleration: 20, maxSpeed: 1400 }, tr),
              rr = e.extend({ deceleration: 1e3, maxSpeed: 360 }, tr),
              nr = e.extend({ deceleration: 1e3, maxSpeed: 90 }, tr);class sr {
            constructor(e) {
                this._map = e, this.clear();
            }clear() {
                this._inertiaBuffer = [];
            }record(t) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t });
            }_drainInertiaBuffer() {
                const t = this._inertiaBuffer,
                      i = e.exported.now();for (; t.length > 0 && i - t[0].time > 160;) t.shift();
            }_onMoveEnd(t) {
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;const i = { zoom: 0, bearing: 0, pitch: 0, pan: new e.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };for (const { settings: e } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
                      r = {};if (i.pan.mag()) {
                    const n = lr(i.pan.mag(), o, e.extend({}, ir, t || {}));r.offset = i.pan.mult(n.amount / i.pan.mag()), r.center = this._map.transform.center, ar(r, n);
                }if (i.zoom) {
                    const e = lr(i.zoom, o, or);r.zoom = this._map.transform.zoom + e.amount, ar(r, e);
                }if (i.bearing) {
                    const t = lr(i.bearing, o, rr);r.bearing = this._map.transform.bearing + e.clamp(t.amount, -179, 179), ar(r, t);
                }if (i.pitch) {
                    const e = lr(i.pitch, o, nr);r.pitch = this._map.transform.pitch + e.amount, ar(r, e);
                }if (r.zoom || r.bearing) {
                    const e = void 0 === i.pinchAround ? i.around : i.pinchAround;r.around = e ? this._map.unproject(e) : this._map.getCenter();
                }return this.clear(), r.noMoveStart = !0, r;
            }
        }function ar(e, t) {
            (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);
        }function lr(t, i, o) {
            const { maxSpeed: r, linearity: n, deceleration: s } = o,
                  a = e.clamp(t * n / (i / 1e3), -r, r),
                  l = Math.abs(a) / (s * n);return { easing: o.easing, duration: 1e3 * l, amount: a * (l / 2) };
        }class cr extends e.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }get defaultPrevented() {
                return this._defaultPrevented;
            }constructor(t, i, o, r = {}) {
                const n = p(i.getCanvasContainer(), o),
                      s = i.unproject(n);super(t, e.extend({ point: n, lngLat: s, originalEvent: o }, r)), this._defaultPrevented = !1, this.target = i;
            }
        }class hr extends e.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }get defaultPrevented() {
                return this._defaultPrevented;
            }constructor(t, i, o) {
                const r = "touchend" === t ? o.changedTouches : o.touches,
                      n = m(i.getCanvasContainer(), r),
                      s = n.map(e => i.unproject(e)),
                      a = n.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.pointGeometry(0, 0));super(t, { points: n, point: a, lngLats: s, lngLat: i.unproject(a), originalEvent: o }), this._defaultPrevented = !1;
            }
        }class ur extends e.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }get defaultPrevented() {
                return this._defaultPrevented;
            }constructor(e, t, i) {
                super(e, { originalEvent: i }), this._defaultPrevented = !1;
            }
        }class _r {
            constructor(e, t) {
                this._map = e, this._clickTolerance = t.clickTolerance;
            }reset() {
                this._mousedownPos = void 0;
            }wheel(e) {
                return this._firePreventable(new ur(e.type, this._map, e));
            }mousedown(e, t) {
                return this._mousedownPos = t, this._firePreventable(new cr(e.type, this._map, e));
            }mouseup(e) {
                this._map.fire(new cr(e.type, this._map, e));
            }preclick(t) {
                const i = e.extend({}, t);i.type = "preclick", this._map.fire(new cr(i.type, this._map, i));
            }click(e, t) {
                this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new cr(e.type, this._map, e)));
            }dblclick(e) {
                return this._firePreventable(new cr(e.type, this._map, e));
            }mouseover(e) {
                this._map.fire(new cr(e.type, this._map, e));
            }mouseout(e) {
                this._map.fire(new cr(e.type, this._map, e));
            }touchstart(e) {
                return this._firePreventable(new hr(e.type, this._map, e));
            }touchmove(e) {
                this._map.fire(new hr(e.type, this._map, e));
            }touchend(e) {
                this._map.fire(new hr(e.type, this._map, e));
            }touchcancel(e) {
                this._map.fire(new hr(e.type, this._map, e));
            }_firePreventable(e) {
                if (this._map.fire(e), e.defaultPrevented) return {};
            }isEnabled() {
                return !0;
            }isActive() {
                return !1;
            }enable() {}disable() {}
        }class dr {
            constructor(e) {
                this._map = e;
            }reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }mousemove(e) {
                this._map.fire(new cr(e.type, this._map, e));
            }mousedown() {
                this._delayContextMenu = !0;
            }mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new cr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }contextmenu(e) {
                this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new cr(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
            }isEnabled() {
                return !0;
            }isActive() {
                return !1;
            }enable() {}disable() {}
        }class pr {
            constructor(e, t) {
                this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;
            }isEnabled() {
                return !!this._enabled;
            }isActive() {
                return !!this._active;
            }enable() {
                this.isEnabled() || (this._enabled = !0);
            }disable() {
                this.isEnabled() && (this._enabled = !1);
            }mousedown(e, t) {
                this.isEnabled() && e.shiftKey && 0 === e.button && (h(), this._startPos = this._lastPos = t, this._active = !0);
            }mousemoveWindow(e, t) {
                if (!this._active) return;const i = t,
                      o = this._startPos,
                      r = this._lastPos;if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;this._lastPos = i, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));const s = Math.min(o.x, i.x),
                      a = Math.max(o.x, i.x),
                      l = Math.min(o.y, i.y),
                      c = Math.max(o.y, i.y);this._map._requestDomTask(() => {
                    this._box && (this._box.style.transform = `translate(${s}px,${l}px)`, this._box.style.width = a - s + "px", this._box.style.height = c - l + "px");
                });
            }mouseupWindow(t, i) {
                if (!this._active) return;const o = this._startPos,
                      r = i;if (o && 0 === t.button) {
                    if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.Event("boxzoomend", { originalEvent: t })), { cameraAnimation: e => e.fitScreenCoordinates(o, r, this._map.getBearing(), { linear: !1 }) };this._fireEvent("boxzoomcancel", t);
                }
            }keydown(e) {
                this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
            }blur() {
                this.reset();
            }reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;
            }_fireEvent(t, i) {
                return this._map.fire(new e.Event(t, { originalEvent: i }));
            }
        }function mr(e, t) {
            const i = {};for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];return i;
        }class fr {
            constructor(e) {
                this.reset(), this.numTouches = e.numTouches;
            }reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
            }touchstart(t, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {
                    const i = new e.pointGeometry(0, 0);for (const e of t) i._add(e);return i.div(t.length);
                }(i), this.touches = mr(o, i)));
            }touchmove(e, t, i) {
                if (this.aborted || !this.centroid) return;const o = mr(i, t);for (const e in this.touches) {
                    const t = this.touches[e],
                          i = o[e];(!i || i.dist(t) > 30) && (this.aborted = !0);
                }
            }touchend(e, t, i) {
                if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e = !this.aborted && this.centroid;if (this.reset(), e) return e;
                }
            }
        }class gr {
            constructor(e) {
                this.singleTap = new fr(e), this.numTaps = e.numTaps, this.reset();
            }reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }touchstart(e, t, i) {
                this.singleTap.touchstart(e, t, i);
            }touchmove(e, t, i) {
                this.singleTap.touchmove(e, t, i);
            }touchend(e, t, i) {
                const o = this.singleTap.touchend(e, t, i);if (o) {
                    const t = e.timeStamp - this.lastTime < 500,
                          i = !this.lastTap || this.lastTap.dist(o) < 30;if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }class vr {
            constructor() {
                this._zoomIn = new gr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new gr({ numTouches: 2, numTaps: 1 }), this.reset();
            }reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }touchstart(e, t, i) {
                this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);
            }touchmove(e, t, i) {
                this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);
            }touchend(e, t, i) {
                const o = this._zoomIn.touchend(e, t, i),
                      r = this._zoomOut.touchend(e, t, i);return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: t => t.easeTo({ duration: 300, zoom: t.getZoom() + 1, around: t.unproject(o) }, { originalEvent: e }) }) : r ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: t => t.easeTo({ duration: 300, zoom: t.getZoom() - 1, around: t.unproject(r) }, { originalEvent: e }) }) : void 0;
            }touchcancel() {
                this.reset();
            }enable() {
                this._enabled = !0;
            }disable() {
                this._enabled = !1, this.reset();
            }isEnabled() {
                return this._enabled;
            }isActive() {
                return this._active;
            }
        }const xr = { 0: 1, 2: 2 };class yr {
            constructor(e) {
                this.reset(), this._clickTolerance = e.clickTolerance || 1;
            }blur() {
                this.reset();
            }reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }_correctButton(e, t) {
                return !1;
            }_move(e, t) {
                return {};
            }mousedown(e, t) {
                if (this._lastPoint) return;const i = f(e);this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);
            }mousemoveWindow(e, t) {
                const i = this._lastPoint;if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {
                    const i = xr[t];return void 0 === e.buttons || (e.buttons & i) !== i;
                }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);
            }mouseupWindow(e) {
                this._lastPoint && f(e) === this._eventButton && (this._moved && d(), this.reset());
            }enable() {
                this._enabled = !0;
            }disable() {
                this._enabled = !1, this.reset();
            }isEnabled() {
                return this._enabled;
            }isActive() {
                return this._active;
            }
        }class br extends yr {
            mousedown(e, t) {
                super.mousedown(e, t), this._lastPoint && (this._active = !0);
            }_correctButton(e, t) {
                return 0 === t && !e.ctrlKey;
            }_move(e, t) {
                return { around: t, panDelta: t.sub(e) };
            }
        }class wr extends yr {
            _correctButton(e, t) {
                return 0 === t && e.ctrlKey || 2 === t;
            }_move(e, t) {
                const i = .8 * (t.x - e.x);if (i) return this._active = !0, { bearingDelta: i };
            }contextmenu(e) {
                e.preventDefault();
            }
        }class Tr extends yr {
            _correctButton(e, t) {
                return 0 === t && e.ctrlKey || 2 === t;
            }_move(e, t) {
                const i = -.5 * (t.y - e.y);if (i) return this._active = !0, { pitchDelta: i };
            }contextmenu(e) {
                e.preventDefault();
            }
        }class Er {
            constructor(t, i) {
                this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
            }reset() {
                this._active = !1, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
            }touchstart(e, t, i) {
                return this._calculateTransform(e, t, i);
            }touchmove(t, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e.isFullscreen()) return void this._showTouchPanBlockerAlert();"hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, o);
                }
            }touchend(e, t, i) {
                this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();
            }touchcancel() {
                this.reset();
            }_calculateTransform(t, i, o) {
                o.length > 0 && (this._active = !0);const r = mr(o, i),
                      n = new e.pointGeometry(0, 0),
                      s = new e.pointGeometry(0, 0);let a = 0;for (const e in r) {
                    const t = r[e],
                          i = this._touches[e];i && (n._add(t), s._add(t.sub(i)), a++, r[e] = t);
                }if (this._touches = r, a < this._minTouches || !s.mag()) return;const l = s.div(a);return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : { around: n.div(a), panDelta: l };
            }enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }isEnabled() {
                return !!this._enabled;
            }isActive() {
                return !!this._active;
            }_addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }_showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 500);
            }
        }class Cr {
            constructor() {
                this.reset();
            }reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }_start(e) {}_move(e, t, i) {
                return {};
            }touchstart(e, t, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));
            }touchmove(e, t, i) {
                const o = this._firstTwoTouches;if (!o) return;e.preventDefault();const [r, n] = o,
                      s = Mr(i, t, r),
                      a = Mr(i, t, n);if (!s || !a) return;const l = this._aroundCenter ? null : s.add(a).div(2);return this._move([s, a], l, e);
            }touchend(e, t, i) {
                if (!this._firstTwoTouches) return;const [o, r] = this._firstTwoTouches,
                      n = Mr(i, t, o),
                      s = Mr(i, t, r);n && s || (this._active && d(), this.reset());
            }touchcancel() {
                this.reset();
            }enable(e) {
                this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
            }disable() {
                this._enabled = !1, this.reset();
            }isEnabled() {
                return this._enabled;
            }isActive() {
                return this._active;
            }
        }function Mr(e, t, i) {
            for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];
        }function Ir(e, t) {
            return Math.log(e / t) / Math.LN2;
        }class Sr extends Cr {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }_start(e) {
                this._startDistance = this._distance = e[0].dist(e[1]);
            }_move(e, t) {
                const i = this._distance;if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Ir(this._distance, this._startDistance)) < .1)) return this._active = !0, { zoomDelta: Ir(this._distance, i), pinchAround: t };
            }
        }function Dr(e, t) {
            return 180 * e.angleWith(t) / Math.PI;
        }class Lr extends Cr {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }_start(e) {
                this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
            }_move(e, t) {
                const i = this._vector;if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, { bearingDelta: Dr(this._vector, i), pinchAround: t };
            }_isBelowThreshold(e) {
                this._minDiameter = Math.min(this._minDiameter, e.mag());const t = 25 / (Math.PI * this._minDiameter) * 360,
                      i = this._startVector;if (!i) return !1;const o = Dr(e, i);return Math.abs(o) < t;
            }
        }function Ar(e) {
            return Math.abs(e.y) > Math.abs(e.x);
        }class zr extends Cr {
            constructor(e) {
                super(), this._map = e;
            }reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }_start(e) {
                this._lastPoints = e, Ar(e[0].sub(e[1])) && (this._valid = !1);
            }_move(t, i, o) {
                const r = this._lastPoints;if (!r) return;const n = t[0].sub(r[0]),
                      s = t[1].sub(r[1]);return this._map._cooperativeGestures && !e.isFullscreen() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n, s, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, { pitchDelta: (n.y + s.y) / 2 * -.5 });
            }gestureBeginsVertically(e, t, i) {
                if (void 0 !== this._valid) return this._valid;const o = e.mag() >= 2,
                      r = t.mag() >= 2;if (!o && !r) return;if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;const n = e.y > 0 == t.y > 0;return Ar(e) && Ar(t) && n;
            }
        }const Pr = { panStep: 100, bearingStep: 15, pitchStep: 10 };class Rr {
            constructor() {
                const e = Pr;this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
            }blur() {
                this.reset();
            }reset() {
                this._active = !1;
            }keydown(e) {
                if (e.altKey || e.ctrlKey || e.metaKey) return;let t = 0,
                    i = 0,
                    o = 0,
                    r = 0,
                    n = 0;switch (e.keyCode) {case 61:case 107:case 171:case 187:
                        t = 1;break;case 189:case 109:case 173:
                        t = -1;break;case 37:
                        e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);break;case 39:
                        e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);break;case 38:
                        e.shiftKey ? o = 1 : (e.preventDefault(), n = -1);break;case 40:
                        e.shiftKey ? o = -1 : (e.preventDefault(), n = 1);break;default:
                        return;}return this._rotationDisabled && (i = 0, o = 0), { cameraAnimation: s => {
                        const a = s.getZoom();s.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Or, zoom: t ? Math.round(a) + t * (e.shiftKey ? 2 : 1) : a, bearing: s.getBearing() + i * this._bearingStep, pitch: s.getPitch() + o * this._pitchStep, offset: [-r * this._panStep, -n * this._panStep], center: s.getCenter() }, { originalEvent: e });
                    } };
            }enable() {
                this._enabled = !0;
            }disable() {
                this._enabled = !1, this.reset();
            }isEnabled() {
                return this._enabled;
            }isActive() {
                return this._active;
            }disableRotation() {
                this._rotationDisabled = !0;
            }enableRotation() {
                this._rotationDisabled = !1;
            }
        }function Or(e) {
            return e * (2 - e);
        }const Br = 4.000244140625;class kr {
            constructor(t, i) {
                this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
            }setZoomRate(e) {
                this._defaultZoomRate = e;
            }setWheelZoomRate(e) {
                this._wheelZoomRate = e;
            }isEnabled() {
                return !!this._enabled;
            }isActive() {
                return this._active || void 0 !== this._finishTimeout;
            }isZooming() {
                return !!this._zooming;
            }enable(e) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }wheel(t) {
                if (!this.isEnabled()) return;if (this._map._cooperativeGestures) {
                    if (!(t.ctrlKey || t.metaKey || this.isZooming() || e.isFullscreen())) return void this._showBlockerAlert();"hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }let i = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;const o = e.exported.now(),
                      r = o - (this._lastWheelEventTime || 0);this._lastWheelEventTime = o, 0 !== i && i % Br == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();
            }_onTimeout(e) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
            }_start(e) {
                if (!this._delta) return;this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);const t = p(this._el, e);this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }renderFrame() {
                if (!this._frameId) return;if (this._frameId = null, !this.isActive()) return;const t = this._map.transform;"wheel" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);const i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;if (0 !== this._delta) {
                    const e = "wheel" === this._type && Math.abs(this._delta) > Br ? this._wheelZoomRate : this._defaultZoomRate;let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));this._delta < 0 && 0 !== o && (o = 1 / o);const r = i(),
                          n = Math.pow(2, r),
                          s = "number" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : n;this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(s * o))), "wheel" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._delta = 0;
                }const o = "number" == typeof this._targetZoom ? this._targetZoom : i(),
                      r = this._startZoom,
                      n = this._easing;let s,
                    a = !1;if ("wheel" === this._type && r && n) {
                    const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1),
                          i = n(t);s = e.number(r, o, i), t < 1 ? this._frameId || (this._frameId = !0) : a = !0;
                } else s = o, a = !0;return this._active = !0, a && (this._active = !1, this._finishTimeout = setTimeout(() => {
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200)), { noInertia: !0, needsRenderFrame: !a, zoomDelta: s - i(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
            }_smoothOutEasing(t) {
                let i = e.ease;if (this._prevEase) {
                    const t = this._prevEase,
                          o = (e.exported.now() - t.start) / t.duration,
                          r = t.easing(o + .01) - t.easing(o),
                          n = .27 / Math.sqrt(r * r + 1e-4) * .01,
                          s = Math.sqrt(.0729 - n * n);i = e.bezier(n, s, .25, 1);
                }return this._prevEase = { start: e.exported.now(), duration: t, easing: i }, i;
            }blur() {
                this.reset();
            }reset() {
                this._active = !1;
            }_addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }_showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 200);
            }
        }class Fr {
            constructor(e, t) {
                this._clickZoom = e, this._tapZoom = t;
            }enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }class Ur {
            constructor() {
                this.reset();
            }reset() {
                this._active = !1;
            }blur() {
                this.reset();
            }dblclick(e, t) {
                return e.preventDefault(), { cameraAnimation: i => {
                        i.easeTo({ duration: 300, zoom: i.getZoom() + (e.shiftKey ? -1 : 1), around: i.unproject(t) }, { originalEvent: e });
                    } };
            }enable() {
                this._enabled = !0;
            }disable() {
                this._enabled = !1, this.reset();
            }isEnabled() {
                return this._enabled;
            }isActive() {
                return this._active;
            }
        }class Nr {
            constructor() {
                this._tap = new gr({ numTouches: 1, numTaps: 1 }), this.reset();
            }reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }touchstart(e, t, i) {
                this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));
            }touchmove(e, t, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;const o = t[0],
                              r = o.y - this._swipePoint.y;return this._swipePoint = o, e.preventDefault(), this._active = !0, { zoomDelta: r / 128 };
                    }
                } else this._tap.touchmove(e, t, i);
            }touchend(e, t, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);
            }touchcancel() {
                this.reset();
            }enable() {
                this._enabled = !0;
            }disable() {
                this._enabled = !1, this.reset();
            }isEnabled() {
                return this._enabled;
            }isActive() {
                return this._active;
            }
        }class Gr {
            constructor(e, t, i) {
                this._el = e, this._mousePan = t, this._touchPan = i;
            }enable(e) {
                this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }class jr {
            constructor(e, t, i) {
                this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;
            }enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }class Zr {
            constructor(e, t, i, o) {
                this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }enable(e) {
                this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }const Vr = e => e.zoom || e.drag || e.pitch || e.rotate;class Wr extends e.Event {}class Xr {
            constructor() {
                this.constants = [1, 1, .01], this.radius = 0;
            }setup(t, i) {
                const o = e.sub([], i, t);this.radius = e.length(o[2] < 0 ? e.div([], o, this.constants) : [o[0], o[1], 0]);
            }projectRay(t) {
                e.div(t, t, this.constants), e.normalize(t, t), e.mul$1(t, t, this.constants);const i = e.scale$2([], t, this.radius);if (i[2] > 0) {
                    const t = e.scale$2([], [0, 0, 1], e.dot(i, [0, 0, 1])),
                          o = e.scale$2([], e.normalize([], [i[0], i[1], 0]), this.radius),
                          r = e.add([], i, e.scale$2([], e.sub([], e.add([], o, t), i), 2));i[0] = r[0], i[1] = r[1];
                }return i;
            }
        }function qr(e) {
            return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
        }class $r {
            constructor(t, i) {
                this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new sr(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Xr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.bindAll(["handleEvent", "handleWindowEvent"], this);const o = this._el;this._listeners = [[o, "touchstart", { passive: !0 }], [o, "touchmove", { passive: !1 }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [e.window.document, "mousemove", { capture: !0 }], [e.window.document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", { capture: !1 }], [o, "keyup", void 0], [o, "wheel", { passive: !1 }], [o, "contextmenu", void 0], [e.window, "blur", void 0]];for (const [t, i, o] of this._listeners) t.addEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);
            }destroy() {
                for (const [t, i, o] of this._listeners) t.removeEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);
            }_addDefaultHandlers(e) {
                const t = this._map,
                      i = t.getCanvasContainer();this._add("mapEvent", new _r(t, e));const o = t.boxZoom = new pr(t, e);this._add("boxZoom", o);const r = new vr(),
                      n = new Ur();t.doubleClickZoom = new Fr(n, r), this._add("tapZoom", r), this._add("clickZoom", n);const s = new Nr();this._add("tapDragZoom", s);const a = t.touchPitch = new zr(t);this._add("touchPitch", a);const l = new wr(e),
                      c = new Tr(e);t.dragRotate = new jr(e, l, c), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", c, ["mouseRotate"]);const h = new br(e),
                      u = new Er(t, e);t.dragPan = new Gr(i, h, u), this._add("mousePan", h), this._add("touchPan", u, ["touchZoom", "touchRotate"]);const _ = new Lr(),
                      d = new Sr();t.touchZoomRotate = new Zr(i, d, _, s), this._add("touchRotate", _, ["touchPan", "touchZoom"]), this._add("touchZoom", d, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new dr(t));const p = t.scrollZoom = new kr(t, this);this._add("scrollZoom", p, ["mousePan"]);const m = t.keyboard = new Rr();this._add("keyboard", m);for (const i of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e.interactive && e[i] && t[i].enable(e[i]);
            }_add(e, t, i) {
                this._handlers.push({ handlerName: e, handler: t, allowed: i }), this._handlersById[e] = t;
            }stop(e) {
                if (!this._updatingCamera) {
                    for (const { handler: e } of this._handlers) e.reset();this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
                }
            }isActive() {
                for (const { handler: e } of this._handlers) if (e.isActive()) return !0;return !1;
            }isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }isRotating() {
                return !!this._eventsInProgress.rotate;
            }isMoving() {
                return !!Vr(this._eventsInProgress) || this.isZooming();
            }_isDragging() {
                return !!this._eventsInProgress.drag;
            }_blockedByActive(e, t, i) {
                for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;return !1;
            }handleWindowEvent(e) {
                this.handleEvent(e, `${e.type}Window`);
            }_getMapTouches(e) {
                const t = [];for (const i of e) this._el.contains(i.target) && t.push(i);return t;
            }handleEvent(e, t) {
                this._updatingCamera = !0;const i = "renderFrame" === e.type,
                      o = i ? void 0 : e,
                      r = { needsRenderFrame: !1 },
                      n = {},
                      s = {},
                      a = e.touches ? this._getMapTouches(e.touches) : void 0,
                      l = a ? m(this._el, a) : i ? void 0 : p(this._el, e);for (const { handlerName: i, handler: c, allowed: h } of this._handlers) {
                    if (!c.isEnabled()) continue;let u;this._blockedByActive(s, h, i) ? c.reset() : c[t || e.type] && (u = c[t || e.type](e, l, a), this.mergeHandlerResult(r, n, u, i, o), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || c.isActive()) && (s[i] = c);
                }const c = {};for (const e in this._previousActiveHandlers) s[e] || (c[e] = o);this._previousActiveHandlers = s, (Object.keys(c).length || qr(r)) && (this._changes.push([r, n, c]), this._triggerRenderFrame()), (Object.keys(s).length || qr(r)) && this._map._stop(!0), this._updatingCamera = !1;const { cameraAnimation: h } = r;h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
            }mergeHandlerResult(t, i, o, r, n) {
                if (!o) return;e.extend(t, o);const s = { handlerName: r, originalEvent: o.originalEvent || n };void 0 !== o.zoomDelta && (i.zoom = s), void 0 !== o.panDelta && (i.drag = s), void 0 !== o.pitchDelta && (i.pitch = s), void 0 !== o.bearingDelta && (i.rotate = s);
            }_applyChanges() {
                const t = {},
                      i = {},
                      o = {};for (const [r, n, s] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new e.pointGeometry(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t.around = r.around), void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), e.extend(i, n), e.extend(o, s);this._updateMapTransform(t, i, o), this._changes = [];
            }_updateMapTransform(t, i, o) {
                const r = this._map,
                      n = r.transform,
                      s = e => [e.x, e.y, e.z];if ((e => {
                    const t = this._eventsInProgress.drag;return t && !this._handlersById[t.handlerName].isActive();
                })() && !qr(t)) {
                    const e = n.zoom;n.cameraElevationReference = "sea", n.recenterOnTerrain(), n.cameraElevationReference = "ground", e !== n.zoom && this._map._update(!0);
                }if (n._isCameraConstrained && r._stop(!0), !qr(t)) return void this._fireEvents(i, o, !0);let { panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: u, aroundCoord: _, pinchAround: d } = t;n._isCameraConstrained && (l > 0 && (l = 0), n._isCameraConstrained = !1), void 0 !== d && (u = d), (l || (e => i.drag && !this._eventsInProgress.drag)()) && u && (this._dragOrigin = s(n.pointCoordinate3D(u)), this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)), n.cameraElevationReference = "sea", r._stop(!0), u = u || r.transform.centerPoint, c && (n.bearing += c), h && (n.pitch += h), n._updateCameraState();const p = [0, 0, 0];if (a) if ("mercator" === n.projection.name) {
                    const e = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u).dir),
                          t = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u.sub(a)).dir);p[0] = t[0] - e[0], p[1] = t[1] - e[1];
                } else {
                    const t = n.pointCoordinate(u);if ("globe" === n.projection.name) {
                        a = a.rotate(-n.angle);const i = n._pixelsPerMercatorPixel / n.worldSize;p[0] = -a.x * e.mercatorScale(e.latFromMercatorY(t.y)) * i, p[1] = -a.y * e.mercatorScale(n.center.lat) * i;
                    } else {
                        const e = n.pointCoordinate(u.sub(a));t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);
                    }
                }const m = n.zoom,
                      f = [0, 0, 0];if (l) {
                    const t = s(_ || n.pointCoordinate3D(u)),
                          i = { dir: e.normalize([], e.sub([], t, n._camera.position)) };if (i.dir[2] < 0) {
                        const o = n.zoomDeltaToMovement(t, l);e.scale$2(f, i.dir, o);
                    }
                }const g = e.add(p, p, f);n._translateCameraConstrained(g), l && Math.abs(n.zoom - m) > 1e-4 && n.recenterOnTerrain(), n.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);
            }_fireEvents(t, i, o) {
                const r = Vr(this._eventsInProgress),
                      n = Vr(t),
                      s = {};for (const e in t) {
                    const { originalEvent: i } = t[e];this._eventsInProgress[e] || (s[`${e}start`] = i), this._eventsInProgress[e] = t[e];
                }!r && n && this._fireEvent("movestart", n.originalEvent);for (const e in s) this._fireEvent(e, s[e]);n && this._fireEvent("move", n.originalEvent);for (const e in t) {
                    const { originalEvent: i } = t[e];this._fireEvent(e, i);
                }const a = {};let l;for (const e in this._eventsInProgress) {
                    const { handlerName: t, originalEvent: o } = this._eventsInProgress[e];this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, a[`${e}end`] = l);
                }for (const e in a) this._fireEvent(e, a[e]);const c = Vr(this._eventsInProgress);if (o && (r || n) && !c) {
                    this._updatingCamera = !0;const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                          i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, { originalEvent: l })) : (this._map.fire(new e.Event("moveend", { originalEvent: l })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }_fireEvent(t, i) {
                this._map.fire(new e.Event(t, i ? { originalEvent: i } : {}));
            }_requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {
                    this._frameId = void 0, this.handleEvent(new Wr("renderFrame", { timeStamp: e })), this._applyChanges();
                });
            }_triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }const Hr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";class Yr extends e.Evented {
            constructor(t, i) {
                super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
            }getCenter() {
                return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
            }setCenter(e, t) {
                return this.jumpTo({ center: e }, t);
            }panBy(t, i, o) {
                return t = e.pointGeometry.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t }, i), o);
            }panTo(t, i, o) {
                return this.easeTo(e.extend({ center: t }, i), o);
            }getZoom() {
                return this.transform.zoom;
            }setZoom(e, t) {
                return this.jumpTo({ zoom: e }, t), this;
            }zoomTo(t, i, o) {
                return this.easeTo(e.extend({ zoom: t }, i), o);
            }zoomIn(e, t) {
                return this.zoomTo(this.getZoom() + 1, e, t), this;
            }zoomOut(e, t) {
                return this.zoomTo(this.getZoom() - 1, e, t), this;
            }getBearing() {
                return this.transform.bearing;
            }setBearing(e, t) {
                return this.jumpTo({ bearing: e }, t), this;
            }getPadding() {
                return this.transform.padding;
            }setPadding(e, t) {
                return this.jumpTo({ padding: e }, t), this;
            }rotateTo(t, i, o) {
                return this.easeTo(e.extend({ bearing: t }, i), o);
            }resetNorth(t, i) {
                return this.rotateTo(0, e.extend({ duration: 1e3 }, t), i), this;
            }resetNorthPitch(t, i) {
                return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t), i), this;
            }snapToNorth(e, t) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;
            }getPitch() {
                return this.transform.pitch;
            }setPitch(e, t) {
                return this.jumpTo({ pitch: e }, t), this;
            }cameraForBounds(t, i) {
                t = e.LngLatBounds.convert(t);const o = i && i.bearing || 0,
                      r = i && i.pitch || 0,
                      n = t.getNorthWest(),
                      s = t.getSouthEast();return this._cameraForBounds(this.transform, n, s, o, r, i);
            }_extendCameraOptions(t) {
                const i = { top: 0, bottom: 0, right: 0, left: 0 };if ("number" == typeof (t = e.extend({ padding: i, offset: [0, 0], maxZoom: this.transform.maxZoom }, t)).padding) {
                    const e = t.padding;t.padding = { top: e, bottom: e, right: e, left: e };
                }return t.padding = e.extend(i, t.padding), t;
            }_minimumAABBFrustumDistance(e, t) {
                const i = t.max[0] - t.min[0],
                      o = t.max[1] - t.min[1];return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);
            }_cameraForBoundsOnGlobe(t, i, o, r, n, s) {
                const a = t.clone(),
                      l = this._extendCameraOptions(s);a.bearing = r, a.pitch = n;const c = e.LngLat.convert(i),
                      h = e.LngLat.convert(o),
                      u = .5 * (c.lat + h.lat),
                      _ = .5 * (c.lng + h.lng),
                      d = e.latLngToECEF(u, _),
                      p = e.normalize([], d),
                      m = e.normalize([], e.cross([], p, [0, 1, 0])),
                      f = e.cross([], m, p),
                      g = [m[0], m[1], m[2], 0, f[0], f[1], f[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1],
                      v = [d, e.latLngToECEF(c.lat, c.lng), e.latLngToECEF(h.lat, c.lng), e.latLngToECEF(h.lat, h.lng), e.latLngToECEF(c.lat, h.lng), e.latLngToECEF(u, c.lng), e.latLngToECEF(u, h.lng), e.latLngToECEF(c.lat, _), e.latLngToECEF(h.lat, _)];let x = e.Aabb.fromPoints(v.map(t => [e.dot(m, t), e.dot(f, t), e.dot(p, t)]));const y = e.transformMat4([], x.center, g);0 === e.squaredLength(y) && e.set(y, 0, 0, 1), e.normalize(y, y), e.scale$2(y, y, e.GLOBE_RADIUS), a.center = e.ecefToLatLng(y);const b = a.getWorldToCameraMatrix(),
                      w = e.invert(new Float64Array(16), b);x = e.Aabb.applyTransform(x, e.multiply([], b, g)), e.transformMat4(y, y, b);const T = .5 * (x.max[2] - x.min[2]),
                      E = this._minimumAABBFrustumDistance(a, x),
                      C = e.scale$2([], [0, 0, 1], T),
                      M = e.add(C, y, C),
                      I = E + (0 === a.pitch ? 0 : e.distance(y, M)),
                      S = a.globeCenterInViewSpace,
                      D = e.sub([], y, [S[0], S[1], S[2]]);e.normalize(D, D), e.scale$2(D, D, I);const L = e.add([], y, D);e.transformMat4(L, L, w);const A = e.earthRadius / e.GLOBE_RADIUS,
                      z = e.length(L),
                      P = e.mercatorZfromAltitude(Math.max(z * A - e.earthRadius, Number.EPSILON), 0),
                      R = Math.min(a.zoomFromMercatorZAdjusted(P), l.maxZoom);return R > .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({ name: "mercator" }), a.zoom = R, this._cameraForBounds(a, i, o, r, n, s)) : { center: a.center, zoom: R, bearing: r, pitch: n };
            }queryTerrainElevation(t, i) {
                const o = this.transform.elevation;return o ? (i = e.extend({}, { exaggerated: !0 }, i), o.getAtPoint(e.MercatorCoordinate.fromLngLat(t), null, i.exaggerated)) : null;
            }_cameraForBounds(t, i, o, r, n, s) {
                if ("globe" === t.projection.name) return this._cameraForBoundsOnGlobe(t, i, o, r, n, s);const a = t.clone(),
                      l = this._extendCameraOptions(s),
                      c = a.padding;a.bearing = r, a.pitch = n;const h = e.LngLat.convert(i),
                      u = e.LngLat.convert(o),
                      _ = new e.LngLat(h.lng, u.lat),
                      d = new e.LngLat(u.lng, h.lat),
                      p = a.project(h),
                      m = a.project(u),
                      f = this.queryTerrainElevation(h),
                      g = this.queryTerrainElevation(u),
                      v = this.queryTerrainElevation(_),
                      x = this.queryTerrainElevation(d),
                      y = [[p.x, p.y, Math.min(f || 0, g || 0, v || 0, x || 0)], [m.x, m.y, Math.max(f || 0, g || 0, v || 0, x || 0)]];let b = e.Aabb.fromPoints(y);const w = a.getWorldToCameraMatrix(),
                      T = e.invert(new Float64Array(16), w);b = e.Aabb.applyTransform(b, w);const E = e.sub([], b.max, b.min),
                      C = c.left || 0,
                      M = c.right || 0,
                      I = c.bottom || 0,
                      S = c.top || 0,
                      { left: D, right: L, top: A, bottom: z } = l.padding,
                      P = .5 * (C + M),
                      R = .5 * (S + I),
                      O = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (C + M + D + L)) / E[0], (a.height - (I + S + z + A)) / E[1])), l.maxZoom),
                      B = a.scale / a.zoomScale(O);b = new e.Aabb([b.min[0] - (D + P) * B, b.min[1] - (z + R) * B, b.min[2]], [b.max[0] + (L + P) * B, b.max[1] + (A + R) * B, b.max[2]]);const k = .5 * E[2],
                      F = this._minimumAABBFrustumDistance(a, b),
                      U = [0, 0, 1, 0];e.transformMat4$1(U, U, w), e.normalize$2(U, U);const N = e.scale$2([], U, F + k),
                      G = e.add([], b.center, N),
                      j = ("number" == typeof l.offset.x && "number" == typeof l.offset.y ? new e.pointGeometry(l.offset.x, l.offset.y) : e.pointGeometry.convert(l.offset)).rotate(-e.degToRad(r));b.center[0] -= j.x * B, b.center[1] += j.y * B, e.transformMat4(b.center, b.center, T), e.transformMat4(G, G, T);const Z = [b.center[0], b.center[1], G[2] * a.pixelsPerMeter];e.scale$2(Z, Z, 1 / a.worldSize);const V = e.lngFromMercatorX(Z[0]),
                      W = e.latFromMercatorY(Z[1]),
                      X = Math.min(a._zoomFromMercatorZ(Z[2]), l.maxZoom),
                      q = new e.LngLat(V, W);return a.mercatorFromTransition && X < .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({ name: "globe" }), a.zoom = X, this._cameraForBounds(a, i, o, r, n, s)) : { center: q, zoom: X, bearing: r, pitch: n };
            }fitBounds(e, t, i) {
                const o = this.cameraForBounds(e, t);return this._fitInternal(o, t, i);
            }fitScreenCoordinates(t, i, o, r, n) {
                const s = e.pointGeometry.convert(t),
                      a = e.pointGeometry.convert(i),
                      l = new e.pointGeometry(Math.min(s.x, a.x), Math.min(s.y, a.y)),
                      c = new e.pointGeometry(Math.max(s.x, a.x), Math.max(s.y, a.y));if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a)) return this;const h = this.transform.pointLocation3D(l),
                      u = this.transform.pointLocation3D(c),
                      _ = this.transform.pointLocation3D(new e.pointGeometry(l.x, c.y)),
                      d = this.transform.pointLocation3D(new e.pointGeometry(c.x, l.y)),
                      p = [Math.min(h.lng, u.lng, _.lng, d.lng), Math.min(h.lat, u.lat, _.lat, d.lat)],
                      m = [Math.max(h.lng, u.lng, _.lng, d.lng), Math.max(h.lat, u.lat, _.lat, d.lat)],
                      f = r && r.pitch ? r.pitch : this.getPitch(),
                      g = this._cameraForBounds(this.transform, p, m, o, f, r);return this._fitInternal(g, r, n);
            }_fitInternal(t, i, o) {
                return t ? (delete (i = e.extend(t, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;
            }jumpTo(t, i) {
                this.stop();const o = t.preloadOnly ? this.transform.clone() : this.transform;let r = !1,
                    n = !1,
                    s = !1;return "zoom" in t && o.zoom !== +t.zoom && (r = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.LngLat.convert(t.center)), "bearing" in t && o.bearing !== +t.bearing && (n = !0, o.bearing = +t.bearing), "pitch" in t && o.pitch !== +t.pitch && (s = !0, o.pitch = +t.pitch), null == t.padding || o.isPaddingEqual(t.padding) || (o.padding = t.padding), t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.Event("movestart", i)).fire(new e.Event("move", i)), r && this.fire(new e.Event("zoomstart", i)).fire(new e.Event("zoom", i)).fire(new e.Event("zoomend", i)), n && this.fire(new e.Event("rotatestart", i)).fire(new e.Event("rotate", i)).fire(new e.Event("rotateend", i)), s && this.fire(new e.Event("pitchstart", i)).fire(new e.Event("pitch", i)).fire(new e.Event("pitchend", i)), this.fire(new e.Event("moveend", i)));
            }getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e.warnOnce(Hr), this.transform.getFreeCameraOptions();
            }setFreeCameraOptions(t, i) {
                const o = this.transform;if (!o.projection.supportsFreeCamera) return e.warnOnce(Hr), this;this.stop();const r = o.zoom,
                      n = o.pitch,
                      s = o.bearing;o.setFreeCameraOptions(t);const a = r !== o.zoom,
                      l = n !== o.pitch,
                      c = s !== o.bearing;return this.fire(new e.Event("movestart", i)).fire(new e.Event("move", i)), a && this.fire(new e.Event("zoomstart", i)).fire(new e.Event("zoom", i)).fire(new e.Event("zoomend", i)), c && this.fire(new e.Event("rotatestart", i)).fire(new e.Event("rotate", i)).fire(new e.Event("rotateend", i)), l && this.fire(new e.Event("pitchstart", i)).fire(new e.Event("pitch", i)).fire(new e.Event("pitchend", i)), this.fire(new e.Event("moveend", i)), this;
            }easeTo(t, i) {
                this._stop(!1, t.easeId), (!1 === (t = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t)).animate || !t.essential && e.exported.prefersReducedMotion) && (t.duration = 0);const o = this.transform,
                      r = this.getZoom(),
                      n = this.getBearing(),
                      s = this.getPitch(),
                      a = this.getPadding(),
                      l = "zoom" in t ? +t.zoom : r,
                      c = "bearing" in t ? this._normalizeBearing(t.bearing, n) : n,
                      h = "pitch" in t ? +t.pitch : s,
                      u = "padding" in t ? t.padding : o.padding,
                      _ = e.pointGeometry.convert(t.offset);let d, p, m;if ("globe" === o.projection.name) {
                    const i = e.MercatorCoordinate.fromLngLat(o.center),
                          r = _.rotate(-o.angle);i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;const n = i.toLngLat(),
                          s = e.LngLat.convert(t.center || n);this._normalizeCenter(s), d = o.centerPoint.add(r), p = new e.pointGeometry(i.x, i.y).mult(o.worldSize), m = new e.pointGeometry(e.mercatorXfromLng(s.lng), e.mercatorYfromLat(s.lat)).mult(o.worldSize).sub(p);
                } else {
                    d = o.centerPoint.add(_);const i = o.pointLocation(d),
                          r = e.LngLat.convert(t.center || i);this._normalizeCenter(r), p = o.project(i), m = o.project(r).sub(p);
                }const f = o.zoomScale(l - r);let g, v;t.around && (g = e.LngLat.convert(t.around), v = o.locationPoint(g));const x = this._zooming || l !== r,
                      y = this._rotating || n !== c,
                      b = this._pitching || h !== s,
                      w = !o.isPaddingEqual(u),
                      T = o => T => {
                    if (x && (o.zoom = e.number(r, l, T)), y && (o.bearing = e.number(n, c, T)), b && (o.pitch = e.number(s, h, T)), w && (o.interpolatePadding(a, u, T), d = o.centerPoint.add(_)), g) o.setLocationAtPoint(g, v);else {
                        const e = o.zoomScale(o.zoom - r),
                              t = l > r ? Math.min(2, f) : Math.max(.5, f),
                              i = Math.pow(t, 1 - T),
                              n = o.unproject(p.add(m.mult(T * i)).mult(e));o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, d);
                    }return t.preloadOnly || this._fireMoveEvents(i), o;
                };if (t.preloadOnly) {
                    const e = this._emulate(T, t.duration, o);return this._preloadTiles(e), this;
                }const E = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, E), this._ease(T(o), e => {
                    o.recenterOnTerrain(), this._afterEase(i, e);
                }, t), this;
            }_prepareEase(t, i, o = {}) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", i || o.moving || this.fire(new e.Event("movestart", t)), this._zooming && !o.zooming && this.fire(new e.Event("zoomstart", t)), this._rotating && !o.rotating && this.fire(new e.Event("rotatestart", t)), this._pitching && !o.pitching && this.fire(new e.Event("pitchstart", t));
            }_fireMoveEvents(t) {
                this.fire(new e.Event("move", t)), this._zooming && this.fire(new e.Event("zoom", t)), this._rotating && this.fire(new e.Event("rotate", t)), this._pitching && this.fire(new e.Event("pitch", t));
            }_afterEase(t, i) {
                if (this._easeId && i && this._easeId === i) return;this._easeId = void 0, this.transform.cameraElevationReference = "ground";const o = this._zooming,
                      r = this._rotating,
                      n = this._pitching;this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.Event("zoomend", t)), r && this.fire(new e.Event("rotateend", t)), n && this.fire(new e.Event("pitchend", t)), this.fire(new e.Event("moveend", t));
            }flyTo(t, i) {
                if (!t.essential && e.exported.prefersReducedMotion) {
                    const o = e.pick(t, ["center", "zoom", "bearing", "pitch", "around"]);return this.jumpTo(o, i);
                }this.stop(), t = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t);const o = this.transform,
                      r = this.getZoom(),
                      n = this.getBearing(),
                      s = this.getPitch(),
                      a = this.getPadding(),
                      l = "zoom" in t ? e.clamp(+t.zoom, o.minZoom, o.maxZoom) : r,
                      c = "bearing" in t ? this._normalizeBearing(t.bearing, n) : n,
                      h = "pitch" in t ? +t.pitch : s,
                      u = "padding" in t ? t.padding : o.padding,
                      _ = o.zoomScale(l - r),
                      d = e.pointGeometry.convert(t.offset);let p = o.centerPoint.add(d);const m = o.pointLocation(p),
                      f = e.LngLat.convert(t.center || m);this._normalizeCenter(f);const g = o.project(m),
                      v = o.project(f).sub(g);let x = t.curve;const y = Math.max(o.width, o.height),
                      b = y / _,
                      w = v.mag();if ("minZoom" in t) {
                    const i = e.clamp(Math.min(t.minZoom, r, l), o.minZoom, o.maxZoom),
                          n = y / o.zoomScale(i - r);x = Math.sqrt(n / w * 2);
                }const T = x * x;function E(e) {
                    const t = (b * b - y * y + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : y) * T * w);return Math.log(Math.sqrt(t * t + 1) - t);
                }function C(e) {
                    return (Math.exp(e) - Math.exp(-e)) / 2;
                }function M(e) {
                    return (Math.exp(e) + Math.exp(-e)) / 2;
                }const I = E(0);let S = function (e) {
                    return M(I) / M(I + x * e);
                },
                    D = function (e) {
                    return y * ((M(I) * (C(t = I + x * e) / M(t)) - C(I)) / T) / w;var t;
                },
                    L = (E(1) - I) / x;if (Math.abs(w) < 1e-6 || !isFinite(L)) {
                    if (Math.abs(y - b) < 1e-6) return this.easeTo(t, i);const e = b < y ? -1 : 1;L = Math.abs(Math.log(b / y)) / x, D = function () {
                        return 0;
                    }, S = function (t) {
                        return Math.exp(e * x * t);
                    };
                }t.duration = "duration" in t ? +t.duration : 1e3 * L / ("screenSpeed" in t ? +t.screenSpeed / x : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);const A = n !== c,
                      z = h !== s,
                      P = !o.isPaddingEqual(u),
                      R = o => _ => {
                    const m = _ * L,
                          x = 1 / S(m);o.zoom = 1 === _ ? l : r + o.scaleZoom(x), A && (o.bearing = e.number(n, c, _)), z && (o.pitch = e.number(s, h, _)), P && (o.interpolatePadding(a, u, _), p = o.centerPoint.add(d));const y = 1 === _ ? f : o.unproject(g.add(v.mult(D(m))).mult(x));return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;
                };if (t.preloadOnly) {
                    const e = this._emulate(R, t.duration, o);return this._preloadTiles(e), this;
                }return this._zooming = !0, this._rotating = A, this._pitching = z, this._padding = P, this._prepareEase(i, !1), this._ease(R(o), () => this._afterEase(i), t), this;
            }isEasing() {
                return !!this._easeFrameId;
            }stop() {
                return this._stop();
            }_stop(e, t) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e = this._onEaseEnd;this._onEaseEnd = void 0, e.call(this, t);
                }if (!e) {
                    const e = this.handlers;e && e.stop(!1);
                }return this;
            }_ease(t, i, o) {
                !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.exported.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }_renderFrameCallback() {
                const t = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1),
                      i = this._onEaseFrame;i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }_normalizeBearing(t, i) {
                t = e.wrap(t, -180, 180);const o = Math.abs(t - i);return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;
            }_normalizeCenter(e) {
                const t = this.transform;if (!t.renderWorldCopies || t.maxBounds) return;const i = e.lng - t.center.lng;e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }_emulate(e, t, i) {
                const o = Math.ceil(15 * t / 1e3),
                      r = [],
                      n = e(i.clone());for (let e = 0; e <= o; e++) {
                    const t = n(e / o);r.push(t.clone());
                }return r;
            }
        }class Kr {
            constructor(t = {}) {
                this.options = t, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
            }getDefaultPosition() {
                return "bottom-right";
            }onAdd(e) {
                const t = this.options && this.options.compact;return this._map = e, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }_setElementTitle(e, t) {
                const i = this._map._getUIString(`AttributionControl.${t}`);e.setAttribute("aria-label", i), e.removeAttribute("title"), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
            }_toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }_updateEditLink() {
                let t = this._editLink;t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));const i = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }];if (t) {
                    const o = i.reduce((e, t, o) => (t.value && (e += `${t.key}=${t.value}${o < i.length - 1 ? "&" : ""}`), e), "?");t.href = `${e.config.FEEDBACK_URL}/${o}#${er(this._map, !0)}`, t.rel = "noopener nofollow", this._setElementTitle(t, "MapFeedback");
                }
            }_updateData(e) {
                !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
            }_updateAttributions() {
                if (!this._map.style) return;let e = [];if (this._map.style.stylesheet) {
                    const e = this._map.style.stylesheet;this.styleOwner = e.owner, this.styleId = e.id;
                }const t = this._map.style._sourceCaches;for (const i in t) {
                    const o = t[i];if (o.used) {
                        const t = o.getSource();t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);
                    }
                }e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {
                    for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));const i = e.join(" | ");i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }_updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }class Jr {
            constructor() {
                e.bindAll(["_updateLogo", "_updateCompact"], this);
            }onAdd(e) {
                this._map = e, this._container = n("div", "mapboxgl-ctrl");const t = n("a", "mapboxgl-ctrl-logo");return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://www.mapbox.com/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }getDefaultPosition() {
                return "bottom-left";
            }_updateLogo(e) {
                e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }_logoRequired() {
                if (!this._map.style) return !0;const e = this._map.style._sourceCaches;if (0 === Object.entries(e).length) return !0;for (const t in e) {
                    const i = e[t].getSource();if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
                }return !0;
            }_updateCompact() {
                const e = this._container.children;if (e.length) {
                    const t = e[0];this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add("mapboxgl-compact") : t.classList.remove("mapboxgl-compact");
                }
            }
        }class Qr {
            constructor() {
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }add(e) {
                const t = ++this._id;return this._queue.push({ callback: e, id: t, cancelled: !1 }), t;
            }remove(e) {
                const t = this._currentlyRunning,
                      i = t ? this._queue.concat(t) : this._queue;for (const t of i) if (t.id === e) return void (t.cancelled = !0);
            }run(e = 0) {
                const t = this._currentlyRunning = this._queue;this._queue = [];for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;this._cleared = !1, this._currentlyRunning = !1;
            }clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }function en(t, i, o) {
            if (t = new e.LngLat(t.lng, t.lat), i) {
                const r = new e.LngLat(t.lng - 360, t.lat),
                      n = new e.LngLat(t.lng + 360, t.lat),
                      s = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),
                      a = o.locationPoint(t).distSqr(i),
                      l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;o.locationPoint(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < s) ? t = r : o.locationPoint(n).distSqr(i) < a && (l || Math.abs(n.lng - o.center.lng) < s) && (t = n);
            }for (; Math.abs(t.lng - o.center.lng) > 180;) {
                const e = o.locationPoint(t);if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;
            }return t;
        }const tn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };class on extends e.Evented {
            constructor(t, i) {
                if (super(), (t instanceof e.window.HTMLElement || i) && (t = e.extend({ element: t }, i)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || .2, t && t.element) this._element = t.element, this._offset = e.pointGeometry.convert(t && t.offset || [0, 0]);else {
                    this._defaultMarker = !0, this._element = n("div");const i = 41,
                          o = 27,
                          r = s("svg", { display: "block", height: i * this._scale + "px", width: o * this._scale + "px", viewBox: `0 0 ${o} ${i}` }, this._element),
                          a = s("radialGradient", { id: "shadowGradient" }, s("defs", {}, r));s("stop", { offset: "10%", "stop-opacity": .4 }, a), s("stop", { offset: "100%", "stop-opacity": .05 }, a), s("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r), s("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r), s("path", { opacity: .25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r), s("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r), this._offset = e.pointGeometry.convert(t && t.offset || [0, -14]);
                }this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", e => {
                    e.preventDefault();
                }), this._element.addEventListener("mousedown", e => {
                    e.preventDefault();
                });const o = this._element.classList;for (const e in tn) o.remove(`mapboxgl-marker-anchor-${e}`);o.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
            }addTo(e) {
                return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
            }remove() {
                const e = this._map;return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }getLngLat() {
                return this._lngLat;
            }setLngLat(t) {
                return this._lngLat = e.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }getElement() {
                return this._element;
            }setPopup(e) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                    if (!("offset" in e.options)) {
                        const t = 38.1,
                              i = 13.5,
                              o = Math.sqrt(Math.pow(i, 2) / 2);e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t], "bottom-left": [o, -1 * (t - i + o)], "bottom-right": [-o, -1 * (t - i + o)], left: [i, -1 * (t - i)], right: [-i, -1 * (t - i)] } : this._offset;
                    }this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }return this;
            }_onKeyPress(e) {
                const t = e.code,
                      i = e.charCode || e.keyCode;"Space" !== t && "Enter" !== t && 32 !== i && 13 !== i || this.togglePopup();
            }_onMapClick(e) {
                const t = e.originalEvent.target,
                      i = this._element;this._popup && (t === i || i.contains(t)) && this.togglePopup();
            }getPopup() {
                return this._popup;
            }togglePopup() {
                const e = this._popup;return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }_behindTerrain() {
                const e = this._map,
                      t = this._pos;if (!e || !t) return !1;const i = e.unproject(t),
                      o = e.getFreeCameraOptions();if (!o.position) return !1;const r = o.position.toLngLat();return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);
            }_evaluateOpacity() {
                const t = this._map;if (!t) return;const i = this._pos;if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height) return void this._clearFadeTimer();const o = t.unproject(i);let r;t._showingGlobe() && e.isLngLatBehindGlobe(t.transform, this._lngLat) ? r = 0 : (r = 1 - t._queryFogOpacity(o), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;
            }_clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }_updateDOM() {
                const e = this._pos;if (!e || !this._map) return;const t = this._offset.mult(this._scale);this._element.style.transform = `\n            translate(${e.x}px,${e.y}px)\n            ${tn[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t.x}px,${t.y}px)\n        `;
            }_calculateXYTransform() {
                const t = this._pos,
                      i = this._map,
                      o = this.getPitchAlignment();if (!i || !t || "map" !== o) return "";if (!i._showingGlobe()) {
                    const e = i.getPitch();return e ? `rotateX(${e}deg)` : "";
                }const r = e.radToDeg(e.globeTiltAtLngLat(i.transform, this._lngLat)),
                      n = t.sub(e.globeCenterToScreenPoint(i.transform)),
                      s = Math.abs(n.x) + Math.abs(n.y);if (0 === s) return "";const a = r / s;return `rotateX(${-n.y * a}deg) rotateY(${n.x * a}deg)`;
            }_calculateZTransform() {
                const t = this._pos,
                      i = this._map;if (!i || !t) return "";let o = 0;const r = this.getRotationAlignment();if ("map" === r) {
                    if (i._showingGlobe()) {
                        const t = i.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + .001)),
                              r = i.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - .001)).sub(t);o = e.radToDeg(Math.atan2(r.y, r.x)) - 90;
                    } else o = -i.getBearing();
                } else if ("horizon" === r) {
                    const r = e.smoothstep(4, 6, i.getZoom()),
                          n = e.globeCenterToScreenPoint(i.transform);n.y += r * i.transform.height;const s = t.sub(n),
                          a = e.radToDeg(Math.atan2(s.y, s.x));o = (a > 90 ? a - 270 : a + 90) * (1 - r);
                }return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
            }_update(t) {
                e.window.cancelAnimationFrame(this._updateFrameId);const i = this._map;i && (i.transform.renderWorldCopies && (this._lngLat = en(this._lngLat, this._pos, i.transform)), this._pos = i.project(this._lngLat), !0 === t ? this._updateFrameId = e.window.requestAnimationFrame(() => {
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), i._requestDomTask(() => {
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }getOffset() {
                return this._offset;
            }setOffset(t) {
                return this._offset = e.pointGeometry.convert(t), this._update(), this;
            }_onMove(t) {
                const i = this._map;if (!i) return;const o = this._pointerdownPos,
                      r = this._positionDelta;if (o && r) {
                    if (!this._isDragging) {
                        const e = this._clickTolerance || i._clickTolerance;if (t.point.dist(o) < e) return;this._isDragging = !0;
                    }this._pos = t.point.sub(r), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag"));
                }
            }_onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;const t = this._map;t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive";
            }_addDragHandler(e) {
                const t = this._map,
                      i = this._pos;t && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = "pending", t.on("mousemove", this._onMove), t.on("touchmove", this._onMove), t.once("mouseup", this._onUp), t.once("touchend", this._onUp));
            }setDraggable(e) {
                this._draggable = !!e;const t = this._map;return t && (e ? (t.on("mousedown", this._addDragHandler), t.on("touchstart", this._addDragHandler)) : (t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler))), this;
            }isDraggable() {
                return this._draggable;
            }setRotation(e) {
                return this._rotation = e || 0, this._update(), this;
            }getRotation() {
                return this._rotation;
            }setRotationAlignment(e) {
                return this._rotationAlignment = e || "auto", this._update(), this;
            }getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }setPitchAlignment(e) {
                return this._pitchAlignment = e || "auto", this._update(), this;
            }getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }setOccludedOpacity(e) {
                return this._occludedOpacity = e || .2, this._update(), this;
            }getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }const rn = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" },
              nn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");function sn(t = new e.pointGeometry(0, 0), i = "bottom") {
            if ("number" == typeof t) {
                const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));switch (i) {case "top":
                        return new e.pointGeometry(0, t);case "top-left":
                        return new e.pointGeometry(o, o);case "top-right":
                        return new e.pointGeometry(-o, o);case "bottom":
                        return new e.pointGeometry(0, -t);case "bottom-left":
                        return new e.pointGeometry(o, -o);case "bottom-right":
                        return new e.pointGeometry(-o, -o);case "left":
                        return new e.pointGeometry(t, 0);case "right":
                        return new e.pointGeometry(-t, 0);}return new e.pointGeometry(0, 0);
            }return t instanceof e.pointGeometry || Array.isArray(t) ? e.pointGeometry.convert(t) : e.pointGeometry.convert(t[i] || [0, 0]);
        }class an {
            constructor(e) {
                this.jumpTo(e);
            }getValue(t) {
                if (t <= this._startTime) return this._start;if (t >= this._endTime) return this._end;const i = e.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime));return this._start * (1 - i) + this._end * i;
            }isEasing(e) {
                return e >= this._startTime && e <= this._endTime;
            }jumpTo(e) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
            }easeTo(e, t, i) {
                this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;
            }
        }const ln = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use â + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" },
              cn = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, optimizeForTerrain: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 },
              hn = { showCompass: !0, showZoom: !0, visualizePitch: !1 };class un {
            constructor(t, i, o = !1) {
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new wr({ clickTolerance: t.dragRotate._mouseRotate._clickTolerance }), this.map = t, o && (this.mousePitch = new Tr({ clickTolerance: t.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, { passive: !1 }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
            }down(e, t) {
                this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), h();
            }move(e, t) {
                const i = this.map,
                      o = this.mouseRotate.mousemoveWindow(e, t),
                      r = o && o.bearingDelta;if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(e, t),
                          r = o && o.pitchDelta;r && i.setPitch(i.getPitch() + r);
                }
            }off() {
                const e = this.element;e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart, { passive: !1 }), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp();
            }offTemp() {
                u(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
            }mousedown(t) {
                this.down(e.extend({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }), p(this.element, t)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
            }mousemove(e) {
                this.move(e, p(this.element, e));
            }mouseup(e) {
                this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
            }touchstart(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => e.preventDefault() }, this._startPos));
            }touchmove(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e.targetTouches)[0], this.move({ preventDefault: () => e.preventDefault() }, this._lastPos));
            }touchend(e) {
                0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }const _n = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 },
              dn = { maxWidth: 100, unit: "metric" };function pn(e, t, i) {
            const o = mn(t),
                  r = o / t,
                  n = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }[i];this._map._requestDomTask(() => {
                this._container.style.width = e * r + "px", this._container.innerHTML = `${o}&nbsp;${n}`;
            });
        }function mn(e) {
            const t = Math.pow(10, `${Math.floor(e)}`.length - 1);let i = e / t;return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {
                const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));return Math.round(e * t) / t;
            }(i), t * i;
        }const fn = { version: e.version, supported: i, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends Yr {
                constructor(t) {
                    if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), null != (t = e.extend({}, cn, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");if (null != t.minPitch && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");if (null != t.maxPitch && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");if (t.antialias && e.isSafariWithAntialiasingBug(e.window) && (t.antialias = !1, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ko(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._useWebGL2 = t.useWebGL2, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._collectResourceTiming = t.collectResourceTiming, this._optimizeForTerrain = t.optimizeForTerrain, this._language = this._parseLanguage(t.language), this._worldview = t.worldview, this._renderTaskQueue = new Qr(), this._domRenderTaskQueue = new Qr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, ln, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._performanceMetricsCollection = t.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new an(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e.RequestManager(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, "string" == typeof t.container) {
                        if (this._container = e.window.document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);
                    } else {
                        if (!(t.container instanceof e.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");this._container = t.container;
                    }if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t.maxBounds && this.setMaxBounds(t.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, !1), e.window.addEventListener("resize", this._onWindowResize, !1), e.window.addEventListener("orientationchange", this._onWindowResize, !1), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)), this.handlers = new $r(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, t.style && this.setStyle(t.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t.projection && this.setProjection(t.projection), this._hash = t.hash && new Qo("string" == typeof t.hash && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), t.bounds && (this.resize(), this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, { duration: 0 })))), this.resize(), t.attributionControl && this.addControl(new Kr({ customAttribution: t.customAttribution })), this._logoControl = new Jr(), this.addControl(this._logoControl, t.logoPosition), this.on("style.load", () => {
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet);
                    }), this.on("data", t => {
                        this._update("style" === t.dataType), this.fire(new e.Event(`${t.dataType}data`, t));
                    }), this.on("dataloading", t => {
                        this.fire(new e.Event(`${t.dataType}dataloading`, t));
                    });
                }_getMapId() {
                    return this._mapId;
                }addControl(t, i) {
                    if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : "top-right"), !t || !t.onAdd) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));const o = t.onAdd(this);this._controls.push(t);const r = this._controlPositions[i];return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;
                }removeControl(t) {
                    if (!t || !t.onRemove) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));const i = this._controls.indexOf(t);return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;
                }hasControl(e) {
                    return this._controls.indexOf(e) > -1;
                }getContainer() {
                    return this._container;
                }getCanvasContainer() {
                    return this._canvasContainer;
                }getCanvas() {
                    return this._canvas;
                }resize(t) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));const i = !this._moving;return i && this.fire(new e.Event("movestart", t)).fire(new e.Event("move", t)), this.fire(new e.Event("resize", t)), i && this.fire(new e.Event("moveend", t)), this;
                }getBounds() {
                    return this.transform.getBounds();
                }getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }setMaxBounds(t) {
                    return this.transform.setMaxBounds(e.LngLatBounds.convert(t)), this._update();
                }setMinZoom(t) {
                    if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }getMinZoom() {
                    return this.transform.minZoom;
                }setMaxZoom(t) {
                    if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;throw new Error("maxZoom must be greater than the current minZoom");
                }getMaxZoom() {
                    return this.transform.maxZoom;
                }setMinPitch(t) {
                    if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }getMinPitch() {
                    return this.transform.minPitch;
                }setMaxPitch(t) {
                    if ((t = null == t ? 85 : t) > 85) throw new Error("maxPitch must be less than or equal to 85");if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;throw new Error("maxPitch must be greater than or equal to minPitch");
                }getMaxPitch() {
                    return this.transform.maxPitch;
                }getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }setRenderWorldCopies(e) {
                    return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }getLanguage() {
                    return this._language;
                }_parseLanguage(t) {
                    return "auto" === t ? e.window.navigator.language : Array.isArray(t) ? 0 === t.length ? void 0 : t.map(t => "auto" === t ? e.window.navigator.language : t) : t;
                }setLanguage(e) {
                    const t = this._parseLanguage(e);if (!this.style || t === this._language) return this;this._language = t, this.style._reloadSources();for (const e of this._controls) e._setLanguage && e._setLanguage(this._language);return this;
                }getWorldview() {
                    return this._worldview;
                }setWorldview(e) {
                    return this.style && e !== this._worldview ? (this._worldview = e, this.style._reloadSources(), this) : this;
                }getProjection() {
                    return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
                }_showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }setProjection(e) {
                    return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = { name: e }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.stylesheet ? this.style.stylesheet.projection : null);
                }_updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;const t = this.transform,
                          i = t.projection.name;let o;"globe" === i && t.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t.setMercatorFromTransition(), o = !0) : "mercator" === i && t.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t.setProjection({ name: "globe" }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
                }_prioritizeAndUpdateProjection(e, t) {
                    return this._updateProjection(e || t || { name: "mercator" });
                }_updateProjection(t) {
                    let i;if (i = "globe" === t.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), i) {
                        this.painter.clearBackgroundTiles();for (const e in this.style._sourceCaches) this.style._sourceCaches[e].clearTiles();this._update(!0), this._forceMarkerAndPopupUpdate(!0);
                    }return this;
                }project(t) {
                    return this.transform.locationPoint3D(e.LngLat.convert(t));
                }unproject(t) {
                    return this.transform.pointLocation3D(e.pointGeometry.convert(t));
                }isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }_isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }_createDelegatedListener(e, t, i) {
                    if ("mouseenter" === e || "mouseover" === e) {
                        let o = !1;const r = r => {
                            const n = t.filter(e => this.getLayer(e)),
                                  s = n.length ? this.queryRenderedFeatures(r.point, { layers: n }) : [];s.length ? o || (o = !0, i.call(this, new cr(e, this, r.originalEvent, { features: s }))) : o = !1;
                        },
                              n = () => {
                            o = !1;
                        };return { layers: new Set(t), listener: i, delegates: { mousemove: r, mouseout: n } };
                    }if ("mouseleave" === e || "mouseout" === e) {
                        let o = !1;const r = r => {
                            const n = t.filter(e => this.getLayer(e));(n.length ? this.queryRenderedFeatures(r.point, { layers: n }) : []).length ? o = !0 : o && (o = !1, i.call(this, new cr(e, this, r.originalEvent)));
                        },
                              n = t => {
                            o && (o = !1, i.call(this, new cr(e, this, t.originalEvent)));
                        };return { layers: new Set(t), listener: i, delegates: { mousemove: r, mouseout: n } };
                    }{
                        const o = e => {
                            const o = t.filter(e => this.getLayer(e)),
                                  r = o.length ? this.queryRenderedFeatures(e.point, { layers: o }) : [];r.length && (e.features = r, i.call(this, e), delete e.features);
                        };return { layers: new Set(t), listener: i, delegates: { [e]: o } };
                    }
                }on(e, t, i) {
                    if (void 0 === i) return super.on(e, t);Array.isArray(t) || (t = [t]);const o = this._createDelegatedListener(e, t, i);this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);for (const e in o.delegates) this.on(e, o.delegates[e]);return this;
                }once(e, t, i) {
                    if (void 0 === i) return super.once(e, t);Array.isArray(t) || (t = [t]);const o = this._createDelegatedListener(e, t, i);for (const e in o.delegates) this.once(e, o.delegates[e]);return this;
                }off(e, t, i) {
                    if (void 0 === i) return super.off(e, t);t = new Set(Array.isArray(t) ? t : [t]);const o = (e, t) => {
                        if (e.size !== t.size) return !1;for (const i of e) if (!t.has(i)) return !1;return !0;
                    },
                          r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;return r && (e => {
                        for (let r = 0; r < e.length; r++) {
                            const n = e[r];if (n.listener === i && o(n.layers, t)) {
                                for (const e in n.delegates) this.off(e, n.delegates[e]);return e.splice(r, 1), this;
                            }
                        }
                    })(r), this;
                }queryRenderedFeatures(t, i) {
                    return this.style ? (void 0 !== i || void 0 === t || t instanceof e.pointGeometry || Array.isArray(t) || (i = t, t = void 0), this.style.queryRenderedFeatures(t = t || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : [];
                }querySourceFeatures(e, t) {
                    return this.style.querySourceFeatures(e, t);
                }setStyle(t, i) {
                    return !1 !== (i = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));
                }_getUIString(e) {
                    const t = this._locale[e];if (null == t) throw new Error(`Missing UI string '${e}'`);return t;
                }_updateStyle(e, t) {
                    return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new Qt(this, t || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;
                }_lazyInitEmptyStyle() {
                    this.style || (this.style = new Qt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
                }_diffStyle(t, i) {
                    if ("string" == typeof t) {
                        const o = this._requestManager.normalizeStyleURL(t),
                              r = this._requestManager.transformRequest(o, e.ResourceType.Style);e.getJSON(r, (t, o) => {
                            t ? this.fire(new e.ErrorEvent(t)) : o && this._updateDiff(o, i);
                        });
                    } else "object" == typeof t && this._updateDiff(t, i);
                }_updateDiff(t, i) {
                    try {
                        this.style.setState(t) && this._update(!0);
                    } catch (o) {
                        e.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t, i);
                    }
                }getStyle() {
                    if (this.style) return this.style.serialize();
                }isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), !1);
                }addSource(e, t) {
                    return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);
                }isSourceLoaded(e) {
                    return !!this.style && this.style._isSourceCacheLoaded(e);
                }areTilesLoaded() {
                    const e = this.style && this.style._sourceCaches;for (const t in e) {
                        const i = e[t]._tiles;for (const e in i) {
                            const t = i[e];if ("loaded" !== t.state && "errored" !== t.state) return !1;
                        }
                    }return !0;
                }addSourceType(e, t, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);
                }removeSource(e) {
                    return this.style.removeSource(e), this._updateTerrain(), this._update(!0);
                }getSource(e) {
                    return this.style.getSource(e);
                }addImage(t, i, { pixelRatio: o = 1, sdf: r = !1, stretchX: n, stretchY: s, content: a } = {}) {
                    if (this._lazyInitEmptyStyle(), i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap) {
                        const { width: l, height: c, data: h } = e.exported.getImageData(i);this.style.addImage(t, { data: new e.RGBAImage({ width: l, height: c }, h), pixelRatio: o, stretchX: n, stretchY: s, content: a, sdf: r, version: 0 });
                    } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));else {
                        const { width: l, height: c } = i,
                              h = i;this.style.addImage(t, { data: new e.RGBAImage({ width: l, height: c }, new Uint8Array(h.data)), pixelRatio: o, stretchX: n, stretchY: s, content: a, sdf: r, version: 0, userImage: h }), h.onAdd && h.onAdd(this, t);
                    }
                }updateImage(t, i) {
                    const o = this.style.getImage(t);if (!o) return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));const r = i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? e.exported.getImageData(i) : i,
                          { width: n, height: s } = r;void 0 !== n && void 0 !== s ? n === o.data.width && s === o.data.height ? (o.data.replace(r.data, !(i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap)), this.style.updateImage(t, o)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n}, ${s})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                }hasImage(t) {
                    return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), !1);
                }removeImage(e) {
                    this.style.removeImage(e);
                }loadImage(t, i) {
                    e.getImage(this._requestManager.transformRequest(t, e.ResourceType.Image), (t, o) => {
                        i(t, o instanceof e.window.HTMLImageElement ? e.exported.getImageData(o) : o);
                    });
                }listImages() {
                    return this.style.listImages();
                }addLayer(e, t) {
                    return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);
                }moveLayer(e, t) {
                    return this.style.moveLayer(e, t), this._update(!0);
                }removeLayer(e) {
                    return this.style.removeLayer(e), this._update(!0);
                }getLayer(e) {
                    return this.style.getLayer(e);
                }setLayerZoomRange(e, t, i) {
                    return this.style.setLayerZoomRange(e, t, i), this._update(!0);
                }setFilter(e, t, i = {}) {
                    return this.style.setFilter(e, t, i), this._update(!0);
                }getFilter(e) {
                    return this.style.getFilter(e);
                }setPaintProperty(e, t, i, o = {}) {
                    return this.style.setPaintProperty(e, t, i, o), this._update(!0);
                }getPaintProperty(e, t) {
                    return this.style.getPaintProperty(e, t);
                }setLayoutProperty(e, t, i, o = {}) {
                    return this.style.setLayoutProperty(e, t, i, o), this._update(!0);
                }getLayoutProperty(e, t) {
                    return this.style.getLayoutProperty(e, t);
                }setLight(e, t = {}) {
                    return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);
                }getLight() {
                    return this.style.getLight();
                }setTerrain(e) {
                    return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }setFog(e) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
                }getFog() {
                    return this.style ? this.style.getFog() : null;
                }_queryFogOpacity(t) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t), this.transform) : 0;
                }setFeatureState(e, t) {
                    return this.style.setFeatureState(e, t), this._update();
                }removeFeatureState(e, t) {
                    return this.style.removeFeatureState(e, t), this._update();
                }getFeatureState(e) {
                    return this.style.getFeatureState(e);
                }_updateContainerDimensions() {
                    if (!this._container) return;const t = this._container.getBoundingClientRect().width || 400,
                          i = this._container.getBoundingClientRect().height || 300;let o,
                        r,
                        n,
                        s = this._container;for (; s && (!r || !n);) {
                        const t = e.window.getComputedStyle(s).transform;t && "none" !== t && (o = t.match(/matrix.*\((.+)\)/)[1].split(", "), o[0] && "0" !== o[0] && "1" !== o[0] && (r = o[0]), o[3] && "0" !== o[3] && "1" !== o[3] && (n = o[3])), s = s.parentElement;
                    }this._containerWidth = r ? Math.abs(t / r) : t, this._containerHeight = n ? Math.abs(i / n) : i;
                }_detectMissingCSS() {
                    "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }_setupContainer() {
                    const e = this._container;e.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();const t = this._canvasContainer = n("div", "mapboxgl-canvas-container", e);this._interactive && t.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);const i = this._controlContainer = n("div", "mapboxgl-control-container", e),
                          o = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach(e => {
                        o[e] = n("div", `mapboxgl-ctrl-${e}`, i);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }_resizeCanvas(t, i) {
                    const o = e.exported.devicePixelRatio || 1;this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;
                }_addMarker(e) {
                    this._markers.push(e);
                }_removeMarker(e) {
                    const t = this._markers.indexOf(e);-1 !== t && this._markers.splice(t, 1);
                }_addPopup(e) {
                    this._popups.push(e);
                }_removePopup(e) {
                    const t = this._popups.indexOf(e);-1 !== t && this._popups.splice(t, 1);
                }_setupPainter() {
                    const t = e.extend({}, i.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }),
                          o = this._useWebGL2 && this._canvas.getContext("webgl2", t),
                          r = o || this._canvas.getContext("webgl", t) || this._canvas.getContext("experimental-webgl", t);r ? (this._useWebGL2 && !o && e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e.storeAuthState(r, !0), this.painter = new Fo(r, this.transform, !!o), this.on("data", e => {
                        "source" === e.dataType && this.painter.setTileLoadedFlag(!0);
                    }), e.exported$1.testSupport(r)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
                }_contextLost(t) {
                    t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t }));
                }_contextRestored(t) {
                    this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t }));
                }_onMapScroll(e) {
                    if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }_update(e) {
                    return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }_requestRenderFrame(e) {
                    return this._update(), this._renderTaskQueue.add(e);
                }_cancelRenderFrame(e) {
                    this._renderTaskQueue.remove(e);
                }_requestDomTask(e) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
                }_render(t) {
                    let i;const o = this.painter.context.extTimerQuery,
                          r = e.exported.now();if (this.listens("gpu-timing-frame") && (i = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;this._updateProjectionTransition();const n = this._isInitialLoad ? 0 : this._fadeDuration;if (this.style && this._styleDirty) {
                        this._styleDirty = !1;const t = this.transform.zoom,
                              i = this.transform.pitch,
                              o = e.exported.now(),
                              r = new e.EvaluationParameters(t, { now: o, fadeDuration: n, pitch: i, transition: this.style.getTransition() });this.style.update(r);
                    }this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);let s = !1;if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i) {
                        const t = e.exported.now() - r;o.endQueryEXT(o.TIME_ELAPSED_EXT, i), setTimeout(() => {
                            const n = o.getQueryObjectEXT(i, o.QUERY_RESULT_EXT) / 1e6;o.deleteQueryEXT(i), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t, gpuTime: n })), e.window.performance.mark("frame-gpu", { startTime: r, detail: { gpuTime: n } });
                        }, 50);
                    }if (this.listens("gpu-timing-layer")) {
                        const t = this.painter.collectGpuTimers();setTimeout(() => {
                            const i = this.painter.queryGpuTimers(t);this.fire(new e.Event("gpu-timing-layer", { layerTimes: i }));
                        }, 50);
                    }if (this.listens("gpu-timing-deferred-render")) {
                        const t = this.painter.collectDeferredRenderGpuQueries();setTimeout(() => {
                            const i = this.painter.queryGpuTimeDeferredRender(t);this.fire(new e.Event("gpu-timing-deferred-render", { gpuTime: i }));
                        }, 50);
                    }const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;if (a || this._repaint) this.triggerRepaint();else {
                        const t = !this.isMoving() && this.loaded();if (t && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t = this._calculateSpeedIndex();this.fire(new e.Event("speedindexcompleted", { speedIndex: t })), this.speedIndexTiming = !1;
                        }
                    }!this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
                }_forceMarkerAndPopupUpdate(e) {
                    for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();
                }_updateAverageElevation(e, t = !1) {
                    const i = e => (this.transform.averageElevation = e, this._update(!1), !0);if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
                        const t = this.transform.averageElevation;let o = this.transform.sampleAverageElevation(),
                            r = !1;this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? o = 0 : this._averageElevationLastSampledAt = e;const n = Math.abs(t - o);if (n > 1) {
                            if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);this._averageElevation.easeTo(o, e, 300);
                        } else if (n > 1e-4) return this._averageElevation.jumpTo(o), i(o);
                    }return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
                }_authenticate() {
                    e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {
                        if (t && (t.message === e.AUTH_ERR_MSG || 401 === t.status)) {
                            const t = this.painter.context.gl;e.storeAuthState(t, !1), this._logoControl instanceof Jr && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});
                }_updateTerrain() {
                    const e = this._isDragging();this.painter.updateTerrain(this.style, e);
                }_calculateSpeedIndex() {
                    const e = this.painter.canvasCopy(),
                          t = this.painter.getCanvasCopiesAndTimestamps();t.timeStamps.push(performance.now());const i = this.painter.context.gl,
                          o = i.createFramebuffer();function r(e) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;
                    }return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t.canvasCopies.map(r), t.timeStamps);
                }_canvasPixelComparison(e, t, i) {
                    let o = i[1] - i[0];const r = e.length / 4;for (let n = 0; n < t.length; n++) {
                        const s = t[n];let a = 0;for (let t = 0; t < s.length; t += 4) s[t] === e[t] && s[t + 1] === e[t + 1] && s[t + 2] === e[t + 2] && s[t + 3] === e[t + 3] && (a += 1);o += (i[n + 2] - i[n + 1]) * (1 - a / r);
                    }return o;
                }remove() {
                    this._hash && this._hash.remove();for (const e of this._controls) e.onRemove(this);this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, !1), e.window.removeEventListener("orientationchange", this._onWindowResize, !1), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.removeEventListener("online", this._onWindowOnline, !1), e.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));const t = this.painter.context.gl.getExtension("WEBGL_lose_context");t && t.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), e.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e.Event("remove"));
                }triggerRepaint() {
                    this._triggerFrame(!0);
                }_triggerFrame(t) {
                    this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.exported.frame(e => {
                        const t = !!this._renderNextFrame;this._frame = null, this._renderNextFrame = null, t && this._render(e);
                    }));
                }_preloadTiles(t) {
                    const i = this.style ? Object.values(this.style._sourceCaches) : [];return e.asyncAll(i, (e, i) => e._preloadTiles(t, i), () => {
                        this.triggerRepaint();
                    }), this;
                }_onWindowOnline() {
                    this._update();
                }_onWindowResize(e) {
                    this._trackResize && this.resize({ originalEvent: e })._update();
                }_onVisibilityChange() {
                    "hidden" === e.window.document.visibilityState && this._visibilityHidden++;
                }get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }set showTileBoundaries(e) {
                    this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());
                }get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }set showTerrainWireframe(e) {
                    this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());
                }get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }set speedIndexTiming(e) {
                    this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
                }get showPadding() {
                    return !!this._showPadding;
                }set showPadding(e) {
                    this._showPadding !== e && (this._showPadding = e, this._update());
                }get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }set showCollisionBoxes(e) {
                    this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());
                }get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }set showOverdrawInspector(e) {
                    this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());
                }get repaint() {
                    return !!this._repaint;
                }set repaint(e) {
                    this._repaint !== e && (this._repaint = e, this.triggerRepaint());
                }get vertices() {
                    return !!this._vertices;
                }set vertices(e) {
                    this._vertices = e, this._update();
                }get showTileAABBs() {
                    return !!this._showTileAABBs;
                }set showTileAABBs(e) {
                    this._showTileAABBs !== e && (this._showTileAABBs = e, e && this._update());
                }_setCacheLimits(t, i) {
                    e.setCacheLimits(t, i);
                }get version() {
                    return e.version;
                }
            }, NavigationControl: class {
                constructor(t) {
                    this.options = e.extend({}, hn, t), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", e => e.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", e => {
                        this._map && this._map.zoomIn({}, { originalEvent: e });
                    }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", e => {
                        this._map && this._map.zoomOut({}, { originalEvent: e });
                    }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", e => {
                        const t = this._map;t && (this.options.visualizePitch ? t.resetNorthPitch({}, { originalEvent: e }) : t.resetNorth({}, { originalEvent: e }));
                    }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }_updateZoomButtons() {
                    const e = this._map;if (!e) return;const t = e.getZoom(),
                          i = t === e.getMaxZoom(),
                          o = t === e.getMinZoom();this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
                }_rotateCompassArrow() {
                    const e = this._map;if (!e) return;const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;e._requestDomTask(() => {
                        this._compassIcon && (this._compassIcon.style.transform = t);
                    });
                }onAdd(e) {
                    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new un(e, this._compass, this.options.visualizePitch)), this._container;
                }onRemove() {
                    const e = this._map;e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }_createButton(e, t) {
                    const i = n("button", e, this._container);return i.type = "button", i.addEventListener("click", t), i;
                }_setButtonTitle(e, t) {
                    if (!this._map) return;const i = this._map._getUIString(`NavigationControl.${t}`);e.setAttribute("aria-label", i), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
                }
            }, GeolocateControl: class extends e.Evented {
                constructor(t) {
                    super(), this.options = e.extend({ geolocation: e.window.navigator.geolocation }, _n, t), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Jo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }onAdd(e) {
                    return this._map = e, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }onRemove() {
                    void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }_checkGeolocationSupport(t) {
                    const i = (e = !!this.options.geolocation) => {
                        this._supportsGeolocation = e, t(e);
                    };void 0 !== this._supportsGeolocation ? t(this._supportsGeolocation) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({ name: "geolocation" }).then(e => i("denied" !== e.state)).catch(() => i()) : i();
                }_isOutOfMapMaxBounds(e) {
                    const t = this._map.getMaxBounds(),
                          i = e.coords;return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());
                }_setErrorState() {
                    switch (this._watchState) {case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");break;case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");}
                }_onSuccess(t) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t)), this._updateMarker(), void this._finish();if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {case "WAITING_ACTIVE":case "ACTIVE_LOCK":case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case "BACKGROUND":case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");}this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t)), this._finish();
                    }
                }_updateCamera(t) {
                    const i = new e.LngLat(t.coords.longitude, t.coords.latitude),
                          o = t.coords.accuracy,
                          r = this._map.getBearing(),
                          n = e.extend({ bearing: r }, this.options.fitBoundsOptions);this._map.fitBounds(i.toBounds(o), n, { geolocateSource: !0 });
                }_updateMarker(t) {
                    if (t) {
                        const i = new e.LngLat(t.coords.longitude, t.coords.latitude);this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }_updateCircleRadius() {
                    const t = this._map.transform,
                          i = e.mercatorZfromAltitude(1, t._center.lat) * t.worldSize,
                          o = Math.ceil(2 * this._accuracy * i);this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                }_onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }_updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }_onError(t) {
                    if (this._map) {
                        if (this.options.trackUserLocation) if (1 === t.code) {
                            this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch();
                        } else {
                            if (3 === t.code && this._noTimeout) return;this._setErrorState();
                        }"OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t)), this._finish();
                    }
                }_finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }_setupUI(t) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", e => e.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t) {
                            e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
                        } else {
                            const e = this._map._getUIString("GeolocateControl.FindMyLocation");this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
                        }this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new on({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new on({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", t => {
                            t.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t.originalEvent && "resize" === t.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
                        });
                    }
                }_onDeviceOrientation(e) {
                    this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
                }trigger() {
                    if (!this._setup) return e.warnOnce("Geolocate control triggered before added to a map"), !1;if (this.options.trackUserLocation) {
                        switch (this._watchState) {case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));break;case "WAITING_ACTIVE":case "ACTIVE_LOCK":case "ACTIVE_ERROR":case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));break;case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));}switch (this._watchState) {case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");break;case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");}if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {
                            let e;this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);return !0;
                }_addDeviceOrientationListener() {
                    const t = () => {
                        e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
                    };void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(e => {
                        "granted" === e && t();
                    }).catch(console.error) : t();
                }_clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            }, AttributionControl: Kr, ScaleControl: class {
                constructor(t) {
                    this.options = e.extend({}, dn, t), function () {
                        try {
                            return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "narrow", unit: "meter" }), !0;
                        } catch (e) {
                            return !1;
                        }
                    }() || (this._setScale = pn.bind(this)), e.bindAll(["_update", "_setScale", "setUnit"], this);
                }getDefaultPosition() {
                    return "bottom-left";
                }_update() {
                    const e = this.options.maxWidth || 100,
                          t = this._map,
                          i = t._containerHeight / 2,
                          o = t._containerWidth / 2 - e / 2,
                          r = t.unproject([o, i]),
                          n = t.unproject([o + e, i]),
                          s = r.distanceTo(n);if ("imperial" === this.options.unit) {
                        const t = 3.2808 * s;t > 5280 ? this._setScale(e, t / 5280, "mile") : this._setScale(e, t, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(e, s / 1e3, "kilometer") : this._setScale(e, s, "meter");
                }_setScale(e, t, i) {
                    const o = mn(t),
                          r = o / t;this._map._requestDomTask(() => {
                        this._container.style.width = e * r + "px", this._container.innerHTML = "nautical-mile" !== i ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "narrow", unit: i }).format(o) : `${o}&nbsp;nm`;
                    });
                }onAdd(e) {
                    return this._map = e, this._language = e.getLanguage(), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }_setLanguage(e) {
                    this._language = e, this._update();
                }setUnit(e) {
                    this.options.unit = e, this._update();
                }
            }, FullscreenControl: class {
                constructor(t) {
                    this._fullscreen = !1, t && t.container && (t.container instanceof e.window.HTMLElement ? this._container = t.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
                }onAdd(t) {
                    return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
                }onRemove() {
                    this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }_checkFullscreenSupport() {
                    return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
                }_setupUI() {
                    const t = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);n("span", "mapboxgl-ctrl-icon", t).setAttribute("aria-hidden", "true"), t.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
                }_updateTitle() {
                    const e = this._getTitle();this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e);
                }_getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }_isFullscreen() {
                    return this._fullscreen;
                }_changeIcon() {
                    (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }_onClickFullscreen() {
                    this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            }, Popup: class extends e.Evented {
                constructor(t) {
                    super(), this.options = e.extend(Object.create(rn), t), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\s+/) : []);
                }addTo(t) {
                    return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on("preclick", this._onClose), this.options.closeOnMove && t.on("move", this._onClose), t.on("remove", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on("mousemove", this._onMouseEvent), t.on("mouseup", this._onMouseEvent), t._canvasContainer.classList.add("mapboxgl-track-pointer")) : t.on("move", this._update), this.fire(new e.Event("open")), this;
                }isOpen() {
                    return !!this._map;
                }remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);const t = this._map;return t && (t.off("move", this._update), t.off("move", this._onClose), t.off("preclick", this._onClose), t.off("click", this._onClose), t.off("remove", this.remove), t.off("mousemove", this._onMouseEvent), t.off("mouseup", this._onMouseEvent), t.off("drag", this._onMouseEvent), t._canvasContainer && t._canvasContainer.classList.remove("mapboxgl-track-pointer"), t._removePopup(this), this._map = void 0), this.fire(new e.Event("close")), this;
                }getLngLat() {
                    return this._lngLat;
                }setLngLat(t) {
                    this._lngLat = e.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update();const i = this._map;return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();const e = this._map;return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }getElement() {
                    return this._container;
                }setText(t) {
                    return this.setDOMContent(e.window.document.createTextNode(t));
                }setHTML(t) {
                    const i = e.window.document.createDocumentFragment(),
                          o = e.window.document.createElement("body");let r;for (o.innerHTML = t; r = o.firstChild, r;) i.appendChild(r);return this.setDOMContent(i);
                }getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }setMaxWidth(e) {
                    return this.options.maxWidth = e, this._update(), this;
                }setDOMContent(e) {
                    let t = this._content;if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);if (t.appendChild(e), this.options.closeButton) {
                        const e = this._closeButton = n("button", "mapboxgl-popup-close-button", t);e.type = "button", e.setAttribute("aria-label", "Close popup"), e.setAttribute("aria-hidden", "true"), e.innerHTML = "&#215;", e.addEventListener("click", this._onClose);
                    }return this._update(), this._focusFirstElement(), this;
                }addClassName(e) {
                    return this._classList.add(e), this._updateClassList(), this;
                }removeClassName(e) {
                    return this._classList.delete(e), this._updateClassList(), this;
                }setOffset(e) {
                    return this.options.offset = e, this._update(), this;
                }toggleClassName(e) {
                    let t;return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;
                }_onMouseEvent(e) {
                    this._update(e.point);
                }_getAnchor(e) {
                    if (this.options.anchor) return this.options.anchor;const t = this._map,
                          i = this._container,
                          o = this._pos;if (!t || !i || !o) return "bottom";const r = i.offsetWidth,
                          n = i.offsetHeight,
                          s = o.x < r / 2,
                          a = o.x > t.transform.width - r / 2;if (o.y + e < n) return s ? "top-left" : a ? "top-right" : "top";if (o.y > t.transform.height - n) {
                        if (s) return "bottom-left";if (a) return "bottom-right";
                    }return s ? "left" : a ? "right" : "bottom";
                }_updateClassList() {
                    const e = this._container;if (!e) return;const t = [...this._classList];t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), e.className = t.join(" ");
                }_update(t) {
                    const i = this._map,
                          o = this._content;if (!i || !this._lngLat && !this._trackPointer || !o) return;let r = this._container;if (r || (r = this._container = n("div", "mapboxgl-popup", i.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = en(this._lngLat, this._pos, i.transform)), !this._trackPointer || t) {
                        const e = this._pos = this._trackPointer && t ? t : i.project(this._lngLat),
                              o = sn(this.options.offset),
                              r = this._anchor = this._getAnchor(o.y),
                              n = sn(this.options.offset, r),
                              s = e.add(n).round();i._requestDomTask(() => {
                            this._container && r && (this._container.style.transform = `${tn[r]} translate(${s.x}px,${s.y}px)`);
                        });
                    }if (!this._marker && i._showingGlobe()) {
                        const t = e.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;this._setOpacity(t);
                    }this._updateClassList();
                }_focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;const e = this._container.querySelector(nn);e && e.focus();
                }_onClose() {
                    this.remove();
                }_setOpacity(e) {
                    this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none");
                }
            }, Marker: on, Style: Qt, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.pointGeometry, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: Zo, Evented: e.Evented, config: e.config, prewarm: function () {
                je().acquire(Ue);
            }, clearPrewarmedResources: function () {
                const e = Ge;e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Ue), Ge = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
            }, get accessToken() {
                return e.config.ACCESS_TOKEN;
            }, set accessToken(t) {
                e.config.ACCESS_TOKEN = t;
            }, get baseApiUrl() {
                return e.config.API_URL;
            }, set baseApiUrl(t) {
                e.config.API_URL = t;
            }, get workerCount() {
                return Ne.workerCount;
            }, set workerCount(e) {
                Ne.workerCount = e;
            }, get maxParallelImageRequests() {
                return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
            }, set maxParallelImageRequests(t) {
                e.config.MAX_PARALLEL_IMAGE_REQUESTS = t;
            }, clearStorage(t) {
                e.clearTileCache(t);
            }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow };return fn;
    });

    //

    var mapboxgl$1 = mapboxgl;

    return mapboxgl$1;
});
//# sourceMappingURL=mapbox-gl.js.map
},{}],6:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.displayMap = undefined;

var _mapboxGl = require('mapbox-gl');

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var displayMap = exports.displayMap = function displayMap(locations) {
  _mapboxGl2.default.accessToken = 'pk.eyJ1IjoiYmFoYWEyMDAxIiwiYSI6ImNsZXBqNncxaTA5NW4zem1qYWdjaTU0NWwifQ.EnFn3UivyEp2f9iXlWyr9w';
  var map = new _mapboxGl2.default.Map({
    container: 'map', // container ID
    style: 'mapbox://styles/bahaa2001/clevac25y000901p6izu54sva',
    // scrollZoom: false,
    // center: [-118.315192, 34.006905],
    // zoom: 5,
    interactive: false
  });

  var bounds = new _mapboxGl2.default.LngLatBounds();

  locations.forEach(function (loc) {
    // Create marker
    var el = document.createElement('div');
    el.className = 'marker';
    // Add marker
    new _mapboxGl2.default.Marker({ element: el, anchor: 'bottom' }).setLngLat(loc.coordinates).addTo(map);

    // Add popup
    new _mapboxGl2.default.Popup().setLngLat(loc.coordinates).setHTML('<p>Day ' + loc.day + ': ' + loc.description + '</p>').addTo(map);
    bounds.extend(loc.coordinates);
  });
  map.fitBounds(bounds, {
    padding: { top: 200, bottom: 200, left: 100, right: 100 }
  });
}; /* eslint-disable*/
},{"mapbox-gl":17}],3:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.colorStars = exports.updateReview = exports.deleteReview = exports.addReview = undefined;
var _this = undefined;

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _cuteAlert = require('./cute/cute-alert');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* eslint-disable */


var addReview = exports.addReview = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(body) {
    var res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return (0, _axios2.default)({
              method: 'POST',
              url: '/api/v1/reviews/',
              data: body
            });

          case 3:
            res = _context.sent;

            if (res.data.status === 'success') {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'Thanks for your review',
                timer: 1000
              }).then(function () {
                location.reload(true);
              });
            }
            _context.next = 10;
            break;

          case 7:
            _context.prev = 7;
            _context.t0 = _context['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context.t0.response.data.message,
              timer: 10000
            });

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this, [[0, 7]]);
  }));

  return function addReview(_x) {
    return _ref.apply(this, arguments);
  };
}();

var deleteReview = exports.deleteReview = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(id) {
    var res;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return (0, _axios2.default)({
              method: 'DELETE',
              url: '/api/v1/reviews/' + id,
              data: {}
            });

          case 3:
            res = _context2.sent;

            if (res.status === 204) {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'Review deleted',
                timer: 1000
              });
            }
            _context2.next = 10;
            break;

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context2.t0.response.data.message,
              timer: 2000
            });

          case 10:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, _this, [[0, 7]]);
  }));

  return function deleteReview(_x2) {
    return _ref2.apply(this, arguments);
  };
}();
var updateReview = exports.updateReview = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(review, rating, id) {
    var res;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return (0, _axios2.default)({
              method: 'PATCH',
              url: '/api/v1/reviews/' + id,
              data: { review: review, rating: rating }
            });

          case 3:
            res = _context3.sent;

            if (res.data.status === 'success') {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'Review has been updated',
                timer: 1000
              });
            }
            _context3.next = 10;
            break;

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context3.t0.response.data.message,
              timer: 10000
            });

          case 10:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, _this, [[0, 7]]);
  }));

  return function updateReview(_x3, _x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();

var colorStars = exports.colorStars = function colorStars(stars) {
  stars.forEach(function (e) {
    e.addEventListener('click', function () {
      for (var index = 0; index < stars.length; index++) {
        stars[index].classList.remove('star--active');
      }
      for (var _index = 0; _index < e.getAttribute('data-num'); _index++) {
        stars[_index].classList.toggle('star--active');
      }
    });
  });
};
},{"axios":16,"./cute/cute-alert":15}],487:[function(require,module,exports) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":74}],229:[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};
},{}],467:[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

},{"safe-buffer":487,"process":229}],501:[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],378:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};

var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {

  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';

  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  checkListener(listener);

  events = this._events;
  if (events === undefined) return this;

  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }

    if (list.length === 1) events[type] = list[0];

    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;

  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined) return [];

  var evlistener = events[type];
  if (evlistener === undefined) return [];

  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
},{}],667:[function(require,module,exports) {
module.exports = require('events').EventEmitter;
},{"events":378}],383:[function(require,module,exports) {

},{}],668:[function(require,module,exports) {

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");return (typeof key === "undefined" ? "undefined" : _typeof(key)) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if ((typeof input === "undefined" ? "undefined" : _typeof(input)) !== "object" || input === null) return input;var prim = input[Symbol.toPrimitive];if (prim !== undefined) {
    var res = prim.call(input, hint || "default");if ((typeof res === "undefined" ? "undefined" : _typeof(res)) !== "object") return res;throw new TypeError("@@toPrimitive must return a primitive value.");
  }return (hint === "string" ? String : Number)(input);
}
var _require = require('buffer'),
    Buffer = _require.Buffer;
var _require2 = require('util'),
    inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function (_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":74,"util":383}],669:[function(require,module,exports) {
var process = require("process");
'use strict';

// undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
},{"process":229}],666:[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual === 'undefined' ? 'undefined' : _typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
},{}],670:[function(require,module,exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":666}],652:[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],634:[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
},{"util-deprecate":652,"./internal/streams/stream":667,"buffer":74,"./internal/streams/destroy":669,"./internal/streams/state":670,"../errors":666,"inherits":501,"./_stream_duplex":635,"process":229}],635:[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
},{"./_stream_readable":633,"./_stream_writable":634,"inherits":501,"process":229}],609:[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":74}],564:[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":609}],638:[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function () {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function () {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function () {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function (err) {
    callback.call(stream, err);
  };
  var onclose = function () {
    var err = void 0;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function () {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
},{"../../../errors":666}],671:[function(require,module,exports) {
var process = require("process");
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function () {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise = void 0;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, 'return', function () {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function (stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function (resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
},{"./end-of-stream":638,"process":229}],672:[function(require,module,exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};
},{}],633:[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder = void 0;
var createReadableStreamAsyncIterator = void 0;
var from = void 0;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"events":378,"./internal/streams/stream":667,"buffer":74,"util":383,"./internal/streams/buffer_list":668,"./internal/streams/destroy":669,"./internal/streams/state":670,"../errors":666,"inherits":501,"./_stream_duplex":635,"string_decoder/":564,"./internal/streams/async_iterator":671,"./internal/streams/from":672,"process":229}],636:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":666,"./_stream_duplex":635,"inherits":501}],637:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":636,"inherits":501}],639:[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos = void 0;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(undefined, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error = void 0;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
},{"../../../errors":666,"./end-of-stream":638}],592:[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');
},{"./lib/_stream_readable.js":633,"./lib/_stream_writable.js":634,"./lib/_stream_duplex.js":635,"./lib/_stream_transform.js":636,"./lib/_stream_passthrough.js":637,"./lib/internal/streams/end-of-stream.js":638,"./lib/internal/streams/pipeline.js":639}],535:[function(require,module,exports) {

'use strict';

var Buffer = require('safe-buffer').Buffer;
var Transform = require('readable-stream').Transform;
var inherits = require('inherits');

function throwIfNotStringOrBuffer(val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer');
  }
}

function HashBase(blockSize) {
  Transform.call(this);

  this._block = Buffer.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];

  this._finalized = false;
}

inherits(HashBase, Transform);

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null;
  try {
    this.update(chunk, encoding);
  } catch (err) {
    error = err;
  }

  callback(error);
};

HashBase.prototype._flush = function (callback) {
  var error = null;
  try {
    this.push(this.digest());
  } catch (err) {
    error = err;
  }

  callback(error);
};

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data');
  if (this._finalized) throw new Error('Digest already called');
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);

  // consume data
  var block = this._block;
  var offset = 0;
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
    this._update();
    this._blockOffset = 0;
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++];

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry;
    carry = this._length[j] / 0x0100000000 | 0;
    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
  }

  return this;
};

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented');
};

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called');
  this._finalized = true;

  var digest = this._digest();
  if (encoding !== undefined) digest = digest.toString(encoding);

  // reset state
  this._block.fill(0);
  this._blockOffset = 0;
  for (var i = 0; i < 4; ++i) this._length[i] = 0;

  return digest;
};

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented');
};

module.exports = HashBase;
},{"safe-buffer":487,"readable-stream":592,"inherits":501}],506:[function(require,module,exports) {

'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"inherits":501,"hash-base":535,"safe-buffer":487}],504:[function(require,module,exports) {

'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":74,"inherits":501,"hash-base":535}],591:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":487}],537:[function(require,module,exports) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"inherits":501,"./hash":591,"safe-buffer":487}],538:[function(require,module,exports) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"inherits":501,"./hash":591,"safe-buffer":487}],539:[function(require,module,exports) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"inherits":501,"./hash":591,"safe-buffer":487}],536:[function(require,module,exports) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"inherits":501,"./sha256":539,"./hash":591,"safe-buffer":487}],540:[function(require,module,exports) {

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"inherits":501,"./hash":591,"safe-buffer":487}],541:[function(require,module,exports) {

var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"inherits":501,"./sha512":540,"./hash":591,"safe-buffer":487}],505:[function(require,module,exports) {
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":537,"./sha1":538,"./sha224":536,"./sha256":539,"./sha384":541,"./sha512":540}],658:[function(require,module,exports) {
var process = require("process");
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":229}],655:[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":378}],657:[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":74}],659:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":74}],654:[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":657,"util":383}],656:[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":658}],598:[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":658,"core-util-is":659,"inherits":501,"util-deprecate":652,"./internal/streams/stream":655,"safe-buffer":657,"./internal/streams/destroy":656,"./_stream_duplex":600,"process":229}],600:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":658,"core-util-is":659,"inherits":501,"./_stream_readable":597,"./_stream_writable":598}],597:[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":658,"isarray":328,"events":378,"./internal/streams/stream":655,"safe-buffer":657,"core-util-is":659,"inherits":501,"util":383,"./internal/streams/BufferList":654,"./internal/streams/destroy":656,"./_stream_duplex":600,"string_decoder/":564,"process":229}],599:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":600,"core-util-is":659,"inherits":501}],601:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":599,"core-util-is":659,"inherits":501}],549:[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":597,"./lib/_stream_writable.js":598,"./lib/_stream_duplex.js":600,"./lib/_stream_transform.js":599,"./lib/_stream_passthrough.js":601}],649:[function(require,module,exports) {
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":598}],650:[function(require,module,exports) {
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":600}],653:[function(require,module,exports) {
module.exports = require('./readable').Transform

},{"./readable":549}],651:[function(require,module,exports) {
module.exports = require('./readable').PassThrough

},{"./readable":549}],562:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":378,"inherits":501,"readable-stream/readable.js":549,"readable-stream/writable.js":649,"readable-stream/duplex.js":650,"readable-stream/transform.js":653,"readable-stream/passthrough.js":651}],502:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"safe-buffer":487,"stream":562,"string_decoder":564,"inherits":501}],468:[function(require,module,exports) {
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"inherits":501,"md5.js":506,"ripemd160":504,"sha.js":505,"cipher-base":502}],495:[function(require,module,exports) {

'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"inherits":501,"safe-buffer":487,"cipher-base":502}],497:[function(require,module,exports) {
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":506}],469:[function(require,module,exports) {

'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"inherits":501,"./legacy":495,"cipher-base":502,"safe-buffer":487,"create-hash/md5":497,"ripemd160":504,"sha.js":505}],509:[function(require,module,exports) {
module.exports = {
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}
;
},{}],480:[function(require,module,exports) {
module.exports = require('./browser/algorithms.json')

},{"./browser/algorithms.json":509}],532:[function(require,module,exports) {
var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number');
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations');
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number');
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
    /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length');
  }
};
},{}],531:[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var defaultEncoding;
/* istanbul ignore next */
if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8';
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
} else {
  defaultEncoding = 'utf-8';
}
module.exports = defaultEncoding;
},{"process":229}],530:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer;

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing;
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding);
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer);
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView');
  }
};
},{"safe-buffer":487}],489:[function(require,module,exports) {

var md5 = require('create-hash/md5');
var RIPEMD160 = require('ripemd160');
var sha = require('sha.js');
var Buffer = require('safe-buffer').Buffer;

var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var toBuffer = require('./to-buffer');

var ZEROS = Buffer.alloc(128);
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};

function Hmac(alg, key, saltLen) {
  var hash = getDigest(alg);
  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;

  if (key.length > blocksize) {
    key = hash(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
  ipad.copy(ipad1, 0, 0, blocksize);
  this.ipad1 = ipad1;
  this.ipad2 = ipad;
  this.opad = opad;
  this.alg = alg;
  this.blocksize = blocksize;
  this.hash = hash;
  this.size = sizes[alg];
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize);
  var h = this.hash(ipad);
  h.copy(this.opad, this.blocksize);
  return this.hash(this.opad);
};

function getDigest(alg) {
  function shaFunc(data) {
    return sha(alg).update(data).digest();
  }
  function rmd160Func(data) {
    return new RIPEMD160().update(data).digest();
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func;
  if (alg === 'md5') return md5;
  return shaFunc;
}

function pbkdf2(password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen);
  password = toBuffer(password, defaultEncoding, 'Password');
  salt = toBuffer(salt, defaultEncoding, 'Salt');

  digest = digest || 'sha1';

  var hmac = new Hmac(digest, password, salt.length);

  var DK = Buffer.allocUnsafe(keylen);
  var block1 = Buffer.allocUnsafe(salt.length + 4);
  salt.copy(block1, 0, 0, salt.length);

  var destPos = 0;
  var hLen = sizes[digest];
  var l = Math.ceil(keylen / hLen);

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length);

    var T = hmac.run(block1, hmac.ipad1);
    var U = T;

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2);
      for (var k = 0; k < hLen; k++) T[k] ^= U[k];
    }

    T.copy(DK, destPos);
    destPos += hLen;
  }

  return DK;
}

module.exports = pbkdf2;
},{"create-hash/md5":497,"ripemd160":504,"sha.js":505,"safe-buffer":487,"./precondition":532,"./default-encoding":531,"./to-buffer":530}],488:[function(require,module,exports) {

var global = arguments[3];
var Buffer = require('safe-buffer').Buffer;

var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var sync = require('./sync');
var toBuffer = require('./to-buffer');

var ZERO_BUF;
var subtle = global.crypto && global.crypto.subtle;
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
};
var checks = [];
function checkNative(algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false);
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false);
  }
  if (checks[algo] !== undefined) {
    return checks[algo];
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function () {
    return true;
  }).catch(function () {
    return false;
  });
  checks[algo] = prom;
  return prom;
}
var nextTick;
function getNextTick() {
  if (nextTick) {
    return nextTick;
  }
  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick;
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask;
  } else if (global.setImmediate) {
    nextTick = global.setImmediate;
  } else {
    nextTick = global.setTimeout;
  }
  return nextTick;
}
function browserPbkdf2(password, salt, iterations, length, algo) {
  return subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3);
  }).then(function (res) {
    return Buffer.from(res);
  });
}

function resolvePromise(promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out);
    });
  }, function (e) {
    getNextTick()(function () {
      callback(e);
    });
  });
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest;
    digest = undefined;
  }

  digest = digest || 'sha1';
  var algo = toBrowser[digest.toLowerCase()];

  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out;
      try {
        out = sync(password, salt, iterations, keylen, digest);
      } catch (e) {
        return callback(e);
      }
      callback(null, out);
    });
    return;
  }

  checkParameters(iterations, keylen);
  password = toBuffer(password, defaultEncoding, 'Password');
  salt = toBuffer(salt, defaultEncoding, 'Salt');
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2');

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);

    return sync(password, salt, iterations, keylen, digest);
  }), callback);
};
},{"safe-buffer":487,"./precondition":532,"./default-encoding":531,"./sync":489,"./to-buffer":530}],470:[function(require,module,exports) {
exports.pbkdf2 = require('./lib/async');
exports.pbkdf2Sync = require('./lib/sync');
},{"./lib/async":488,"./lib/sync":489}],602:[function(require,module,exports) {
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],610:[function(require,module,exports) {
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],603:[function(require,module,exports) {
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":610}],604:[function(require,module,exports) {
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var utils = require('./utils');
var Cipher = require('./cipher');

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"minimalistic-assert":610,"inherits":501,"./utils":602,"./cipher":603}],605:[function(require,module,exports) {
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"minimalistic-assert":610,"inherits":501}],606:[function(require,module,exports) {
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var Cipher = require('./cipher');
var DES = require('./des');

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"minimalistic-assert":610,"inherits":501,"./cipher":603,"./des":604}],551:[function(require,module,exports) {
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/utils":602,"./des/cipher":603,"./des/des":604,"./des/cbc":605,"./des/ede":606}],517:[function(require,module,exports) {

var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

},{"cipher-base":502,"des.js":551,"inherits":501,"safe-buffer":487}],583:[function(require,module,exports) {
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],631:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

},{"buffer":74}],588:[function(require,module,exports) {
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":631}],589:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"safe-buffer":487,"buffer-xor":631}],584:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":487}],586:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":487}],585:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"buffer-xor":631,"buffer":74}],632:[function(require,module,exports) {
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],587:[function(require,module,exports) {

var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"buffer-xor":631,"safe-buffer":487,"../incr32":632}],577:[function(require,module,exports) {
module.exports = {
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}
;
},{}],523:[function(require,module,exports) {
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./ecb":583,"./cbc":588,"./cfb":589,"./cfb8":584,"./cfb1":586,"./ofb":585,"./ctr":587,"./list.json":577}],618:[function(require,module,exports) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":487}],665:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho VÃ¤hÃ¤-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":487}],616:[function(require,module,exports) {

var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":618,"safe-buffer":487,"cipher-base":502,"inherits":501,"./ghash":665,"buffer-xor":631,"./incr32":632}],617:[function(require,module,exports) {

var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":618,"safe-buffer":487,"cipher-base":502,"inherits":501}],515:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"safe-buffer":487,"md5.js":506}],578:[function(require,module,exports) {

var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./modes":523,"./authCipher":616,"safe-buffer":487,"./streamCipher":617,"cipher-base":502,"./aes":618,"evp_bytestokey":515,"inherits":501}],579:[function(require,module,exports) {

var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./authCipher":616,"safe-buffer":487,"./modes":523,"./streamCipher":617,"cipher-base":502,"./aes":618,"evp_bytestokey":515,"inherits":501}],516:[function(require,module,exports) {
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./encrypter":578,"./decrypter":579,"./modes/list.json":577}],518:[function(require,module,exports) {
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],472:[function(require,module,exports) {
var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-des":517,"browserify-aes/browser":516,"browserify-aes/modes":523,"browserify-des/modes":518,"evp_bytestokey":515}],533:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":383}],593:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":383}],570:[function(require,module,exports) {
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":383}],534:[function(require,module,exports) {
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":593,"brorand":570}],498:[function(require,module,exports) {
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"randombytes":467,"bn.js":533,"miller-rabin":534}],496:[function(require,module,exports) {
module.exports = {
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
};
},{}],499:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

},{"bn.js":533,"miller-rabin":534,"./generatePrime":498,"randombytes":467,"buffer":74}],474:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

},{"./lib/generatePrime":498,"./lib/primes.json":496,"./lib/dh":499,"buffer":74}],642:[function(require,module,exports) {
module.exports = require('events').EventEmitter;
},{"events":378}],643:[function(require,module,exports) {

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");return (typeof key === "undefined" ? "undefined" : _typeof(key)) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if ((typeof input === "undefined" ? "undefined" : _typeof(input)) !== "object" || input === null) return input;var prim = input[Symbol.toPrimitive];if (prim !== undefined) {
    var res = prim.call(input, hint || "default");if ((typeof res === "undefined" ? "undefined" : _typeof(res)) !== "object") return res;throw new TypeError("@@toPrimitive must return a primitive value.");
  }return (hint === "string" ? String : Number)(input);
}
var _require = require('buffer'),
    Buffer = _require.Buffer;
var _require2 = require('util'),
    inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function (_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":74,"util":383}],644:[function(require,module,exports) {
var process = require("process");
'use strict';

// undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
},{"process":229}],608:[function(require,module,exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual === 'undefined' ? 'undefined' : _typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
},{}],645:[function(require,module,exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":608}],556:[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
},{"util-deprecate":652,"./internal/streams/stream":642,"buffer":74,"./internal/streams/destroy":644,"./internal/streams/state":645,"../errors":608,"inherits":501,"./_stream_duplex":554,"process":229}],554:[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
},{"./_stream_readable":557,"./_stream_writable":556,"inherits":501,"process":229}],559:[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function () {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function () {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function () {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function (err) {
    callback.call(stream, err);
  };
  var onclose = function () {
    var err = void 0;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function () {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
},{"../../../errors":608}],646:[function(require,module,exports) {
var process = require("process");
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function () {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise = void 0;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, 'return', function () {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function (stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function (resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
},{"./end-of-stream":559,"process":229}],647:[function(require,module,exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};
},{}],557:[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder = void 0;
var createReadableStreamAsyncIterator = void 0;
var from = void 0;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"events":378,"./internal/streams/stream":642,"buffer":74,"util":383,"./internal/streams/buffer_list":643,"./internal/streams/destroy":644,"./internal/streams/state":645,"../errors":608,"inherits":501,"./_stream_duplex":554,"string_decoder/":564,"./internal/streams/async_iterator":646,"./internal/streams/from":647,"process":229}],555:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":608,"./_stream_duplex":554,"inherits":501}],558:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":555,"inherits":501}],560:[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos = void 0;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(undefined, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error = void 0;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
},{"../../../errors":608,"./end-of-stream":559}],522:[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');
},{"./lib/_stream_readable.js":557,"./lib/_stream_writable.js":556,"./lib/_stream_duplex.js":554,"./lib/_stream_transform.js":555,"./lib/_stream_passthrough.js":558,"./lib/internal/streams/end-of-stream.js":559,"./lib/internal/streams/pipeline.js":560}],553:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":383}],546:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var BN = require('bn.js')
var randomBytes = require('randombytes')

function blind (priv) {
  var r = getr(priv)
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed()
  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
}

function getr (priv) {
  var len = priv.modulus.byteLength()
  var r
  do {
    r = new BN(randomBytes(len))
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
  return r
}

function crt (msg, priv) {
  var blinds = blind(priv)
  var len = priv.modulus.byteLength()
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus)
  var c1 = blinded.toRed(BN.mont(priv.prime1))
  var c2 = blinded.toRed(BN.mont(priv.prime2))
  var qinv = priv.coefficient
  var p = priv.prime1
  var q = priv.prime2
  var m1 = c1.redPow(priv.exponent1).fromRed()
  var m2 = c2.redPow(priv.exponent2).fromRed()
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q)
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len)
}
crt.getr = getr

module.exports = crt

},{"bn.js":553,"randombytes":467,"buffer":74}],567:[function(require,module,exports) {
module.exports = {
  "name": "elliptic",
  "version": "6.5.4",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}
;
},{}],611:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":383}],612:[function(require,module,exports) {
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],568:[function(require,module,exports) {
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":611,"minimalistic-assert":610,"minimalistic-crypto-utils":612}],620:[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"bn.js":611,"../utils":568}],621:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":568,"bn.js":611,"inherits":501,"./base":620}],622:[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"bn.js":611,"inherits":501,"./base":620,"../utils":568}],623:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":568,"bn.js":611,"inherits":501,"./base":620}],571:[function(require,module,exports) {
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":620,"./short":621,"./mont":622,"./edwards":623}],661:[function(require,module,exports) {
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"minimalistic-assert":610,"inherits":501}],660:[function(require,module,exports) {
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":661,"minimalistic-assert":610}],688:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":661}],683:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../utils":661,"../common":660,"./common":688}],680:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../utils":661,"../common":660,"./common":688,"minimalistic-assert":610}],679:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":661,"./256":680}],681:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../utils":661,"../common":660,"minimalistic-assert":610}],682:[function(require,module,exports) {
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":661,"./512":681}],664:[function(require,module,exports) {
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":683,"./sha/224":679,"./sha/256":680,"./sha/384":682,"./sha/512":681}],663:[function(require,module,exports) {
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./utils":661,"./common":660}],662:[function(require,module,exports) {
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":661,"minimalistic-assert":610}],619:[function(require,module,exports) {
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/utils":661,"./hash/common":660,"./hash/sha":664,"./hash/ripemd":663,"./hash/hmac":662}],615:[function(require,module,exports) {
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],569:[function(require,module,exports) {
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"hash.js":619,"./curve":571,"./utils":568,"./precomputed/secp256k1":615}],626:[function(require,module,exports) {
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":619,"minimalistic-crypto-utils":612,"minimalistic-assert":610}],624:[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"bn.js":611,"../utils":568}],625:[function(require,module,exports) {
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"bn.js":611,"../utils":568}],573:[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"bn.js":611,"hmac-drbg":626,"../utils":568,"../curves":569,"brorand":570,"./key":624,"./signature":625}],627:[function(require,module,exports) {
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":568}],628:[function(require,module,exports) {
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"bn.js":611,"../utils":568}],572:[function(require,module,exports) {
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"hash.js":619,"../curves":569,"../utils":568,"./key":627,"./signature":628}],503:[function(require,module,exports) {
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":567,"./elliptic/utils":568,"brorand":570,"./elliptic/curve":571,"./elliptic/curves":569,"./elliptic/ec":573,"./elliptic/eddsa":572}],674:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":383}],692:[function(require,module,exports) {

var process = require("process");
/* eslint-disable node/no-deprecated-api */

'use strict'

var buffer = require('buffer')
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer

},{"buffer":74,"process":229}],693:[function(require,module,exports) {
'use strict';

const inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  const state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  const state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;

  const prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;

  const now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;

  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":501}],689:[function(require,module,exports) {

'use strict';

const inherits = require('inherits');
const Reporter = require('../base/reporter').Reporter;
const Buffer = require('safer-buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    Buffer.isBuffer(data.base) &&
    data.constructor.name === 'DecoderBuffer' &&
    typeof data.offset === 'number' &&
    typeof data.length === 'number' &&
    typeof data.save === 'function' &&
    typeof data.restore === 'function' &&
    typeof data.isEmpty === 'function' &&
    typeof data.readUInt8 === 'function' &&
    typeof data.skip === 'function' &&
    typeof data.raw === 'function';

  return isCompatible;
};

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  const res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  const res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    data.constructor.name === 'EncoderBuffer' &&
    typeof data.length === 'number' &&
    typeof data.join === 'function';

  return isCompatible;
};

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = Buffer.alloc(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"inherits":501,"../base/reporter":693,"safer-buffer":692}],690:[function(require,module,exports) {
'use strict';

const Reporter = require('../base/reporter').Reporter;
const EncoderBuffer = require('../base/buffer').EncoderBuffer;
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const assert = require('minimalistic-assert');

// Supported tags
const tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
const overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;
  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

const stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      const res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        const value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  const state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  const state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  const state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  const state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  const state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  let result = state['default'];
  let present = true;

  let prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    let tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      const save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  let prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      const explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    const start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      let save;
      if (state.any)
        save = input.save();
      const body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any) {
      // no-op
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
        ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
      ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  const state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;

  Object.keys(state.choice).some(function(key) {
    const save = input.save();
    const node = state.choice[key];
    try {
      const value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  const state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  const result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  let result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default'];
    else
      return;
  }

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      const prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  if (!state.any && state.choice === null) {
    const tag = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;

  const node = state.choice[data.type];
  if (!node) {
    assert(
      false,
      data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

},{"../base/reporter":693,"../base/buffer":689,"minimalistic-assert":610}],691:[function(require,module,exports) {
'use strict';

// Helper
function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
}

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = reverse(exports.tag);

},{}],686:[function(require,module,exports) {

'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    const header = Buffer.alloc(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    const buf = Buffer.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  const objid = Buffer.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = Buffer.from(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0)
      size++;

    const out = Buffer.alloc(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  let size = 1;
  for (let i = num; i >= 0x100; i >>= 8)
    size++;

  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state['default'] === null)
    return false;

  const data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  let res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"inherits":501,"safer-buffer":692,"../base/node":690,"../constants/der":691}],687:[function(require,module,exports) {
'use strict';

const inherits = require('inherits');

const DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);

  const p = buf.toString('base64');
  const out = [ '-----BEGIN ' + options.label + '-----' ];
  for (let i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"inherits":501,"./der":686}],678:[function(require,module,exports) {
'use strict';

const encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":686,"./pem":687}],685:[function(require,module,exports) {
'use strict';

const inherits = require('inherits');

const bignum = require('bn.js');
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  const decodedTag = derDecodeTag(buffer,
    'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  let len = derDecodeLen(buffer,
    decodedTag.primitive,
    'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  const state = buffer.save();
  const res = this._skipUntilEnd(
    buffer,
    'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (;;) {
    const tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    const len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    let res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len);
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
  options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    const res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    const raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    let str = '';
    for (let i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    const numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    const printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  const first = (identifiers[0] / 40) | 0;
  const second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    let tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  const str = buffer.raw().toString();

  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;
  if (tag === 'gentime') {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  const raw = buffer.raw();
  let res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    let oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  const tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  const num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"inherits":501,"bn.js":674,"../base/buffer":689,"../base/node":690,"../constants/der":691}],684:[function(require,module,exports) {

'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;

const DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);

  const label = options.label.toUpperCase();

  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  const base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9+/=]+/gi, '');

  const input = Buffer.from(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"inherits":501,"safer-buffer":692,"./der":685}],675:[function(require,module,exports) {
'use strict';

const decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":685,"./pem":684}],673:[function(require,module,exports) {
'use strict';

const encoders = require('./encoders');
const decoders = require('./decoders');
const inherits = require('inherits');

const api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;

  function Generated(entity) {
    this._initNamed(entity, name);
  }
  inherits(Generated, Base);
  Generated.prototype._initNamed = function _initNamed(entity, name) {
    Base.call(this, entity, name);
  };

  return new Generated(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"./encoders":678,"./decoders":675,"inherits":501}],676:[function(require,module,exports) {
'use strict';

const base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./reporter":693,"./buffer":689,"./node":690}],677:[function(require,module,exports) {
'use strict';

const constants = exports;

// Helper
constants._reverse = function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":691}],641:[function(require,module,exports) {
'use strict';

const asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"bn.js":674,"./asn1/api":673,"./asn1/base":676,"./asn1/constants":677,"./asn1/decoders":675,"./asn1/encoders":678}],640:[function(require,module,exports) {
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict'

var asn = require('asn1.js')

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate

},{"asn1.js":641}],595:[function(require,module,exports) {
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
'use strict'

var asn1 = require('asn1.js')

exports.certificate = require('./certificate')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

},{"asn1.js":641,"./certificate":640}],594:[function(require,module,exports) {
module.exports = {"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
},{}],596:[function(require,module,exports) {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
var Buffer = require('safe-buffer').Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

},{"evp_bytestokey":515,"browserify-aes":516,"safe-buffer":487}],547:[function(require,module,exports) {

var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
var Buffer = require('safe-buffer').Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

},{"./asn1":595,"./aesid.json":594,"./fixProc":596,"browserify-aes":516,"pbkdf2":470,"safe-buffer":487}],552:[function(require,module,exports) {
module.exports = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}
;
},{}],519:[function(require,module,exports) {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var EC = require('elliptic').ec
var BN = require('bn.js')
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [0, 1]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return Buffer.from(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r)
  if (s[0] & 0x80) s = [0].concat(s)

  var total = r.length + s.length + 4
  var res = [0x30, total, 0x02, r.length]
  res = res.concat(r, [0x02, s.length], s)
  return Buffer.from(res)
}

function getKey (x, q, hash, algo) {
  x = Buffer.from(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = Buffer.alloc(hlen)
  v.fill(1)
  var k = Buffer.alloc(hlen)
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = Buffer.from(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = Buffer.alloc(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

},{"safe-buffer":487,"create-hmac":469,"browserify-rsa":546,"elliptic":503,"bn.js":553,"parse-asn1":547,"./curves.json":552}],520:[function(require,module,exports) {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer
var BN = require('bn.js')
var EC = require('elliptic').ec
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [1]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = Buffer.from(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = Buffer.from(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

},{"safe-buffer":487,"bn.js":553,"elliptic":503,"parse-asn1":547,"./curves.json":552}],471:[function(require,module,exports) {

var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var stream = require('readable-stream')
var inherits = require('inherits')
var sign = require('./sign')
var verify = require('./verify')

var algorithms = require('./algorithms.json')
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = Buffer.from(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

},{"safe-buffer":487,"create-hash":468,"readable-stream":522,"inherits":501,"./sign":519,"./verify":520,"./algorithms.json":509}],500:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":383}],473:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

},{"elliptic":503,"bn.js":500,"buffer":74}],543:[function(require,module,exports) {

var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

},{"create-hash":468,"safe-buffer":487}],542:[function(require,module,exports) {
module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

},{}],545:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":383}],544:[function(require,module,exports) {

var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

},{"bn.js":545,"safe-buffer":487}],507:[function(require,module,exports) {

var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

},{"parse-asn1":547,"randombytes":467,"create-hash":468,"./mgf":543,"./xor":542,"bn.js":545,"./withPublic":544,"browserify-rsa":546,"safe-buffer":487}],508:[function(require,module,exports) {

var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

},{"parse-asn1":547,"./mgf":543,"./xor":542,"bn.js":545,"browserify-rsa":546,"create-hash":468,"./withPublic":544,"safe-buffer":487}],477:[function(require,module,exports) {
exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

},{"./publicEncrypt":507,"./privateDecrypt":508}],478:[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

},{"safe-buffer":487,"randombytes":467,"process":229}],377:[function(require,module,exports) {
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var algos = require('browserify-sign/algos')
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = require('diffie-hellman')

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = require('browserify-sign')

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill')

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}

},{"randombytes":467,"create-hash":468,"create-hmac":469,"browserify-sign/algos":480,"pbkdf2":470,"browserify-cipher":472,"diffie-hellman":474,"browserify-sign":471,"create-ecdh":473,"public-encrypt":477,"randomfill":478}],64:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoProvider = void 0;
/**
 * Interface encapsulating the various crypto computations used by the library,
 * allowing pluggable underlying crypto implementations.
 */

var CryptoProvider = function () {
  function CryptoProvider() {
    _classCallCheck(this, CryptoProvider);
  }

  _createClass(CryptoProvider, [{
    key: "computeHMACSignature",

    /**
     * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
     * The output HMAC should be encoded in hexadecimal.
     *
     * Sample values for implementations:
     * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
     * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
     */
    value: function computeHMACSignature(payload, secret) {
      throw new Error('computeHMACSignature not implemented.');
    }
    /**
     * Asynchronous version of `computeHMACSignature`. Some implementations may
     * only allow support async signature computation.
     *
     * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
     * The output HMAC should be encoded in hexadecimal.
     *
     * Sample values for implementations:
     * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
     * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
     */

  }, {
    key: "computeHMACSignatureAsync",
    value: function computeHMACSignatureAsync(payload, secret) {
      throw new Error('computeHMACSignatureAsync not implemented.');
    }
  }]);

  return CryptoProvider;
}();

exports.CryptoProvider = CryptoProvider;
},{}],374:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeCryptoProvider = void 0;
var crypto = require("crypto");
var CryptoProvider_1 = require("./CryptoProvider");
/**
 * `CryptoProvider which uses the Node `crypto` package for its computations.
 */

var NodeCryptoProvider = function (_CryptoProvider_1$Cry) {
    _inherits(NodeCryptoProvider, _CryptoProvider_1$Cry);

    function NodeCryptoProvider() {
        _classCallCheck(this, NodeCryptoProvider);

        return _possibleConstructorReturn(this, (NodeCryptoProvider.__proto__ || Object.getPrototypeOf(NodeCryptoProvider)).apply(this, arguments));
    }

    _createClass(NodeCryptoProvider, [{
        key: "computeHMACSignature",

        /** @override */
        value: function computeHMACSignature(payload, secret) {
            return crypto.createHmac('sha256', secret).update(payload, 'utf8').digest('hex');
        }
        /** @override */

    }, {
        key: "computeHMACSignatureAsync",
        value: function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(payload, secret) {
                var signature;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.computeHMACSignature(payload, secret);

                            case 2:
                                signature = _context.sent;
                                return _context.abrupt("return", signature);

                            case 4:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function computeHMACSignatureAsync(_x, _x2) {
                return _ref.apply(this, arguments);
            }

            return computeHMACSignatureAsync;
        }()
    }]);

    return NodeCryptoProvider;
}(CryptoProvider_1.CryptoProvider);

exports.NodeCryptoProvider = NodeCryptoProvider;
},{"crypto":377,"./CryptoProvider":64}],548:[function(require,module,exports) {
var global = arguments[3];
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

},{}],510:[function(require,module,exports) {
var process = require("process");
var Buffer = require("buffer").Buffer;
var global = arguments[3];
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

},{"./capability":548,"inherits":501,"readable-stream":549,"process":229,"buffer":74}],550:[function(require,module,exports) {

var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":74}],511:[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var global = arguments[3];
var process = require("process");
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

},{"./capability":548,"inherits":501,"./response":510,"readable-stream":549,"to-arraybuffer":550,"buffer":74,"process":229}],514:[function(require,module,exports) {
module.exports = extend;

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target;
}
},{}],513:[function(require,module,exports) {
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],575:[function(require,module,exports) {
var global = arguments[3];
var define;
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

},{}],574:[function(require,module,exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],614:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
},{}],613:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};
},{}],576:[function(require,module,exports) {
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');
},{"./decode":614,"./encode":613}],512:[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"punycode":575,"./util":574,"querystring":576}],481:[function(require,module,exports) {
var global = arguments[3];
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
},{"./lib/request":511,"./lib/response":510,"xtend":514,"builtin-status-codes":513,"url":512}],482:[function(require,module,exports) {
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

},{"http":481,"url":512}],63:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClientResponse = exports.HttpClient = void 0;
/**
 * Encapsulates the logic for issuing a request to the Stripe API.
 *
 * A custom HTTP client should should implement:
 * 1. A response class which extends HttpClientResponse and wraps around their
 *    own internal representation of a response.
 * 2. A client class which extends HttpClient and implements all methods,
 *    returning their own response class when making requests.
 */

var HttpClient = function () {
    function HttpClient() {
        _classCallCheck(this, HttpClient);
    }

    _createClass(HttpClient, [{
        key: "getClientName",

        /** The client name used for diagnostics. */
        value: function getClientName() {
            throw new Error('getClientName not implemented.');
        }
    }, {
        key: "makeRequest",
        value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
            throw new Error('makeRequest not implemented.');
        }
        /** Helper to make a consistent timeout error across implementations. */

    }], [{
        key: "makeTimeoutError",
        value: function makeTimeoutError() {
            var timeoutErr = new TypeError(HttpClient.TIMEOUT_ERROR_CODE);
            timeoutErr.code = HttpClient.TIMEOUT_ERROR_CODE;
            return timeoutErr;
        }
    }]);

    return HttpClient;
}();

exports.HttpClient = HttpClient;
// Public API accessible via Stripe.HttpClient
HttpClient.CONNECTION_CLOSED_ERROR_CODES = ['ECONNRESET', 'EPIPE'];
HttpClient.TIMEOUT_ERROR_CODE = 'ETIMEDOUT';

var HttpClientResponse = function () {
    function HttpClientResponse(statusCode, headers) {
        _classCallCheck(this, HttpClientResponse);

        this._statusCode = statusCode;
        this._headers = headers;
    }

    _createClass(HttpClientResponse, [{
        key: "getStatusCode",
        value: function getStatusCode() {
            return this._statusCode;
        }
    }, {
        key: "getHeaders",
        value: function getHeaders() {
            return this._headers;
        }
    }, {
        key: "getRawResponse",
        value: function getRawResponse() {
            throw new Error('getRawResponse not implemented.');
        }
    }, {
        key: "toStream",
        value: function toStream(streamCompleteCallback) {
            throw new Error('toStream not implemented.');
        }
    }, {
        key: "toJSON",
        value: function toJSON() {
            throw new Error('toJSON not implemented.');
        }
    }]);

    return HttpClientResponse;
}();

exports.HttpClientResponse = HttpClientResponse;
},{}],375:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeHttpClientResponse = exports.NodeHttpClient = void 0;
var http = require("http");
var https = require("https");
var HttpClient_1 = require("./HttpClient");
var defaultHttpAgent = new http.Agent({ keepAlive: true });
var defaultHttpsAgent = new https.Agent({ keepAlive: true });
/**
 * HTTP client which uses the Node `http` and `https` packages to issue
 * requests.`
 */

var NodeHttpClient = function (_HttpClient_1$HttpCli) {
    _inherits(NodeHttpClient, _HttpClient_1$HttpCli);

    function NodeHttpClient(agent) {
        _classCallCheck(this, NodeHttpClient);

        var _this = _possibleConstructorReturn(this, (NodeHttpClient.__proto__ || Object.getPrototypeOf(NodeHttpClient)).call(this));

        _this._agent = agent;
        return _this;
    }
    /** @override. */


    _createClass(NodeHttpClient, [{
        key: "getClientName",
        value: function getClientName() {
            return 'node';
        }
    }, {
        key: "makeRequest",
        value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
            var isInsecureConnection = protocol === 'http';
            var agent = this._agent;
            if (!agent) {
                agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;
            }
            var requestPromise = new Promise(function (resolve, reject) {
                var req = (isInsecureConnection ? http : https).request({
                    host: host,
                    port: port,
                    path: path,
                    method: method,
                    agent: agent,
                    headers: headers,
                    ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5'
                });
                req.setTimeout(timeout, function () {
                    req.destroy(HttpClient_1.HttpClient.makeTimeoutError());
                });
                req.on('response', function (res) {
                    resolve(new NodeHttpClientResponse(res));
                });
                req.on('error', function (error) {
                    reject(error);
                });
                req.once('socket', function (socket) {
                    if (socket.connecting) {
                        socket.once(isInsecureConnection ? 'connect' : 'secureConnect', function () {
                            // Send payload; we're safe:
                            req.write(requestData);
                            req.end();
                        });
                    } else {
                        // we're already connected
                        req.write(requestData);
                        req.end();
                    }
                });
            });
            return requestPromise;
        }
    }]);

    return NodeHttpClient;
}(HttpClient_1.HttpClient);

exports.NodeHttpClient = NodeHttpClient;

var NodeHttpClientResponse = function (_HttpClient_1$HttpCli2) {
    _inherits(NodeHttpClientResponse, _HttpClient_1$HttpCli2);

    function NodeHttpClientResponse(res) {
        _classCallCheck(this, NodeHttpClientResponse);

        var _this2 = _possibleConstructorReturn(this, (NodeHttpClientResponse.__proto__ || Object.getPrototypeOf(NodeHttpClientResponse)).call(this, res.statusCode, res.headers || {}));
        // @ts-ignore


        _this2._res = res;
        return _this2;
    }

    _createClass(NodeHttpClientResponse, [{
        key: "getRawResponse",
        value: function getRawResponse() {
            return this._res;
        }
    }, {
        key: "toStream",
        value: function toStream(streamCompleteCallback) {
            // The raw response is itself the stream, so we just return that. To be
            // backwards compatible, we should invoke the streamCompleteCallback only
            // once the stream has been fully consumed.
            this._res.once('end', function () {
                return streamCompleteCallback();
            });
            return this._res;
        }
    }, {
        key: "toJSON",
        value: function toJSON() {
            var _this3 = this;

            return new Promise(function (resolve, reject) {
                var response = '';
                _this3._res.setEncoding('utf8');
                _this3._res.on('data', function (chunk) {
                    response += chunk;
                });
                _this3._res.once('end', function () {
                    try {
                        resolve(JSON.parse(response));
                    } catch (e) {
                        reject(e);
                    }
                });
            });
        }
    }]);

    return NodeHttpClientResponse;
}(HttpClient_1.HttpClientResponse);

exports.NodeHttpClientResponse = NodeHttpClientResponse;
},{"http":481,"https":482,"./HttpClient":63}],466:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchHttpClientResponse = exports.FetchHttpClient = void 0;
var HttpClient_1 = require("./HttpClient");
/**
 * HTTP client which uses a `fetch` function to issue requests.
 *
 * By default relies on the global `fetch` function, but an optional function
 * can be passed in. If passing in a function, it is expected to match the Web
 * Fetch API. As an example, this could be the function provided by the
 * node-fetch package (https://github.com/node-fetch/node-fetch).
 */

var FetchHttpClient = function (_HttpClient_1$HttpCli) {
    _inherits(FetchHttpClient, _HttpClient_1$HttpCli);

    function FetchHttpClient(fetchFn) {
        _classCallCheck(this, FetchHttpClient);

        var _this = _possibleConstructorReturn(this, (FetchHttpClient.__proto__ || Object.getPrototypeOf(FetchHttpClient)).call(this));

        _this._fetchFn = fetchFn;
        return _this;
    }
    /** @override. */


    _createClass(FetchHttpClient, [{
        key: "getClientName",
        value: function getClientName() {
            return 'fetch';
        }
    }, {
        key: "makeRequest",
        value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
            var isInsecureConnection = protocol === 'http';
            var url = new URL(path, (isInsecureConnection ? 'http' : 'https') + "://" + host);
            url.port = port;
            // For methods which expect payloads, we should always pass a body value
            // even when it is empty. Without this, some JS runtimes (eg. Deno) will
            // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519
            // for more details.
            var methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';
            var body = requestData || (methodHasPayload ? '' : undefined);
            var fetchFn = this._fetchFn || fetch;
            var fetchPromise = fetchFn(url.toString(), {
                method: method,
                // @ts-ignore
                headers: headers,
                // @ts-ignore
                body: body
            });
            // The Fetch API does not support passing in a timeout natively, so a
            // timeout promise is constructed to race against the fetch and preempt the
            // request, simulating a timeout.
            //
            // This timeout behavior differs from Node:
            // - Fetch uses a single timeout for the entire length of the request.
            // - Node is more fine-grained and resets the timeout after each stage of
            //   the request.
            //
            // As an example, if the timeout is set to 30s and the connection takes 20s
            // to be established followed by 20s for the body, Fetch would timeout but
            // Node would not. The more fine-grained timeout cannot be implemented with
            // fetch.
            var pendingTimeoutId = void 0;
            var timeoutPromise = new Promise(function (_, reject) {
                pendingTimeoutId = setTimeout(function () {
                    pendingTimeoutId = null;
                    reject(HttpClient_1.HttpClient.makeTimeoutError());
                }, timeout);
            });
            return Promise.race([fetchPromise, timeoutPromise]).then(function (res) {
                return new FetchHttpClientResponse(res);
            }).finally(function () {
                if (pendingTimeoutId) {
                    clearTimeout(pendingTimeoutId);
                }
            });
        }
    }]);

    return FetchHttpClient;
}(HttpClient_1.HttpClient);

exports.FetchHttpClient = FetchHttpClient;

var FetchHttpClientResponse = function (_HttpClient_1$HttpCli2) {
    _inherits(FetchHttpClientResponse, _HttpClient_1$HttpCli2);

    function FetchHttpClientResponse(res) {
        _classCallCheck(this, FetchHttpClientResponse);

        var _this2 = _possibleConstructorReturn(this, (FetchHttpClientResponse.__proto__ || Object.getPrototypeOf(FetchHttpClientResponse)).call(this, res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers)));

        _this2._res = res;
        return _this2;
    }

    _createClass(FetchHttpClientResponse, [{
        key: "getRawResponse",
        value: function getRawResponse() {
            return this._res;
        }
    }, {
        key: "toStream",
        value: function toStream(streamCompleteCallback) {
            // Unfortunately `fetch` does not have event handlers for when the stream is
            // completely read. We therefore invoke the streamCompleteCallback right
            // away. This callback emits a response event with metadata and completes
            // metrics, so it's ok to do this without waiting for the stream to be
            // completely read.
            streamCompleteCallback();
            // Fetch's `body` property is expected to be a readable stream of the body.
            return this._res.body;
        }
    }, {
        key: "toJSON",
        value: function toJSON() {
            return this._res.json();
        }
    }], [{
        key: "_transformHeadersToObject",
        value: function _transformHeadersToObject(headers) {
            // Fetch uses a Headers instance so this must be converted to a barebones
            // JS object to meet the HttpClient interface.
            var headersObj = {};
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = headers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var entry = _step.value;

                    if (!Array.isArray(entry) || entry.length != 2) {
                        throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');
                    }
                    headersObj[entry[0]] = entry[1];
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return headersObj;
        }
    }]);

    return FetchHttpClientResponse;
}(HttpClient_1.HttpClientResponse);

exports.FetchHttpClientResponse = FetchHttpClientResponse;
},{"./HttpClient":63}],465:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.SubtleCryptoProvider = void 0;
var CryptoProvider_1 = require("./CryptoProvider");
/**
 * `CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.
 *
 * This only supports asynchronous operations.
 */

var SubtleCryptoProvider = function (_CryptoProvider_1$Cry) {
    _inherits(SubtleCryptoProvider, _CryptoProvider_1$Cry);

    function SubtleCryptoProvider(subtleCrypto) {
        _classCallCheck(this, SubtleCryptoProvider);

        // If no subtle crypto is interface, default to the global namespace. This
        // is to allow custom interfaces (eg. using the Node webcrypto interface in
        // tests).
        var _this = _possibleConstructorReturn(this, (SubtleCryptoProvider.__proto__ || Object.getPrototypeOf(SubtleCryptoProvider)).call(this));

        _this.subtleCrypto = subtleCrypto || crypto.subtle;
        return _this;
    }
    /** @override */


    _createClass(SubtleCryptoProvider, [{
        key: "computeHMACSignature",
        value: function computeHMACSignature(payload, secret) {
            throw new Error('SubtleCryptoProvider cannot be used in a synchronous context.');
        }
        /** @override */

    }, {
        key: "computeHMACSignatureAsync",
        value: function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(payload, secret) {
                var encoder, key, signatureBuffer, signatureBytes, signatureHexCodes, i;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                encoder = new TextEncoder();
                                _context.next = 3;
                                return this.subtleCrypto.importKey('raw', encoder.encode(secret), {
                                    name: 'HMAC',
                                    hash: { name: 'SHA-256' }
                                }, false, ['sign']);

                            case 3:
                                key = _context.sent;
                                _context.next = 6;
                                return this.subtleCrypto.sign('hmac', key, encoder.encode(payload));

                            case 6:
                                signatureBuffer = _context.sent;

                                // crypto.subtle returns the signature in base64 format. This must be
                                // encoded in hex to match the CryptoProvider contract. We map each byte in
                                // the buffer to its corresponding hex octet and then combine into a string.
                                signatureBytes = new Uint8Array(signatureBuffer);
                                signatureHexCodes = new Array(signatureBytes.length);

                                for (i = 0; i < signatureBytes.length; i++) {
                                    signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];
                                }
                                return _context.abrupt("return", signatureHexCodes.join(''));

                            case 11:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function computeHMACSignatureAsync(_x, _x2) {
                return _ref.apply(this, arguments);
            }

            return computeHMACSignatureAsync;
        }()
    }]);

    return SubtleCryptoProvider;
}(CryptoProvider_1.CryptoProvider);

exports.SubtleCryptoProvider = SubtleCryptoProvider;
// Cached mapping of byte to hex representation. We do this once to avoid re-
// computing every time we need to convert the result of a signature to hex.
var byteHexMapping = new Array(256);
for (var i = 0; i < byteHexMapping.length; i++) {
    byteHexMapping[i] = i.toString(16).padStart(2, '0');
}
},{"./CryptoProvider":64}],376:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformFunctions = void 0;
var FetchHttpClient_1 = require("../net/FetchHttpClient");
var SubtleCryptoProvider_1 = require("../crypto/SubtleCryptoProvider");
/**
 * Interface encapsulating various utility functions whose
 * implementations depend on the platform / JS runtime.
 */

var PlatformFunctions = function () {
    function PlatformFunctions() {
        _classCallCheck(this, PlatformFunctions);

        this._fetchFn = null;
        this._agent = null;
    }
    /**
     * Gets uname with Node's built-in `exec` function, if available.
     */


    _createClass(PlatformFunctions, [{
        key: "getUname",
        value: function getUname() {
            throw new Error('getUname not implemented.');
        }
        /**
         * Generates a v4 UUID. See https://stackoverflow.com/a/2117523
         */

    }, {
        key: "uuid4",
        value: function uuid4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0;
                var v = c === 'x' ? r : r & 0x3 | 0x8;
                return v.toString(16);
            });
        }
        /**
         * Compares strings in constant time.
         */

    }, {
        key: "secureCompare",
        value: function secureCompare(a, b) {
            // return early here if buffer lengths are not equal
            if (a.length !== b.length) {
                return false;
            }
            var len = a.length;
            var result = 0;
            for (var i = 0; i < len; ++i) {
                result |= a.charCodeAt(i) ^ b.charCodeAt(i);
            }
            return result === 0;
        }
        /**
         * Creates an event emitter.
         */

    }, {
        key: "createEmitter",
        value: function createEmitter() {
            throw new Error('createEmitter not implemented.');
        }
        /**
         * Checks if the request data is a stream. If so, read the entire stream
         * to a buffer and return the buffer.
         */

    }, {
        key: "tryBufferData",
        value: function tryBufferData(data) {
            throw new Error('tryBufferData not implemented.');
        }
        /**
         * Creates an HTTP client which uses the Node `http` and `https` packages
         * to issue requests.
         */

    }, {
        key: "createNodeHttpClient",
        value: function createNodeHttpClient(agent) {
            throw new Error('createNodeHttpClient not implemented.');
        }
        /**
         * Creates an HTTP client for issuing Stripe API requests which uses the Web
         * Fetch API.
         *
         * A fetch function can optionally be passed in as a parameter. If none is
         * passed, will default to the default `fetch` function in the global scope.
         */

    }, {
        key: "createFetchHttpClient",
        value: function createFetchHttpClient(fetchFn) {
            return new FetchHttpClient_1.FetchHttpClient(fetchFn);
        }
        /**
         * Creates an HTTP client using runtime-specific APIs.
         */

    }, {
        key: "createDefaultHttpClient",
        value: function createDefaultHttpClient() {
            throw new Error('createDefaultHttpClient not implemented.');
        }
        /**
         * Creates a CryptoProvider which uses the Node `crypto` package for its computations.
         */

    }, {
        key: "createNodeCryptoProvider",
        value: function createNodeCryptoProvider() {
            throw new Error('createNodeCryptoProvider not implemented.');
        }
        /**
         * Creates a CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.
         */

    }, {
        key: "createSubtleCryptoProvider",
        value: function createSubtleCryptoProvider(subtleCrypto) {
            return new SubtleCryptoProvider_1.SubtleCryptoProvider(subtleCrypto);
        }
    }, {
        key: "createDefaultCryptoProvider",
        value: function createDefaultCryptoProvider() {
            throw new Error('createDefaultCryptoProvider not implemented.');
        }
    }]);

    return PlatformFunctions;
}();

exports.PlatformFunctions = PlatformFunctions;
},{"../net/FetchHttpClient":466,"../crypto/SubtleCryptoProvider":465}],57:[function(require,module,exports) {
"use strict";
/* eslint-disable camelcase */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.StripeUnknownError = exports.StripeInvalidGrantError = exports.StripeIdempotencyError = exports.StripeSignatureVerificationError = exports.StripeConnectionError = exports.StripeRateLimitError = exports.StripePermissionError = exports.StripeAuthenticationError = exports.StripeAPIError = exports.StripeInvalidRequestError = exports.StripeCardError = exports.StripeError = exports.generate = void 0;
var generate = function generate(rawStripeError) {
  switch (rawStripeError.type) {
    case 'card_error':
      return new StripeCardError(rawStripeError);
    case 'invalid_request_error':
      return new StripeInvalidRequestError(rawStripeError);
    case 'api_error':
      return new StripeAPIError(rawStripeError);
    case 'authentication_error':
      return new StripeAuthenticationError(rawStripeError);
    case 'rate_limit_error':
      return new StripeRateLimitError(rawStripeError);
    case 'idempotency_error':
      return new StripeIdempotencyError(rawStripeError);
    case 'invalid_grant':
      return new StripeInvalidGrantError(rawStripeError);
    default:
      return new StripeUnknownError(rawStripeError);
  }
};
exports.generate = generate;
/**
 * StripeError is the base error from which all other more specific Stripe errors derive.
 * Specifically for errors returned from Stripe's REST API.
 */

var StripeError = function (_Error) {
  _inherits(StripeError, _Error);

  function StripeError() {
    var raw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, StripeError);

    var _this = _possibleConstructorReturn(this, (StripeError.__proto__ || Object.getPrototypeOf(StripeError)).call(this, raw.message));

    _this.type = _this.constructor.name;
    _this.raw = raw;
    _this.rawType = raw.type;
    _this.code = raw.code;
    _this.doc_url = raw.doc_url;
    _this.param = raw.param;
    _this.detail = raw.detail;
    _this.headers = raw.headers;
    _this.requestId = raw.requestId;
    _this.statusCode = raw.statusCode;
    // @ts-ignore
    _this.message = raw.message;
    _this.charge = raw.charge;
    _this.decline_code = raw.decline_code;
    _this.payment_intent = raw.payment_intent;
    _this.payment_method = raw.payment_method;
    _this.payment_method_type = raw.payment_method_type;
    _this.setup_intent = raw.setup_intent;
    _this.source = raw.source;
    return _this;
  }

  return StripeError;
}(Error);

exports.StripeError = StripeError;
/**
 * Helper factory which takes raw stripe errors and outputs wrapping instances
 */
StripeError.generate = exports.generate;
// Specific Stripe Error types:
/**
 * CardError is raised when a user enters a card that can't be charged for
 * some reason.
 */

var StripeCardError = function (_StripeError) {
  _inherits(StripeCardError, _StripeError);

  function StripeCardError() {
    _classCallCheck(this, StripeCardError);

    return _possibleConstructorReturn(this, (StripeCardError.__proto__ || Object.getPrototypeOf(StripeCardError)).apply(this, arguments));
  }

  return StripeCardError;
}(StripeError);

exports.StripeCardError = StripeCardError;
/**
 * InvalidRequestError is raised when a request is initiated with invalid
 * parameters.
 */

var StripeInvalidRequestError = function (_StripeError2) {
  _inherits(StripeInvalidRequestError, _StripeError2);

  function StripeInvalidRequestError() {
    _classCallCheck(this, StripeInvalidRequestError);

    return _possibleConstructorReturn(this, (StripeInvalidRequestError.__proto__ || Object.getPrototypeOf(StripeInvalidRequestError)).apply(this, arguments));
  }

  return StripeInvalidRequestError;
}(StripeError);

exports.StripeInvalidRequestError = StripeInvalidRequestError;
/**
 * APIError is a generic error that may be raised in cases where none of the
 * other named errors cover the problem. It could also be raised in the case
 * that a new error has been introduced in the API, but this version of the
 * Node.JS SDK doesn't know how to handle it.
 */

var StripeAPIError = function (_StripeError3) {
  _inherits(StripeAPIError, _StripeError3);

  function StripeAPIError() {
    _classCallCheck(this, StripeAPIError);

    return _possibleConstructorReturn(this, (StripeAPIError.__proto__ || Object.getPrototypeOf(StripeAPIError)).apply(this, arguments));
  }

  return StripeAPIError;
}(StripeError);

exports.StripeAPIError = StripeAPIError;
/**
 * AuthenticationError is raised when invalid credentials are used to connect
 * to Stripe's servers.
 */

var StripeAuthenticationError = function (_StripeError4) {
  _inherits(StripeAuthenticationError, _StripeError4);

  function StripeAuthenticationError() {
    _classCallCheck(this, StripeAuthenticationError);

    return _possibleConstructorReturn(this, (StripeAuthenticationError.__proto__ || Object.getPrototypeOf(StripeAuthenticationError)).apply(this, arguments));
  }

  return StripeAuthenticationError;
}(StripeError);

exports.StripeAuthenticationError = StripeAuthenticationError;
/**
 * PermissionError is raised in cases where access was attempted on a resource
 * that wasn't allowed.
 */

var StripePermissionError = function (_StripeError5) {
  _inherits(StripePermissionError, _StripeError5);

  function StripePermissionError() {
    _classCallCheck(this, StripePermissionError);

    return _possibleConstructorReturn(this, (StripePermissionError.__proto__ || Object.getPrototypeOf(StripePermissionError)).apply(this, arguments));
  }

  return StripePermissionError;
}(StripeError);

exports.StripePermissionError = StripePermissionError;
/**
 * RateLimitError is raised in cases where an account is putting too much load
 * on Stripe's API servers (usually by performing too many requests). Please
 * back off on request rate.
 */

var StripeRateLimitError = function (_StripeError6) {
  _inherits(StripeRateLimitError, _StripeError6);

  function StripeRateLimitError() {
    _classCallCheck(this, StripeRateLimitError);

    return _possibleConstructorReturn(this, (StripeRateLimitError.__proto__ || Object.getPrototypeOf(StripeRateLimitError)).apply(this, arguments));
  }

  return StripeRateLimitError;
}(StripeError);

exports.StripeRateLimitError = StripeRateLimitError;
/**
 * StripeConnectionError is raised in the event that the SDK can't connect to
 * Stripe's servers. That can be for a variety of different reasons from a
 * downed network to a bad TLS certificate.
 */

var StripeConnectionError = function (_StripeError7) {
  _inherits(StripeConnectionError, _StripeError7);

  function StripeConnectionError() {
    _classCallCheck(this, StripeConnectionError);

    return _possibleConstructorReturn(this, (StripeConnectionError.__proto__ || Object.getPrototypeOf(StripeConnectionError)).apply(this, arguments));
  }

  return StripeConnectionError;
}(StripeError);

exports.StripeConnectionError = StripeConnectionError;
/**
 * SignatureVerificationError is raised when the signature verification for a
 * webhook fails
 */

var StripeSignatureVerificationError = function (_StripeError8) {
  _inherits(StripeSignatureVerificationError, _StripeError8);

  function StripeSignatureVerificationError(header, payload) {
    var raw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, StripeSignatureVerificationError);

    var _this9 = _possibleConstructorReturn(this, (StripeSignatureVerificationError.__proto__ || Object.getPrototypeOf(StripeSignatureVerificationError)).call(this, raw));

    _this9.header = header;
    _this9.payload = payload;
    return _this9;
  }

  return StripeSignatureVerificationError;
}(StripeError);

exports.StripeSignatureVerificationError = StripeSignatureVerificationError;
/**
 * IdempotencyError is raised in cases where an idempotency key was used
 * improperly.
 */

var StripeIdempotencyError = function (_StripeError9) {
  _inherits(StripeIdempotencyError, _StripeError9);

  function StripeIdempotencyError() {
    _classCallCheck(this, StripeIdempotencyError);

    return _possibleConstructorReturn(this, (StripeIdempotencyError.__proto__ || Object.getPrototypeOf(StripeIdempotencyError)).apply(this, arguments));
  }

  return StripeIdempotencyError;
}(StripeError);

exports.StripeIdempotencyError = StripeIdempotencyError;
/**
 * InvalidGrantError is raised when a specified code doesn't exist, is
 * expired, has been used, or doesn't belong to you; a refresh token doesn't
 * exist, or doesn't belong to you; or if an API key's mode (live or test)
 * doesn't match the mode of a code or refresh token.
 */

var StripeInvalidGrantError = function (_StripeError10) {
  _inherits(StripeInvalidGrantError, _StripeError10);

  function StripeInvalidGrantError() {
    _classCallCheck(this, StripeInvalidGrantError);

    return _possibleConstructorReturn(this, (StripeInvalidGrantError.__proto__ || Object.getPrototypeOf(StripeInvalidGrantError)).apply(this, arguments));
  }

  return StripeInvalidGrantError;
}(StripeError);

exports.StripeInvalidGrantError = StripeInvalidGrantError;
/**
 * Any other error from Stripe not specifically captured above
 */

var StripeUnknownError = function (_StripeError11) {
  _inherits(StripeUnknownError, _StripeError11);

  function StripeUnknownError() {
    _classCallCheck(this, StripeUnknownError);

    return _possibleConstructorReturn(this, (StripeUnknownError.__proto__ || Object.getPrototypeOf(StripeUnknownError)).apply(this, arguments));
  }

  return StripeUnknownError;
}(StripeError);

exports.StripeUnknownError = StripeUnknownError;
},{}],648:[function(require,module,exports) {
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */

module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
		return false;
	}
	if (typeof Symbol.iterator === 'symbol') {
		return true;
	}

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') {
		return false;
	}

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
		return false;
	}
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
		return false;
	}

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) {
		return false;
	} // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
		return false;
	}

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
		return false;
	}

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) {
		return false;
	}

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
		return false;
	}

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) {
			return false;
		}
	}

	return true;
};
},{}],561:[function(require,module,exports) {
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') {
		return false;
	}
	if (typeof Symbol !== 'function') {
		return false;
	}
	if (typeof origSymbol('foo') !== 'symbol') {
		return false;
	}
	if (typeof Symbol('bar') !== 'symbol') {
		return false;
	}

	return hasSymbolSham();
};
},{"./shams":648}],607:[function(require,module,exports) {
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],563:[function(require,module,exports) {
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":607}],566:[function(require,module,exports) {
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
},{"function-bind":563}],524:[function(require,module,exports) {
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

try {
	null.error; // eslint-disable-line no-unused-expressions
} catch (e) {
	// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
	var errorProto = getProto(getProto(e));
	INTRINSICS['%Error.prototype%'] = errorProto;
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"has-symbols":561,"function-bind":563,"has":566}],565:[function(require,module,exports) {
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":563,"get-intrinsic":524}],525:[function(require,module,exports) {
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"get-intrinsic":524,"./":565}],526:[function(require,module,exports) {
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = require('./util.inspect');
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}

},{"./util.inspect":383}],486:[function(require,module,exports) {
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bind/callBound');
var inspect = require('object-inspect');

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};

},{"get-intrinsic":524,"call-bind/callBound":525,"object-inspect":526}],449:[function(require,module,exports) {
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};
},{}],485:[function(require,module,exports) {
'use strict';

var formats = require('./formats');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}();

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (c === 0x2D // -
        || c === 0x2E // .
        || c === 0x5F // _
        || c === 0x7E // ~
        || c >= 0x30 && c <= 0x39 // 0-9
        || c >= 0x41 && c <= 0x5A // a-z
        || c >= 0x61 && c <= 0x7A // A-Z
        || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
        ) {
                out += string.charAt(i);
                continue;
            }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
            continue;
        }

        i += 1;
        c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};
},{"./formats":449}],447:[function(require,module,exports) {
'use strict';

var getSideChannel = require('side-channel');
var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'symbol' || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            if (generateArrayPrefix === 'comma' && encodeValuesOnly) {
                var valuesArray = split.call(String(obj), ',');
                var valuesJoined = '';
                for (var i = 0; i < valuesArray.length; ++i) {
                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults.encoder, charset, 'value', format));
                }
                return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? '[]' : '') + '=' + valuesJoined];
            }
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('â')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};
},{"side-channel":486,"./utils":485,"./formats":449}],448:[function(require,module,exports) {
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the â character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the â character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('â')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, 'value');
            });
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};
},{"./utils":485}],230:[function(require,module,exports) {
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};
},{"./stringify":447,"./parse":448,"./formats":449}],59:[function(require,module,exports) {
var process = require("process");
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
exports.concat = exports.determineProcessUserAgentProperties = exports.validateInteger = exports.flattenAndStringify = exports.isObject = exports.emitWarning = exports.pascalToCamelCase = exports.callbackifyPromiseWithTimeout = exports.normalizeHeader = exports.normalizeHeaders = exports.removeNullish = exports.protoExtend = exports.getOptionsFromArgs = exports.getDataFromArgs = exports.extractUrlParams = exports.makeURLInterpolator = exports.stringifyRequestData = exports.isOptionsHash = void 0;
var qs = require("qs");
var OPTIONS_KEYS = ['apiKey', 'idempotencyKey', 'stripeAccount', 'apiVersion', 'maxNetworkRetries', 'timeout', 'host'];
// const utils = {
function isOptionsHash(o) {
    return o && (typeof o === "undefined" ? "undefined" : _typeof(o)) === 'object' && OPTIONS_KEYS.some(function (prop) {
        return Object.prototype.hasOwnProperty.call(o, prop);
    });
}
exports.isOptionsHash = isOptionsHash;
/**
 * Stringifies an Object, accommodating nested objects
 * (forming the conventional key 'parent[child]=value')
 */
function stringifyRequestData(data) {
    return qs.stringify(data, {
        serializeDate: function serializeDate(d) {
            return Math.floor(d.getTime() / 1000).toString();
        }
    })
    // Don't use strict form encoding by changing the square bracket control
    // characters back to their literals. This is fine by the server, and
    // makes these parameter strings easier to read.
    .replace(/%5B/g, '[').replace(/%5D/g, ']');
}
exports.stringifyRequestData = stringifyRequestData;
/**
 * Outputs a new function with interpolated object property values.
 * Use like so:
 *   const fn = makeURLInterpolator('some/url/{param1}/{param2}');
 *   fn({ param1: 123, param2: 456 }); // => 'some/url/123/456'
 */
exports.makeURLInterpolator = function () {
    var rc = {
        '\n': '\\n',
        '"': '\\"',
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
    };
    return function (str) {
        var cleanString = str.replace(/["\n\r\u2028\u2029]/g, function ($0) {
            return rc[$0];
        });
        return function (outputs) {
            return cleanString.replace(/\{([\s\S]+?)\}/g, function ($0, $1) {
                return (
                    // @ts-ignore
                    encodeURIComponent(outputs[$1] || '')
                );
            });
        };
    };
}();
function extractUrlParams(path) {
    var params = path.match(/\{\w+\}/g);
    if (!params) {
        return [];
    }
    return params.map(function (param) {
        return param.replace(/[{}]/g, '');
    });
}
exports.extractUrlParams = extractUrlParams;
/**
 * Return the data argument from a list of arguments
 *
 * @param {object[]} args
 * @returns {object}
 */
function getDataFromArgs(args) {
    if (!Array.isArray(args) || !args[0] || _typeof(args[0]) !== 'object') {
        return {};
    }
    if (!isOptionsHash(args[0])) {
        return args.shift();
    }
    var argKeys = Object.keys(args[0]);
    var optionKeysInArgs = argKeys.filter(function (key) {
        return OPTIONS_KEYS.includes(key);
    });
    // In some cases options may be the provided as the first argument.
    // Here we're detecting a case where there are two distinct arguments
    // (the first being args and the second options) and with known
    // option keys in the first so that we can warn the user about it.
    if (optionKeysInArgs.length > 0 && optionKeysInArgs.length !== argKeys.length) {
        emitWarning("Options found in arguments (" + optionKeysInArgs.join(', ') + "). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.");
    }
    return {};
}
exports.getDataFromArgs = getDataFromArgs;
/**
 * Return the options hash from a list of arguments
 */
function getOptionsFromArgs(args) {
    var opts = {
        auth: null,
        host: null,
        headers: {},
        settings: {}
    };
    if (args.length > 0) {
        var arg = args[args.length - 1];
        if (typeof arg === 'string') {
            opts.auth = args.pop();
        } else if (isOptionsHash(arg)) {
            var params = Object.assign({}, args.pop());
            var extraKeys = Object.keys(params).filter(function (key) {
                return !OPTIONS_KEYS.includes(key);
            });
            if (extraKeys.length) {
                emitWarning("Invalid options found (" + extraKeys.join(', ') + "); ignoring.");
            }
            if (params.apiKey) {
                opts.auth = params.apiKey;
            }
            if (params.idempotencyKey) {
                opts.headers['Idempotency-Key'] = params.idempotencyKey;
            }
            if (params.stripeAccount) {
                opts.headers['Stripe-Account'] = params.stripeAccount;
            }
            if (params.apiVersion) {
                opts.headers['Stripe-Version'] = params.apiVersion;
            }
            if (Number.isInteger(params.maxNetworkRetries)) {
                opts.settings.maxNetworkRetries = params.maxNetworkRetries;
            }
            if (Number.isInteger(params.timeout)) {
                opts.settings.timeout = params.timeout;
            }
            if (params.host) {
                opts.host = params.host;
            }
        }
    }
    return opts;
}
exports.getOptionsFromArgs = getOptionsFromArgs;
/**
 * Provide simple "Class" extension mechanism.
 * <!-- Public API accessible via Stripe.StripeResource.extend -->
 */
function protoExtend(sub) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    var Super = this;
    var Constructor = Object.prototype.hasOwnProperty.call(sub, 'constructor') ? sub.constructor : function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        Super.apply(this, args);
    };
    // This initialization logic is somewhat sensitive to be compatible with
    // divergent JS implementations like the one found in Qt. See here for more
    // context:
    //
    // https://github.com/stripe/stripe-node/pull/334
    Object.assign(Constructor, Super);
    Constructor.prototype = Object.create(Super.prototype);
    Object.assign(Constructor.prototype, sub);
    return Constructor;
}
exports.protoExtend = protoExtend;
/**
 * Remove empty values from an object
 */
function removeNullish(obj) {
    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== 'object') {
        throw new Error('Argument must be an object');
    }
    return Object.keys(obj).reduce(function (result, key) {
        if (obj[key] != null) {
            result[key] = obj[key];
        }
        return result;
    }, {});
}
exports.removeNullish = removeNullish;
/**
 * Normalize standard HTTP Headers:
 * {'foo-bar': 'hi'}
 * becomes
 * {'Foo-Bar': 'hi'}
 */
function normalizeHeaders(obj) {
    if (!(obj && (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object')) {
        return obj;
    }
    return Object.keys(obj).reduce(function (result, header) {
        result[normalizeHeader(header)] = obj[header];
        return result;
    }, {});
}
exports.normalizeHeaders = normalizeHeaders;
/**
 * Stolen from https://github.com/marten-de-vries/header-case-normalizer/blob/master/index.js#L36-L41
 * without the exceptions which are irrelevant to us.
 */
function normalizeHeader(header) {
    return header.split('-').map(function (text) {
        return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();
    }).join('-');
}
exports.normalizeHeader = normalizeHeader;
function callbackifyPromiseWithTimeout(promise, callback) {
    if (callback) {
        // Ensure callback is called outside of promise stack.
        return promise.then(function (res) {
            setTimeout(function () {
                callback(null, res);
            }, 0);
        }, function (err) {
            setTimeout(function () {
                callback(err, null);
            }, 0);
        });
    }
    return promise;
}
exports.callbackifyPromiseWithTimeout = callbackifyPromiseWithTimeout;
/**
 * Allow for special capitalization cases (such as OAuth)
 */
function pascalToCamelCase(name) {
    if (name === 'OAuth') {
        return 'oauth';
    } else {
        return name[0].toLowerCase() + name.substring(1);
    }
}
exports.pascalToCamelCase = pascalToCamelCase;
function emitWarning(warning) {
    if (typeof process.emitWarning !== 'function') {
        return console.warn("Stripe: " + warning); /* eslint-disable-line no-console */
    }
    return process.emitWarning(warning, 'Stripe');
}
exports.emitWarning = emitWarning;
function isObject(obj) {
    var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
    return (type === 'function' || type === 'object') && !!obj;
}
exports.isObject = isObject;
// For use in multipart requests
function flattenAndStringify(data) {
    var result = {};
    var step = function step(obj, prevKey) {
        Object.keys(obj).forEach(function (key) {
            // @ts-ignore
            var value = obj[key];
            var newKey = prevKey ? prevKey + "[" + key + "]" : key;
            if (isObject(value)) {
                if (!(value instanceof Uint8Array) && !Object.prototype.hasOwnProperty.call(value, 'data')) {
                    // Non-buffer non-file Objects are recursively flattened
                    return step(value, newKey);
                } else {
                    // Buffers and file objects are stored without modification
                    result[newKey] = value;
                }
            } else {
                // Primitives are converted to strings
                result[newKey] = String(value);
            }
        });
    };
    step(data, null);
    return result;
}
exports.flattenAndStringify = flattenAndStringify;
function validateInteger(name, n, defaultVal) {
    if (!Number.isInteger(n)) {
        if (defaultVal !== undefined) {
            return defaultVal;
        } else {
            throw new Error(name + " must be an integer");
        }
    }
    return n;
}
exports.validateInteger = validateInteger;
function determineProcessUserAgentProperties() {
    return typeof process === 'undefined' ? {} : {
        lang_version: process.version,
        platform: process.platform
    };
}
exports.determineProcessUserAgentProperties = determineProcessUserAgentProperties;
/**
 * Joins an array of Uint8Arrays into a single Uint8Array
 */
function concat(arrays) {
    var totalLength = arrays.reduce(function (len, array) {
        return len + array.length;
    }, 0);
    var merged = new Uint8Array(totalLength);
    var offset = 0;
    arrays.forEach(function (array) {
        merged.set(array, offset);
        offset += array.length;
    });
    return merged;
}
exports.concat = concat;
},{"qs":230,"process":229}],39:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.NodePlatformFunctions = void 0;
var crypto = require("crypto");
var events_1 = require("events");
var NodeCryptoProvider_1 = require("../crypto/NodeCryptoProvider");
var NodeHttpClient_1 = require("../net/NodeHttpClient");
var PlatformFunctions_1 = require("./PlatformFunctions");
var Error_1 = require("../Error");
var utils_1 = require("../utils");
var child_process_1 = require("child_process");

var StreamProcessingError = function (_Error_1$StripeError) {
    _inherits(StreamProcessingError, _Error_1$StripeError);

    function StreamProcessingError() {
        _classCallCheck(this, StreamProcessingError);

        return _possibleConstructorReturn(this, (StreamProcessingError.__proto__ || Object.getPrototypeOf(StreamProcessingError)).apply(this, arguments));
    }

    return StreamProcessingError;
}(Error_1.StripeError);
/**
 * Specializes WebPlatformFunctions using APIs available in Node.js.
 */


var NodePlatformFunctions = function (_PlatformFunctions_1$) {
    _inherits(NodePlatformFunctions, _PlatformFunctions_1$);

    function NodePlatformFunctions() {
        _classCallCheck(this, NodePlatformFunctions);

        var _this2 = _possibleConstructorReturn(this, (NodePlatformFunctions.__proto__ || Object.getPrototypeOf(NodePlatformFunctions)).call(this));

        _this2._exec = child_process_1.exec;
        _this2._UNAME_CACHE = null;
        return _this2;
    }
    /** @override */


    _createClass(NodePlatformFunctions, [{
        key: "uuid4",
        value: function uuid4() {
            // available in: v14.17.x+
            if (crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return _get(NodePlatformFunctions.prototype.__proto__ || Object.getPrototypeOf(NodePlatformFunctions.prototype), "uuid4", this).call(this);
        }
        /**
         * @override
         * Node's built in `exec` function sometimes throws outright,
         * and sometimes has a callback with an error,
         * depending on the type of error.
         *
         * This unifies that interface by resolving with a null uname
         * if an error is encountered.
         */

    }, {
        key: "getUname",
        value: function getUname() {
            var _this3 = this;

            if (!this._UNAME_CACHE) {
                this._UNAME_CACHE = new Promise(function (resolve, reject) {
                    try {
                        _this3._exec('uname -a', function (err, uname) {
                            if (err) {
                                return resolve(null);
                            }
                            resolve(uname);
                        });
                    } catch (e) {
                        resolve(null);
                    }
                });
            }
            return this._UNAME_CACHE;
        }
        /**
         * @override
         * Secure compare, from https://github.com/freewil/scmp
         */

    }, {
        key: "secureCompare",
        value: function secureCompare(a, b) {
            if (!a || !b) {
                throw new Error('secureCompare must receive two arguments');
            }
            // return early here if buffer lengths are not equal since timingSafeEqual
            // will throw if buffer lengths are not equal
            if (a.length !== b.length) {
                return false;
            }
            // use crypto.timingSafeEqual if available (since Node.js v6.6.0),
            // otherwise use our own scmp-internal function.
            if (crypto.timingSafeEqual) {
                var textEncoder = new TextEncoder();
                var aEncoded = textEncoder.encode(a);
                var bEncoded = textEncoder.encode(b);
                return crypto.timingSafeEqual(aEncoded, bEncoded);
            }
            return _get(NodePlatformFunctions.prototype.__proto__ || Object.getPrototypeOf(NodePlatformFunctions.prototype), "secureCompare", this).call(this, a, b);
        }
    }, {
        key: "createEmitter",
        value: function createEmitter() {
            return new events_1.EventEmitter();
        }
        /** @override */

    }, {
        key: "tryBufferData",
        value: function tryBufferData(data) {
            if (!(data.file.data instanceof events_1.EventEmitter)) {
                return Promise.resolve(data);
            }
            var bufferArray = [];
            return new Promise(function (resolve, reject) {
                data.file.data.on('data', function (line) {
                    bufferArray.push(line);
                }).once('end', function () {
                    // @ts-ignore
                    var bufferData = Object.assign({}, data);
                    bufferData.file.data = (0, utils_1.concat)(bufferArray);
                    resolve(bufferData);
                }).on('error', function (err) {
                    reject(new StreamProcessingError({
                        message: 'An error occurred while attempting to process the file for upload.',
                        detail: err
                    }));
                });
            });
        }
        /** @override */

    }, {
        key: "createNodeHttpClient",
        value: function createNodeHttpClient(agent) {
            return new NodeHttpClient_1.NodeHttpClient(agent);
        }
        /** @override */

    }, {
        key: "createDefaultHttpClient",
        value: function createDefaultHttpClient() {
            return new NodeHttpClient_1.NodeHttpClient();
        }
        /** @override */

    }, {
        key: "createNodeCryptoProvider",
        value: function createNodeCryptoProvider() {
            return new NodeCryptoProvider_1.NodeCryptoProvider();
        }
        /** @override */

    }, {
        key: "createDefaultCryptoProvider",
        value: function createDefaultCryptoProvider() {
            return this.createNodeCryptoProvider();
        }
    }]);

    return NodePlatformFunctions;
}(PlatformFunctions_1.PlatformFunctions);

exports.NodePlatformFunctions = NodePlatformFunctions;
},{"crypto":377,"events":378,"../crypto/NodeCryptoProvider":374,"../net/NodeHttpClient":375,"./PlatformFunctions":376,"../Error":57,"../utils":59,"child_process":383}],231:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.resourceNamespace = void 0;
// ResourceNamespace allows you to create nested resources, i.e. `stripe.issuing.cards`.
// It also works recursively, so you could do i.e. `stripe.billing.invoicing.pay`.
function ResourceNamespace(stripe, resources) {
    for (var name in resources) {
        var camelCaseName = name[0].toLowerCase() + name.substring(1);
        var resource = new resources[name](stripe);
        this[camelCaseName] = resource;
    }
}
function resourceNamespace(namespace, resources) {
    return function (stripe) {
        return new ResourceNamespace(stripe, resources);
    };
}
exports.resourceNamespace = resourceNamespace;
},{}],450:[function(require,module,exports) {
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.makeAutoPaginationMethods = void 0;
var utils_1 = require("./utils");
function makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {
    var promiseCache = { currentPromise: null };
    var reverseIteration = isReverseIteration(requestArgs);
    var pagePromise = firstPagePromise;
    var i = 0;
    // Search and List methods iterate differently.
    // Search relies on a `next_page` token and can only iterate in one direction.
    // List relies on either an `ending_before` or `starting_after` field with
    // an item ID to paginate and is bi-directional.
    //
    // Please note: spec.methodType === 'search' is beta functionality and is
    // subject to change/removal at any time.
    var getNextPagePromise = void 0;
    if (spec.methodType === 'search') {
        getNextPagePromise = function getNextPagePromise(pageResult) {
            if (!pageResult.next_page) {
                throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');
            }
            return self._makeRequest(requestArgs, spec, {
                page: pageResult.next_page
            });
        };
    } else {
        getNextPagePromise = function getNextPagePromise(pageResult) {
            var lastId = getLastId(pageResult, reverseIteration);
            return self._makeRequest(requestArgs, spec, _defineProperty({}, reverseIteration ? 'ending_before' : 'starting_after', lastId));
        };
    }
    function iterate(pageResult) {
        if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {
            throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');
        }
        if (i < pageResult.data.length) {
            var idx = reverseIteration ? pageResult.data.length - 1 - i : i;
            var value = pageResult.data[idx];
            i += 1;
            return { value: value, done: false };
        } else if (pageResult.has_more) {
            // Reset counter, request next page, and recurse.
            i = 0;
            pagePromise = getNextPagePromise(pageResult);
            return pagePromise.then(iterate);
        }
        return { value: undefined, done: true };
    }
    function asyncIteratorNext() {
        return memoizedPromise(promiseCache, function (resolve, reject) {
            return pagePromise.then(iterate).then(resolve).catch(reject);
        });
    }
    var autoPagingEach = makeAutoPagingEach(asyncIteratorNext);
    var autoPagingToArray = makeAutoPagingToArray(autoPagingEach);
    var autoPaginationMethods = _defineProperty({
        autoPagingEach: autoPagingEach,
        autoPagingToArray: autoPagingToArray,
        // Async iterator functions:
        next: asyncIteratorNext,
        return: function _return() {
            // This is required for `break`.
            return {};
        }
    }, getAsyncIteratorSymbol(), function () {
        return autoPaginationMethods;
    });
    return autoPaginationMethods;
}
exports.makeAutoPaginationMethods = makeAutoPaginationMethods;
/**
 * ----------------
 * Private Helpers:
 * ----------------
 */
function getAsyncIteratorSymbol() {
    if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {
        return Symbol.asyncIterator;
    }
    // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1
    return '@@asyncIterator';
}
function getDoneCallback(args) {
    if (args.length < 2) {
        return null;
    }
    var onDone = args[1];
    if (typeof onDone !== 'function') {
        throw Error("The second argument to autoPagingEach, if present, must be a callback function; received " + (typeof onDone === "undefined" ? "undefined" : _typeof(onDone)));
    }
    return onDone;
}
/**
 * We allow four forms of the `onItem` callback (the middle two being equivalent),
 *
 *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`
 *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`
 *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`
 *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`
 *
 * In addition to standard validation, this helper
 * coalesces the former forms into the latter form.
 */
function getItemCallback(args) {
    if (args.length === 0) {
        return undefined;
    }
    var onItem = args[0];
    if (typeof onItem !== 'function') {
        throw Error("The first argument to autoPagingEach, if present, must be a callback function; received " + (typeof onItem === "undefined" ? "undefined" : _typeof(onItem)));
    }
    // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`
    if (onItem.length === 2) {
        return onItem;
    }
    if (onItem.length > 2) {
        throw Error("The `onItem` callback function passed to autoPagingEach must accept at most two arguments; got " + onItem);
    }
    // This magically handles all three of these usecases (the latter two being functionally identical):
    // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`
    // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`
    // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`
    return function _onItem(item, next) {
        var shouldContinue = onItem(item);
        next(shouldContinue);
    };
}
function getLastId(listResult, reverseIteration) {
    var lastIdx = reverseIteration ? 0 : listResult.data.length - 1;
    var lastItem = listResult.data[lastIdx];
    var lastId = lastItem && lastItem.id;
    if (!lastId) {
        throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');
    }
    return lastId;
}
/**
 * If a user calls `.next()` multiple times in parallel,
 * return the same result until something has resolved
 * to prevent page-turning race conditions.
 */
function memoizedPromise(promiseCache, cb) {
    if (promiseCache.currentPromise) {
        return promiseCache.currentPromise;
    }
    promiseCache.currentPromise = new Promise(cb).then(function (ret) {
        promiseCache.currentPromise = undefined;
        return ret;
    });
    return promiseCache.currentPromise;
}
function makeAutoPagingEach(asyncIteratorNext) {
    return function autoPagingEach() /* onItem?, onDone? */{
        var args = [].slice.call(arguments);
        var onItem = getItemCallback(args);
        var onDone = getDoneCallback(args);
        if (args.length > 2) {
            throw Error("autoPagingEach takes up to two arguments; received " + args);
        }
        var autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext,
        // @ts-ignore we might need a null check
        onItem);
        return (0, utils_1.callbackifyPromiseWithTimeout)(autoPagePromise, onDone);
    };
}
function makeAutoPagingToArray(autoPagingEach) {
    return function autoPagingToArray(opts, onDone) {
        var limit = opts && opts.limit;
        if (!limit) {
            throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');
        }
        if (limit > 10000) {
            throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');
        }
        var promise = new Promise(function (resolve, reject) {
            var items = [];
            autoPagingEach(function (item) {
                items.push(item);
                if (items.length >= limit) {
                    return false;
                }
            }).then(function () {
                resolve(items);
            }).catch(reject);
        });
        // @ts-ignore
        return (0, utils_1.callbackifyPromiseWithTimeout)(promise, onDone);
    };
}
function wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {
    return new Promise(function (resolve, reject) {
        function handleIteration(iterResult) {
            if (iterResult.done) {
                resolve();
                return;
            }
            var item = iterResult.value;
            return new Promise(function (next) {
                // Bit confusing, perhaps; we pass a `resolve` fn
                // to the user, so they can decide when and if to continue.
                // They can return false, or a promise which resolves to false, to break.
                onItem(item, next);
            }).then(function (shouldContinue) {
                if (shouldContinue === false) {
                    return handleIteration({ done: true });
                } else {
                    return asyncIteratorNext().then(handleIteration);
                }
            });
        }
        asyncIteratorNext().then(handleIteration).catch(reject);
    });
}
function isReverseIteration(requestArgs) {
    var args = [].slice.call(requestArgs);
    var dataFromArgs = (0, utils_1.getDataFromArgs)(args);
    return !!dataFromArgs.ending_before;
}
},{"./utils":59}],228:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.stripeMethod = void 0;
var utils_1 = require("./utils");
var autoPagination_1 = require("./autoPagination");
/**
 * Create an API method from the declared spec.
 *
 * @param [spec.method='GET'] Request Method (POST, GET, DELETE, PUT)
 * @param [spec.path=''] Path to be appended to the API BASE_PATH, joined with
 *  the instance's path (e.g. 'charges' or 'customers')
 * @param [spec.fullPath=''] Fully qualified path to the method (eg. /v1/a/b/c).
 *  If this is specified, path should not be specified.
 * @param [spec.urlParams=[]] Array of required arguments in the order that they
 *  must be passed by the consumer of the API. Subsequent optional arguments are
 *  optionally passed through a hash (Object) as the penultimate argument
 *  (preceding the also-optional callback argument
 * @param [spec.encode] Function for mutating input parameters to a method.
 *  Usefully for applying transforms to data on a per-method basis.
 * @param [spec.host] Hostname for the request.
 *
 * <!-- Public API accessible via Stripe.StripeResource.method -->
 */
function stripeMethod(spec) {
    if (spec.path !== undefined && spec.fullPath !== undefined) {
        throw new Error("Method spec specified both a 'path' (" + spec.path + ") and a 'fullPath' (" + spec.fullPath + ").");
    }
    return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var callback = typeof args[args.length - 1] == 'function' && args.pop();
        spec.urlParams = (0, utils_1.extractUrlParams)(spec.fullPath || this.createResourcePathWithSymbols(spec.path || ''));
        var requestPromise = (0, utils_1.callbackifyPromiseWithTimeout)(this._makeRequest(args, spec, {}), callback);
        // Please note `spec.methodType === 'search'` is beta functionality and this
        // interface is subject to change/removal at any time.
        if (spec.methodType === 'list' || spec.methodType === 'search') {
            var autoPaginationMethods = (0, autoPagination_1.makeAutoPaginationMethods)(this, args, spec, requestPromise);
            Object.assign(requestPromise, autoPaginationMethods);
        }
        return requestPromise;
    };
}
exports.stripeMethod = stripeMethod;
},{"./utils":59,"./autoPagination":450}],61:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StripeResource = void 0;
var utils_1 = require("./utils");
var StripeMethod_1 = require("./StripeMethod");
// Provide extension mechanism for Stripe Resource Sub-Classes
StripeResource.extend = utils_1.protoExtend;
// Expose method-creator
StripeResource.method = StripeMethod_1.stripeMethod;
StripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;
/**
 * Encapsulates request logic for a Stripe Resource
 */
function StripeResource(stripe, deprecatedUrlData) {
    this._stripe = stripe;
    if (deprecatedUrlData) {
        throw new Error('Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.');
    }
    this.basePath = (0, utils_1.makeURLInterpolator)(
    // @ts-ignore changing type of basePath
    this.basePath || stripe.getApiField('basePath'));
    // @ts-ignore changing type of path
    this.resourcePath = this.path;
    // @ts-ignore changing type of path
    this.path = (0, utils_1.makeURLInterpolator)(this.path);
    this.initialize.apply(this, arguments);
}
exports.StripeResource = StripeResource;
StripeResource.prototype = {
    _stripe: null,
    // @ts-ignore the type of path changes in ctor
    path: '',
    resourcePath: '',
    // Methods that don't use the API's default '/v1' path can override it with this setting.
    basePath: null,
    initialize: function initialize() {},

    // Function to override the default data processor. This allows full control
    // over how a StripeResource's request data will get converted into an HTTP
    // body. This is useful for non-standard HTTP requests. The function should
    // take method name, data, and headers as arguments.
    requestDataProcessor: null,
    // Function to add a validation checks before sending the request, errors should
    // be thrown, and they will be passed to the callback/promise.
    validateRequest: null,
    createFullPath: function createFullPath(commandPath, urlData) {
        var urlParts = [this.basePath(urlData), this.path(urlData)];
        if (typeof commandPath === 'function') {
            var computedCommandPath = commandPath(urlData);
            // If we have no actual command path, we just omit it to avoid adding a
            // trailing slash. This is important for top-level listing requests, which
            // do not have a command path.
            if (computedCommandPath) {
                urlParts.push(computedCommandPath);
            }
        } else {
            urlParts.push(commandPath);
        }
        return this._joinUrlParts(urlParts);
    },

    // Creates a relative resource path with symbols left in (unlike
    // createFullPath which takes some data to replace them with). For example it
    // might produce: /invoices/{id}
    createResourcePathWithSymbols: function createResourcePathWithSymbols(pathWithSymbols) {
        // If there is no path beyond the resource path, we want to produce just
        // /<resource path> rather than /<resource path>/.
        if (pathWithSymbols) {
            return "/" + this._joinUrlParts([this.resourcePath, pathWithSymbols]);
        } else {
            return "/" + this.resourcePath;
        }
    },
    _joinUrlParts: function _joinUrlParts(parts) {
        // Replace any accidentally doubled up slashes. This previously used
        // path.join, which would do this as well. Unfortunately we need to do this
        // as the functions for creating paths are technically part of the public
        // interface and so we need to preserve backwards compatibility.
        return parts.join('/').replace(/\/{2,}/g, '/');
    },
    _getRequestOpts: function _getRequestOpts(requestArgs, spec, overrideData) {
        // Extract spec values with defaults.
        var requestMethod = (spec.method || 'GET').toUpperCase();
        var urlParams = spec.urlParams || [];
        var encode = spec.encode || function (data) {
            return data;
        };
        var isUsingFullPath = !!spec.fullPath;
        var commandPath = (0, utils_1.makeURLInterpolator)(isUsingFullPath ? spec.fullPath : spec.path || '');
        // When using fullPath, we ignore the resource path as it should already be
        // fully qualified.
        var path = isUsingFullPath ? spec.fullPath : this.createResourcePathWithSymbols(spec.path);
        // Don't mutate args externally.
        var args = [].slice.call(requestArgs);
        // Generate and validate url params.
        var urlData = urlParams.reduce(function (urlData, param) {
            var arg = args.shift();
            if (typeof arg !== 'string') {
                throw new Error("Stripe: Argument \"" + param + "\" must be a string, but got: " + arg + " (on API request to `" + requestMethod + " " + path + "`)");
            }
            urlData[param] = arg;
            return urlData;
        }, {});
        // Pull request data and options (headers, auth) from args.
        var dataFromArgs = (0, utils_1.getDataFromArgs)(args);
        var data = encode(Object.assign({}, dataFromArgs, overrideData));
        var options = (0, utils_1.getOptionsFromArgs)(args);
        var host = options.host || spec.host;
        var streaming = !!spec.streaming;
        // Validate that there are no more args.
        if (args.filter(function (x) {
            return x != null;
        }).length) {
            throw new Error("Stripe: Unknown arguments (" + args + "). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to " + requestMethod + " `" + path + "`)");
        }
        // When using full path, we can just invoke the URL interpolator directly
        // as we don't need to use the resource to create a full path.
        var requestPath = isUsingFullPath ? commandPath(urlData) : this.createFullPath(commandPath, urlData);
        var headers = Object.assign(options.headers, spec.headers);
        if (spec.validator) {
            spec.validator(data, { headers: headers });
        }
        var dataInQuery = spec.method === 'GET' || spec.method === 'DELETE';
        var bodyData = dataInQuery ? {} : data;
        var queryData = dataInQuery ? data : {};
        return {
            requestMethod: requestMethod,
            requestPath: requestPath,
            bodyData: bodyData,
            queryData: queryData,
            auth: options.auth,
            headers: headers,
            host: host !== null && host !== void 0 ? host : null,
            streaming: streaming,
            settings: options.settings
        };
    },
    _makeRequest: function _makeRequest(requestArgs, spec, overrideData) {
        var _this = this;

        return new Promise(function (resolve, reject) {
            var _a;
            var opts = void 0;
            try {
                opts = _this._getRequestOpts(requestArgs, spec, overrideData);
            } catch (err) {
                reject(err);
                return;
            }
            function requestCallback(err, response) {
                if (err) {
                    reject(err);
                } else {
                    resolve(spec.transformResponseData ? spec.transformResponseData(response) : response);
                }
            }
            var emptyQuery = Object.keys(opts.queryData).length === 0;
            var path = [opts.requestPath, emptyQuery ? '' : '?', (0, utils_1.stringifyRequestData)(opts.queryData)].join('');
            var _opts = opts,
                headers = _opts.headers,
                settings = _opts.settings;

            _this._stripe._requestSender._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.auth, { headers: headers, settings: settings, streaming: opts.streaming }, requestCallback, (_a = _this.requestDataProcessor) === null || _a === void 0 ? void 0 : _a.bind(_this));
        });
    }
};
},{"./utils":59,"./StripeMethod":228}],277:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Accounts = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Accounts = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/accounts/{account}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/accounts',
        methodType: 'list'
    }),
    disconnect: stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/accounts/{account}/disconnect'
    }),
    listOwners: stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/accounts/{account}/owners',
        methodType: 'list'
    }),
    refresh: stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/accounts/{account}/refresh'
    })
});
},{"../../StripeResource":61}],278:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Authorizations = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Authorizations = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/authorizations/{authorization}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/authorizations/{authorization}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/authorizations',
        methodType: 'list'
    }),
    approve: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/authorizations/{authorization}/approve'
    }),
    decline: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/authorizations/{authorization}/decline'
    })
});
},{"../../StripeResource":61}],280:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Cardholders = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Cardholders = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/cardholders'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/cardholders/{cardholder}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/cardholders/{cardholder}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/cardholders',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],313:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Cards = void 0;
var StripeResource_1 = require("../../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Cards = StripeResource_1.StripeResource.extend({
    deliverCard: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/deliver'
    }),
    failCard: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/fail'
    }),
    returnCard: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/return'
    }),
    shipCard: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/ship'
    })
});
},{"../../../StripeResource":61}],279:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Cards = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Cards = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/cards'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/cards/{card}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/cards/{card}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/cards',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],282:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Configurations = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Configurations = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing_portal/configurations'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/billing_portal/configurations/{configuration}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing_portal/configurations/{configuration}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/billing_portal/configurations',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],281:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Configurations = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Configurations = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/configurations'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/configurations/{configuration}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/configurations/{configuration}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/configurations',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/terminal/configurations/{configuration}'
    })
});
},{"../../StripeResource":61}],283:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionTokens = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ConnectionTokens = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/connection_tokens'
    })
});
},{"../../StripeResource":61}],285:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.CreditReversals = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.CreditReversals = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/credit_reversals'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/credit_reversals/{credit_reversal}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/credit_reversals',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],284:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Customers = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Customers = StripeResource_1.StripeResource.extend({
    fundCashBalance: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/customers/{customer}/fund_cash_balance'
    })
});
},{"../../StripeResource":61}],286:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.DebitReversals = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.DebitReversals = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/debit_reversals'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/debit_reversals/{debit_reversal}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/debit_reversals',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],291:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Disputes = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Disputes = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/disputes'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/disputes/{dispute}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/disputes/{dispute}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/disputes',
        methodType: 'list'
    }),
    submit: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/disputes/{dispute}/submit'
    })
});
},{"../../StripeResource":61}],289:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.EarlyFraudWarnings = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.EarlyFraudWarnings = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/early_fraud_warnings/{early_fraud_warning}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/early_fraud_warnings',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],290:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.FinancialAccounts = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.FinancialAccounts = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/financial_accounts'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/financial_accounts',
        methodType: 'list'
    }),
    retrieveFeatures: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}/features'
    }),
    updateFeatures: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}/features'
    })
});
},{"../../StripeResource":61}],314:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.InboundTransfers = void 0;
var StripeResource_1 = require("../../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.InboundTransfers = StripeResource_1.StripeResource.extend({
    fail: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/inbound_transfers/{id}/fail'
    }),
    returnInboundTransfer: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/inbound_transfers/{id}/return'
    }),
    succeed: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/inbound_transfers/{id}/succeed'
    })
});
},{"../../../StripeResource":61}],287:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.InboundTransfers = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.InboundTransfers = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/inbound_transfers'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/inbound_transfers/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/inbound_transfers',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/inbound_transfers/{inbound_transfer}/cancel'
    })
});
},{"../../StripeResource":61}],288:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Locations = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Locations = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/locations'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/locations/{location}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/locations/{location}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/locations',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/terminal/locations/{location}'
    })
});
},{"../../StripeResource":61}],315:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutboundPayments = void 0;
var StripeResource_1 = require("../../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.OutboundPayments = StripeResource_1.StripeResource.extend({
    fail: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_payments/{id}/fail'
    }),
    post: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_payments/{id}/post'
    }),
    returnOutboundPayment: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_payments/{id}/return'
    })
});
},{"../../../StripeResource":61}],293:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutboundPayments = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.OutboundPayments = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_payments'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_payments/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_payments',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_payments/{id}/cancel'
    })
});
},{"../../StripeResource":61}],317:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutboundTransfers = void 0;
var StripeResource_1 = require("../../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.OutboundTransfers = StripeResource_1.StripeResource.extend({
    fail: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail'
    }),
    post: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post'
    }),
    returnOutboundTransfer: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return'
    })
});
},{"../../../StripeResource":61}],294:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutboundTransfers = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.OutboundTransfers = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_transfers'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_transfers/{outbound_transfer}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_transfers',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_transfers/{outbound_transfer}/cancel'
    })
});
},{"../../StripeResource":61}],316:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Readers = void 0;
var StripeResource_1 = require("../../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Readers = StripeResource_1.StripeResource.extend({
    presentPaymentMethod: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/terminal/readers/{reader}/present_payment_method'
    })
});
},{"../../../StripeResource":61}],292:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Readers = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Readers = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/readers/{reader}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/readers',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/terminal/readers/{reader}'
    }),
    cancelAction: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/cancel_action'
    }),
    processPaymentIntent: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/process_payment_intent'
    }),
    processSetupIntent: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/process_setup_intent'
    }),
    refundPayment: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/refund_payment'
    }),
    setReaderDisplay: stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/set_reader_display'
    })
});
},{"../../StripeResource":61}],318:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceivedCredits = void 0;
var StripeResource_1 = require("../../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ReceivedCredits = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/received_credits'
    })
});
},{"../../../StripeResource":61}],295:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceivedCredits = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ReceivedCredits = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_credits/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_credits',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],319:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceivedDebits = void 0;
var StripeResource_1 = require("../../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ReceivedDebits = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/received_debits'
    })
});
},{"../../../StripeResource":61}],297:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceivedDebits = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ReceivedDebits = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_debits/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_debits',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],296:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Refunds = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Refunds = StripeResource_1.StripeResource.extend({
    expire: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/refunds/{refund}/expire'
    })
});
},{"../../StripeResource":61}],298:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportRuns = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ReportRuns = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/reporting/report_runs'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_runs/{report_run}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_runs',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],299:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportTypes = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ReportTypes = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_types/{report_type}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_types',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],300:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduledQueryRuns = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ScheduledQueryRuns = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/sigma/scheduled_query_runs/{scheduled_query_run}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/sigma/scheduled_query_runs',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],312:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Secrets = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Secrets = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/apps/secrets'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/apps/secrets',
        methodType: 'list'
    }),
    deleteWhere: stripeMethod({
        method: 'POST',
        fullPath: '/v1/apps/secrets/delete'
    }),
    find: stripeMethod({
        method: 'GET',
        fullPath: '/v1/apps/secrets/find'
    })
});
},{"../../StripeResource":61}],301:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Sessions = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Sessions = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing_portal/sessions'
    })
});
},{"../../StripeResource":61}],302:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Sessions = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Sessions = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/checkout/sessions'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/checkout/sessions/{session}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/checkout/sessions',
        methodType: 'list'
    }),
    expire: stripeMethod({
        method: 'POST',
        fullPath: '/v1/checkout/sessions/{session}/expire'
    }),
    listLineItems: stripeMethod({
        method: 'GET',
        fullPath: '/v1/checkout/sessions/{session}/line_items',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],303:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Sessions = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Sessions = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/sessions'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/sessions/{session}'
    })
});
},{"../../StripeResource":61}],304:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.TestClocks = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.TestClocks = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/test_clocks'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/test_helpers/test_clocks/{test_clock}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/test_helpers/test_clocks',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/test_helpers/test_clocks/{test_clock}'
    }),
    advance: stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/test_clocks/{test_clock}/advance'
    })
});
},{"../../StripeResource":61}],305:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionEntries = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.TransactionEntries = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transaction_entries/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transaction_entries',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],306:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Transactions = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Transactions = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/transactions/{transaction}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/transactions/{transaction}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/transactions',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],307:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Transactions = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Transactions = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transactions/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transactions',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],308:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueListItems = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ValueListItems = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/radar/value_list_items'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_list_items/{item}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_list_items',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/radar/value_list_items/{item}'
    })
});
},{"../../StripeResource":61}],309:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueLists = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ValueLists = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/radar/value_lists'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_lists/{value_list}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/radar/value_lists/{value_list}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_lists',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/radar/value_lists/{value_list}'
    })
});
},{"../../StripeResource":61}],310:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.VerificationReports = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.VerificationReports = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_reports/{report}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_reports',
        methodType: 'list'
    })
});
},{"../../StripeResource":61}],311:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.VerificationSessions = void 0;
var StripeResource_1 = require("../../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.VerificationSessions = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_sessions/{session}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions/{session}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_sessions',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions/{session}/cancel'
    }),
    redact: stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions/{session}/redact'
    })
});
},{"../../StripeResource":61}],232:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

Object.defineProperty(exports, "__esModule", { value: true });
exports.Accounts = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
// Since path can either be `account` or `accounts`, support both through stripeMethod path;
exports.Accounts = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts'
    }),
    retrieve: function retrieve(id) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        // No longer allow an api key to be passed as the first string to this function due to ambiguity between
        // old account ids and api keys. To request the account for an api key, send null as the id
        if (typeof id === 'string') {
            return stripeMethod({
                method: 'GET',
                fullPath: '/v1/accounts/{id}'
            }).apply(this, [id].concat(_toConsumableArray(args)));
        } else {
            if (id === null || id === undefined) {
                // Remove id as stripeMethod would complain of unexpected argument
                [].shift.apply([id].concat(_toConsumableArray(args)));
            }
            return stripeMethod({
                method: 'GET',
                fullPath: '/v1/account'
            }).apply(this, [id].concat(_toConsumableArray(args)));
        }
    },

    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/accounts/{account}'
    }),
    createExternalAccount: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/external_accounts'
    }),
    createLoginLink: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/login_links'
    }),
    createPerson: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/persons'
    }),
    deleteExternalAccount: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/accounts/{account}/external_accounts/{id}'
    }),
    deletePerson: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/accounts/{account}/persons/{person}'
    }),
    listCapabilities: stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/capabilities',
        methodType: 'list'
    }),
    listExternalAccounts: stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/external_accounts',
        methodType: 'list'
    }),
    listPersons: stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/persons',
        methodType: 'list'
    }),
    reject: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/reject'
    }),
    retrieveCapability: stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/capabilities/{capability}'
    }),
    retrieveExternalAccount: stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/external_accounts/{id}'
    }),
    retrievePerson: stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/persons/{person}'
    }),
    updateCapability: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/capabilities/{capability}'
    }),
    updateExternalAccount: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/external_accounts/{id}'
    }),
    updatePerson: stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/persons/{person}'
    })
});
},{"../StripeResource":61}],233:[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth = void 0;
var StripeResource_1 = require("../StripeResource");
var utils_1 = require("../utils");
var stripeMethod = StripeResource_1.StripeResource.method;
var oAuthHost = 'connect.stripe.com';
exports.OAuth = StripeResource_1.StripeResource.extend({
    basePath: '/',
    authorizeUrl: function authorizeUrl(params, options) {
        params = params || {};
        options = options || {};
        var path = 'oauth/authorize';
        // For Express accounts, the path changes
        if (options.express) {
            path = "express/" + path;
        }
        if (!params.response_type) {
            params.response_type = 'code';
        }
        if (!params.client_id) {
            params.client_id = this._stripe.getClientId();
        }
        if (!params.scope) {
            params.scope = 'read_write';
        }
        return "https://" + oAuthHost + "/" + path + "?" + (0, utils_1.stringifyRequestData)(params);
    },

    token: stripeMethod({
        method: 'POST',
        path: 'oauth/token',
        host: oAuthHost
    }),
    deauthorize: function deauthorize(spec) {
        if (!spec.client_id) {
            spec.client_id = this._stripe.getClientId();
        }

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        return stripeMethod({
            method: 'POST',
            path: 'oauth/deauthorize',
            host: oAuthHost
        }).apply(this, [spec].concat(_toConsumableArray(args)));
    }
});
},{"../StripeResource":61,"../utils":59}],234:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountLinks = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.AccountLinks = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/account_links'
    })
});
},{"../StripeResource":61}],236:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplePayDomains = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ApplePayDomains = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/apple_pay/domains'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/apple_pay/domains/{domain}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/apple_pay/domains',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/apple_pay/domains/{domain}'
    })
});
},{"../StripeResource":61}],235:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationFees = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ApplicationFees = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees',
        methodType: 'list'
    }),
    createRefund: stripeMethod({
        method: 'POST',
        fullPath: '/v1/application_fees/{id}/refunds'
    }),
    listRefunds: stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees/{id}/refunds',
        methodType: 'list'
    }),
    retrieveRefund: stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees/{fee}/refunds/{id}'
    }),
    updateRefund: stripeMethod({
        method: 'POST',
        fullPath: '/v1/application_fees/{fee}/refunds/{id}'
    })
});
},{"../StripeResource":61}],237:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Balance = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Balance = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/balance'
    })
});
},{"../StripeResource":61}],238:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceTransactions = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.BalanceTransactions = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/balance_transactions/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/balance_transactions',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],239:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Charges = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Charges = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/charges'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/charges/{charge}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/charges/{charge}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/charges',
        methodType: 'list'
    }),
    capture: stripeMethod({
        method: 'POST',
        fullPath: '/v1/charges/{charge}/capture'
    }),
    search: stripeMethod({
        method: 'GET',
        fullPath: '/v1/charges/search',
        methodType: 'search'
    })
});
},{"../StripeResource":61}],240:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.CountrySpecs = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.CountrySpecs = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/country_specs/{country}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/country_specs',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],243:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Coupons = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Coupons = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/coupons'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/coupons/{coupon}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/coupons/{coupon}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/coupons',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/coupons/{coupon}'
    })
});
},{"../StripeResource":61}],241:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.CreditNotes = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.CreditNotes = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/credit_notes'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes/{id}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/credit_notes/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes',
        methodType: 'list'
    }),
    listLineItems: stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes/{credit_note}/lines',
        methodType: 'list'
    }),
    listPreviewLineItems: stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes/preview/lines',
        methodType: 'list'
    }),
    preview: stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes/preview'
    }),
    voidCreditNote: stripeMethod({
        method: 'POST',
        fullPath: '/v1/credit_notes/{id}/void'
    })
});
},{"../StripeResource":61}],242:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Customers = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Customers = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/customers/{customer}'
    }),
    createFundingInstructions: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/funding_instructions'
    }),
    createBalanceTransaction: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/balance_transactions'
    }),
    createSource: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/sources'
    }),
    createTaxId: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/tax_ids'
    }),
    deleteDiscount: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/customers/{customer}/discount'
    }),
    deleteSource: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/customers/{customer}/sources/{id}'
    }),
    deleteTaxId: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/customers/{customer}/tax_ids/{id}'
    }),
    listPaymentMethods: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/payment_methods',
        methodType: 'list'
    }),
    listBalanceTransactions: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/balance_transactions',
        methodType: 'list'
    }),
    listCashBalanceTransactions: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/cash_balance_transactions',
        methodType: 'list'
    }),
    listSources: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/sources',
        methodType: 'list'
    }),
    listTaxIds: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/tax_ids',
        methodType: 'list'
    }),
    retrievePaymentMethod: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/payment_methods/{payment_method}'
    }),
    retrieveBalanceTransaction: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/balance_transactions/{transaction}'
    }),
    retrieveCashBalance: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/cash_balance'
    }),
    retrieveCashBalanceTransaction: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/cash_balance_transactions/{transaction}'
    }),
    retrieveSource: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/sources/{id}'
    }),
    retrieveTaxId: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/tax_ids/{id}'
    }),
    search: stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/search',
        methodType: 'search'
    }),
    updateBalanceTransaction: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/balance_transactions/{transaction}'
    }),
    updateCashBalance: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/cash_balance'
    }),
    updateSource: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/sources/{id}'
    }),
    verifySource: stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/sources/{id}/verify'
    })
});
},{"../StripeResource":61}],244:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Disputes = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Disputes = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/disputes/{dispute}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/disputes/{dispute}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/disputes',
        methodType: 'list'
    }),
    close: stripeMethod({
        method: 'POST',
        fullPath: '/v1/disputes/{dispute}/close'
    })
});
},{"../StripeResource":61}],245:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.EphemeralKeys = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.EphemeralKeys = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/ephemeral_keys',
        validator: function validator(data, options) {
            if (!options.headers || !options.headers['Stripe-Version']) {
                throw new Error('Passing apiVersion in a separate options hash is required to create an ephemeral key. See https://stripe.com/docs/api/versioning?lang=node');
            }
        }
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/ephemeral_keys/{key}'
    })
});
},{"../StripeResource":61}],246:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Events = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/events/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/events',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],247:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExchangeRates = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ExchangeRates = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/exchange_rates/{rate_id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/exchange_rates',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],451:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.multipartRequestDataProcessor = void 0;
var utils_1 = require("./utils");
// Method for formatting HTTP body for the multipart/form-data specification
// Mostly taken from Fermata.js
// https://github.com/natevw/fermata/blob/5d9732a33d776ce925013a265935facd1626cc88/fermata.js#L315-L343
var multipartDataGenerator = function multipartDataGenerator(method, data, headers) {
    var segno = (Math.round(Math.random() * 1e16) + Math.round(Math.random() * 1e16)).toString();
    headers['Content-Type'] = "multipart/form-data; boundary=" + segno;
    var textEncoder = new TextEncoder();
    var buffer = new Uint8Array(0);
    var endBuffer = textEncoder.encode('\r\n');
    function push(l) {
        var prevBuffer = buffer;
        var newBuffer = l instanceof Uint8Array ? l : new Uint8Array(textEncoder.encode(l));
        buffer = new Uint8Array(prevBuffer.length + newBuffer.length + 2);
        buffer.set(prevBuffer);
        buffer.set(newBuffer, prevBuffer.length);
        buffer.set(endBuffer, buffer.length - 2);
    }
    function q(s) {
        return "\"" + s.replace(/"|"/g, '%22').replace(/\r\n|\r|\n/g, ' ') + "\"";
    }
    var flattenedData = (0, utils_1.flattenAndStringify)(data);
    for (var k in flattenedData) {
        var v = flattenedData[k];
        push("--" + segno);
        if (Object.prototype.hasOwnProperty.call(v, 'data')) {
            var typedEntry = v;
            push("Content-Disposition: form-data; name=" + q(k) + "; filename=" + q(typedEntry.name || 'blob'));
            push("Content-Type: " + (typedEntry.type || 'application/octet-stream'));
            push('');
            push(typedEntry.data);
        } else {
            push("Content-Disposition: form-data; name=" + q(k));
            push('');
            push(v);
        }
    }
    push("--" + segno + "--");
    return buffer;
};
function multipartRequestDataProcessor(method, data, headers, callback) {
    data = data || {};
    if (method !== 'POST') {
        return callback(null, (0, utils_1.stringifyRequestData)(data));
    }
    this._stripe._platformFunctions.tryBufferData(data).then(function (bufferedData) {
        var buffer = multipartDataGenerator(method, bufferedData, headers);
        return callback(null, buffer);
    }).catch(function (err) {
        return callback(err, null);
    });
}
exports.multipartRequestDataProcessor = multipartRequestDataProcessor;
},{"./utils":59}],249:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Files = void 0;
var multipart_1 = require("../multipart");
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Files = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/files',
        headers: {
            'Content-Type': 'multipart/form-data'
        },
        host: 'files.stripe.com'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/files/{file}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/files',
        methodType: 'list'
    }),
    requestDataProcessor: multipart_1.multipartRequestDataProcessor
});
},{"../multipart":451,"../StripeResource":61}],248:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.FileLinks = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.FileLinks = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/file_links'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/file_links/{link}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/file_links/{link}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/file_links',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],250:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Invoices = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Invoices = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/{invoice}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/invoices/{invoice}'
    }),
    finalizeInvoice: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/finalize'
    }),
    listLineItems: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/{invoice}/lines',
        methodType: 'list'
    }),
    listUpcomingLines: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/upcoming/lines',
        methodType: 'list'
    }),
    markUncollectible: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/mark_uncollectible'
    }),
    pay: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/pay'
    }),
    retrieveUpcoming: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/upcoming'
    }),
    search: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/search',
        methodType: 'search'
    }),
    sendInvoice: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/send'
    }),
    voidInvoice: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/void'
    })
});
},{"../StripeResource":61}],251:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.InvoiceItems = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.InvoiceItems = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoiceitems'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoiceitems/{invoiceitem}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoiceitems/{invoiceitem}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoiceitems',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/invoiceitems/{invoiceitem}'
    })
});
},{"../StripeResource":61}],252:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mandates = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Mandates = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/mandates/{mandate}'
    })
});
},{"../StripeResource":61}],254:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentIntents = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.PaymentIntents = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_intents/{intent}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_intents',
        methodType: 'list'
    }),
    applyCustomerBalance: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/apply_customer_balance'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/cancel'
    }),
    capture: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/capture'
    }),
    confirm: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/confirm'
    }),
    incrementAuthorization: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/increment_authorization'
    }),
    search: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_intents/search',
        methodType: 'search'
    }),
    verifyMicrodeposits: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/verify_microdeposits'
    })
});
},{"../StripeResource":61}],253:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentLinks = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.PaymentLinks = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_links'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_links/{payment_link}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_links/{payment_link}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_links',
        methodType: 'list'
    }),
    listLineItems: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_links/{payment_link}/line_items',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],255:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentMethods = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.PaymentMethods = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_methods'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_methods/{payment_method}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_methods/{payment_method}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_methods',
        methodType: 'list'
    }),
    attach: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_methods/{payment_method}/attach'
    }),
    detach: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_methods/{payment_method}/detach'
    })
});
},{"../StripeResource":61}],256:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Payouts = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Payouts = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payouts'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payouts/{payout}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payouts/{payout}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/payouts',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payouts/{payout}/cancel'
    }),
    reverse: stripeMethod({
        method: 'POST',
        fullPath: '/v1/payouts/{payout}/reverse'
    })
});
},{"../StripeResource":61}],257:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Plans = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Plans = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/plans'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/plans/{plan}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/plans/{plan}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/plans',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/plans/{plan}'
    })
});
},{"../StripeResource":61}],259:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Prices = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Prices = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/prices'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/prices/{price}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/prices/{price}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/prices',
        methodType: 'list'
    }),
    search: stripeMethod({
        method: 'GET',
        fullPath: '/v1/prices/search',
        methodType: 'search'
    })
});
},{"../StripeResource":61}],258:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Products = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Products = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/products'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/products/{id}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/products/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/products',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/products/{id}'
    }),
    search: stripeMethod({
        method: 'GET',
        fullPath: '/v1/products/search',
        methodType: 'search'
    })
});
},{"../StripeResource":61}],260:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.PromotionCodes = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.PromotionCodes = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/promotion_codes'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/promotion_codes/{promotion_code}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/promotion_codes/{promotion_code}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/promotion_codes',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],261:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Quotes = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Quotes = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/quotes'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes/{quote}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/quotes/{quote}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes',
        methodType: 'list'
    }),
    accept: stripeMethod({
        method: 'POST',
        fullPath: '/v1/quotes/{quote}/accept'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/quotes/{quote}/cancel'
    }),
    finalizeQuote: stripeMethod({
        method: 'POST',
        fullPath: '/v1/quotes/{quote}/finalize'
    }),
    listComputedUpfrontLineItems: stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes/{quote}/computed_upfront_line_items',
        methodType: 'list'
    }),
    listLineItems: stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes/{quote}/line_items',
        methodType: 'list'
    }),
    pdf: stripeMethod({
        host: 'files.stripe.com',
        method: 'GET',
        fullPath: '/v1/quotes/{quote}/pdf',
        streaming: true
    })
});
},{"../StripeResource":61}],262:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Refunds = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Refunds = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/refunds'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/refunds/{refund}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/refunds/{refund}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/refunds',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/refunds/{refund}/cancel'
    })
});
},{"../StripeResource":61}],263:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Reviews = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Reviews = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/reviews/{review}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/reviews',
        methodType: 'list'
    }),
    approve: stripeMethod({
        method: 'POST',
        fullPath: '/v1/reviews/{review}/approve'
    })
});
},{"../StripeResource":61}],264:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.SetupAttempts = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.SetupAttempts = StripeResource_1.StripeResource.extend({
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/setup_attempts',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],265:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.SetupIntents = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.SetupIntents = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/setup_intents/{intent}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/setup_intents',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}/cancel'
    }),
    confirm: stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}/confirm'
    }),
    verifyMicrodeposits: stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}/verify_microdeposits'
    })
});
},{"../StripeResource":61}],266:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShippingRates = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.ShippingRates = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/shipping_rates'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/shipping_rates/{shipping_rate_token}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/shipping_rates/{shipping_rate_token}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/shipping_rates',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],267:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Sources = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Sources = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/sources'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/sources/{source}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/sources/{source}'
    }),
    listSourceTransactions: stripeMethod({
        method: 'GET',
        fullPath: '/v1/sources/{source}/source_transactions',
        methodType: 'list'
    }),
    verify: stripeMethod({
        method: 'POST',
        fullPath: '/v1/sources/{source}/verify'
    })
});
},{"../StripeResource":61}],268:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscriptions = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Subscriptions = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscriptions'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscriptions',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}'
    }),
    deleteDiscount: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}/discount'
    }),
    resume: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscriptions/{subscription}/resume'
    }),
    search: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscriptions/search',
        methodType: 'search'
    })
});
},{"../StripeResource":61}],269:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionItems = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.SubscriptionItems = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_items'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_items/{item}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_items/{item}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_items',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/subscription_items/{item}'
    }),
    createUsageRecord: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_items/{subscription_item}/usage_records'
    }),
    listUsageRecordSummaries: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_items/{subscription_item}/usage_record_summaries',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],270:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionSchedules = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.SubscriptionSchedules = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_schedules/{schedule}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules/{schedule}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_schedules',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules/{schedule}/cancel'
    }),
    release: stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules/{schedule}/release'
    })
});
},{"../StripeResource":61}],271:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.TaxCodes = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.TaxCodes = StripeResource_1.StripeResource.extend({
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax_codes/{id}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax_codes',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],272:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.TaxRates = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.TaxRates = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/tax_rates'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax_rates/{tax_rate}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/tax_rates/{tax_rate}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax_rates',
        methodType: 'list'
    })
});
},{"../StripeResource":61}],273:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tokens = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Tokens = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/tokens'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/tokens/{token}'
    })
});
},{"../StripeResource":61}],274:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Topups = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Topups = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/topups'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/topups/{topup}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/topups/{topup}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/topups',
        methodType: 'list'
    }),
    cancel: stripeMethod({
        method: 'POST',
        fullPath: '/v1/topups/{topup}/cancel'
    })
});
},{"../StripeResource":61}],275:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.Transfers = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.Transfers = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/transfers'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/transfers/{transfer}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/transfers/{transfer}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/transfers',
        methodType: 'list'
    }),
    createReversal: stripeMethod({
        method: 'POST',
        fullPath: '/v1/transfers/{id}/reversals'
    }),
    listReversals: stripeMethod({
        method: 'GET',
        fullPath: '/v1/transfers/{id}/reversals',
        methodType: 'list'
    }),
    retrieveReversal: stripeMethod({
        method: 'GET',
        fullPath: '/v1/transfers/{transfer}/reversals/{id}'
    }),
    updateReversal: stripeMethod({
        method: 'POST',
        fullPath: '/v1/transfers/{transfer}/reversals/{id}'
    })
});
},{"../StripeResource":61}],276:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookEndpoints = void 0;
var StripeResource_1 = require("../StripeResource");
var stripeMethod = StripeResource_1.StripeResource.method;
exports.WebhookEndpoints = StripeResource_1.StripeResource.extend({
    create: stripeMethod({
        method: 'POST',
        fullPath: '/v1/webhook_endpoints'
    }),
    retrieve: stripeMethod({
        method: 'GET',
        fullPath: '/v1/webhook_endpoints/{webhook_endpoint}'
    }),
    update: stripeMethod({
        method: 'POST',
        fullPath: '/v1/webhook_endpoints/{webhook_endpoint}'
    }),
    list: stripeMethod({
        method: 'GET',
        fullPath: '/v1/webhook_endpoints',
        methodType: 'list'
    }),
    del: stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/webhook_endpoints/{webhook_endpoint}'
    })
});
},{"../StripeResource":61}],58:[function(require,module,exports) {
// File generated from our OpenAPI spec
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.FinancialConnections = exports.Checkout = exports.BillingPortal = exports.Apps = exports.WebhookEndpoints = exports.Transfers = exports.Topups = exports.Tokens = exports.TaxRates = exports.TaxCodes = exports.SubscriptionSchedules = exports.SubscriptionItems = exports.Subscriptions = exports.Sources = exports.ShippingRates = exports.SetupIntents = exports.SetupAttempts = exports.Reviews = exports.Refunds = exports.Quotes = exports.PromotionCodes = exports.Products = exports.Prices = exports.Plans = exports.Payouts = exports.PaymentMethods = exports.PaymentLinks = exports.PaymentIntents = exports.Mandates = exports.InvoiceItems = exports.Invoices = exports.FileLinks = exports.Files = exports.ExchangeRates = exports.Events = exports.EphemeralKeys = exports.Disputes = exports.Customers = exports.CreditNotes = exports.Coupons = exports.CountrySpecs = exports.Charges = exports.BalanceTransactions = exports.Balance = exports.ApplicationFees = exports.ApplePayDomains = exports.AccountLinks = exports.Accounts = exports.OAuth = exports.Account = void 0;
exports.Treasury = exports.TestHelpers = exports.Terminal = exports.Sigma = exports.Reporting = exports.Radar = exports.Issuing = exports.Identity = void 0;
var ResourceNamespace_1 = require("./ResourceNamespace");
var Accounts_1 = require("./resources/FinancialConnections/Accounts");
var Authorizations_1 = require("./resources/Issuing/Authorizations");
var Cardholders_1 = require("./resources/Issuing/Cardholders");
var Cards_1 = require("./resources/TestHelpers/Issuing/Cards");
var Cards_2 = require("./resources/Issuing/Cards");
var Configurations_1 = require("./resources/BillingPortal/Configurations");
var Configurations_2 = require("./resources/Terminal/Configurations");
var ConnectionTokens_1 = require("./resources/Terminal/ConnectionTokens");
var CreditReversals_1 = require("./resources/Treasury/CreditReversals");
var Customers_1 = require("./resources/TestHelpers/Customers");
var DebitReversals_1 = require("./resources/Treasury/DebitReversals");
var Disputes_1 = require("./resources/Issuing/Disputes");
var EarlyFraudWarnings_1 = require("./resources/Radar/EarlyFraudWarnings");
var FinancialAccounts_1 = require("./resources/Treasury/FinancialAccounts");
var InboundTransfers_1 = require("./resources/TestHelpers/Treasury/InboundTransfers");
var InboundTransfers_2 = require("./resources/Treasury/InboundTransfers");
var Locations_1 = require("./resources/Terminal/Locations");
var OutboundPayments_1 = require("./resources/TestHelpers/Treasury/OutboundPayments");
var OutboundPayments_2 = require("./resources/Treasury/OutboundPayments");
var OutboundTransfers_1 = require("./resources/TestHelpers/Treasury/OutboundTransfers");
var OutboundTransfers_2 = require("./resources/Treasury/OutboundTransfers");
var Readers_1 = require("./resources/TestHelpers/Terminal/Readers");
var Readers_2 = require("./resources/Terminal/Readers");
var ReceivedCredits_1 = require("./resources/TestHelpers/Treasury/ReceivedCredits");
var ReceivedCredits_2 = require("./resources/Treasury/ReceivedCredits");
var ReceivedDebits_1 = require("./resources/TestHelpers/Treasury/ReceivedDebits");
var ReceivedDebits_2 = require("./resources/Treasury/ReceivedDebits");
var Refunds_1 = require("./resources/TestHelpers/Refunds");
var ReportRuns_1 = require("./resources/Reporting/ReportRuns");
var ReportTypes_1 = require("./resources/Reporting/ReportTypes");
var ScheduledQueryRuns_1 = require("./resources/Sigma/ScheduledQueryRuns");
var Secrets_1 = require("./resources/Apps/Secrets");
var Sessions_1 = require("./resources/BillingPortal/Sessions");
var Sessions_2 = require("./resources/Checkout/Sessions");
var Sessions_3 = require("./resources/FinancialConnections/Sessions");
var TestClocks_1 = require("./resources/TestHelpers/TestClocks");
var TransactionEntries_1 = require("./resources/Treasury/TransactionEntries");
var Transactions_1 = require("./resources/Issuing/Transactions");
var Transactions_2 = require("./resources/Treasury/Transactions");
var ValueListItems_1 = require("./resources/Radar/ValueListItems");
var ValueLists_1 = require("./resources/Radar/ValueLists");
var VerificationReports_1 = require("./resources/Identity/VerificationReports");
var VerificationSessions_1 = require("./resources/Identity/VerificationSessions");
var Accounts_2 = require("./resources/Accounts");
Object.defineProperty(exports, "Account", { enumerable: true, get: function get() {
        return Accounts_2.Accounts;
    } });
var OAuth_1 = require("./resources/OAuth");
Object.defineProperty(exports, "OAuth", { enumerable: true, get: function get() {
        return OAuth_1.OAuth;
    } });
var Accounts_3 = require("./resources/Accounts");
Object.defineProperty(exports, "Accounts", { enumerable: true, get: function get() {
        return Accounts_3.Accounts;
    } });
var AccountLinks_1 = require("./resources/AccountLinks");
Object.defineProperty(exports, "AccountLinks", { enumerable: true, get: function get() {
        return AccountLinks_1.AccountLinks;
    } });
var ApplePayDomains_1 = require("./resources/ApplePayDomains");
Object.defineProperty(exports, "ApplePayDomains", { enumerable: true, get: function get() {
        return ApplePayDomains_1.ApplePayDomains;
    } });
var ApplicationFees_1 = require("./resources/ApplicationFees");
Object.defineProperty(exports, "ApplicationFees", { enumerable: true, get: function get() {
        return ApplicationFees_1.ApplicationFees;
    } });
var Balance_1 = require("./resources/Balance");
Object.defineProperty(exports, "Balance", { enumerable: true, get: function get() {
        return Balance_1.Balance;
    } });
var BalanceTransactions_1 = require("./resources/BalanceTransactions");
Object.defineProperty(exports, "BalanceTransactions", { enumerable: true, get: function get() {
        return BalanceTransactions_1.BalanceTransactions;
    } });
var Charges_1 = require("./resources/Charges");
Object.defineProperty(exports, "Charges", { enumerable: true, get: function get() {
        return Charges_1.Charges;
    } });
var CountrySpecs_1 = require("./resources/CountrySpecs");
Object.defineProperty(exports, "CountrySpecs", { enumerable: true, get: function get() {
        return CountrySpecs_1.CountrySpecs;
    } });
var Coupons_1 = require("./resources/Coupons");
Object.defineProperty(exports, "Coupons", { enumerable: true, get: function get() {
        return Coupons_1.Coupons;
    } });
var CreditNotes_1 = require("./resources/CreditNotes");
Object.defineProperty(exports, "CreditNotes", { enumerable: true, get: function get() {
        return CreditNotes_1.CreditNotes;
    } });
var Customers_2 = require("./resources/Customers");
Object.defineProperty(exports, "Customers", { enumerable: true, get: function get() {
        return Customers_2.Customers;
    } });
var Disputes_2 = require("./resources/Disputes");
Object.defineProperty(exports, "Disputes", { enumerable: true, get: function get() {
        return Disputes_2.Disputes;
    } });
var EphemeralKeys_1 = require("./resources/EphemeralKeys");
Object.defineProperty(exports, "EphemeralKeys", { enumerable: true, get: function get() {
        return EphemeralKeys_1.EphemeralKeys;
    } });
var Events_1 = require("./resources/Events");
Object.defineProperty(exports, "Events", { enumerable: true, get: function get() {
        return Events_1.Events;
    } });
var ExchangeRates_1 = require("./resources/ExchangeRates");
Object.defineProperty(exports, "ExchangeRates", { enumerable: true, get: function get() {
        return ExchangeRates_1.ExchangeRates;
    } });
var Files_1 = require("./resources/Files");
Object.defineProperty(exports, "Files", { enumerable: true, get: function get() {
        return Files_1.Files;
    } });
var FileLinks_1 = require("./resources/FileLinks");
Object.defineProperty(exports, "FileLinks", { enumerable: true, get: function get() {
        return FileLinks_1.FileLinks;
    } });
var Invoices_1 = require("./resources/Invoices");
Object.defineProperty(exports, "Invoices", { enumerable: true, get: function get() {
        return Invoices_1.Invoices;
    } });
var InvoiceItems_1 = require("./resources/InvoiceItems");
Object.defineProperty(exports, "InvoiceItems", { enumerable: true, get: function get() {
        return InvoiceItems_1.InvoiceItems;
    } });
var Mandates_1 = require("./resources/Mandates");
Object.defineProperty(exports, "Mandates", { enumerable: true, get: function get() {
        return Mandates_1.Mandates;
    } });
var PaymentIntents_1 = require("./resources/PaymentIntents");
Object.defineProperty(exports, "PaymentIntents", { enumerable: true, get: function get() {
        return PaymentIntents_1.PaymentIntents;
    } });
var PaymentLinks_1 = require("./resources/PaymentLinks");
Object.defineProperty(exports, "PaymentLinks", { enumerable: true, get: function get() {
        return PaymentLinks_1.PaymentLinks;
    } });
var PaymentMethods_1 = require("./resources/PaymentMethods");
Object.defineProperty(exports, "PaymentMethods", { enumerable: true, get: function get() {
        return PaymentMethods_1.PaymentMethods;
    } });
var Payouts_1 = require("./resources/Payouts");
Object.defineProperty(exports, "Payouts", { enumerable: true, get: function get() {
        return Payouts_1.Payouts;
    } });
var Plans_1 = require("./resources/Plans");
Object.defineProperty(exports, "Plans", { enumerable: true, get: function get() {
        return Plans_1.Plans;
    } });
var Prices_1 = require("./resources/Prices");
Object.defineProperty(exports, "Prices", { enumerable: true, get: function get() {
        return Prices_1.Prices;
    } });
var Products_1 = require("./resources/Products");
Object.defineProperty(exports, "Products", { enumerable: true, get: function get() {
        return Products_1.Products;
    } });
var PromotionCodes_1 = require("./resources/PromotionCodes");
Object.defineProperty(exports, "PromotionCodes", { enumerable: true, get: function get() {
        return PromotionCodes_1.PromotionCodes;
    } });
var Quotes_1 = require("./resources/Quotes");
Object.defineProperty(exports, "Quotes", { enumerable: true, get: function get() {
        return Quotes_1.Quotes;
    } });
var Refunds_2 = require("./resources/Refunds");
Object.defineProperty(exports, "Refunds", { enumerable: true, get: function get() {
        return Refunds_2.Refunds;
    } });
var Reviews_1 = require("./resources/Reviews");
Object.defineProperty(exports, "Reviews", { enumerable: true, get: function get() {
        return Reviews_1.Reviews;
    } });
var SetupAttempts_1 = require("./resources/SetupAttempts");
Object.defineProperty(exports, "SetupAttempts", { enumerable: true, get: function get() {
        return SetupAttempts_1.SetupAttempts;
    } });
var SetupIntents_1 = require("./resources/SetupIntents");
Object.defineProperty(exports, "SetupIntents", { enumerable: true, get: function get() {
        return SetupIntents_1.SetupIntents;
    } });
var ShippingRates_1 = require("./resources/ShippingRates");
Object.defineProperty(exports, "ShippingRates", { enumerable: true, get: function get() {
        return ShippingRates_1.ShippingRates;
    } });
var Sources_1 = require("./resources/Sources");
Object.defineProperty(exports, "Sources", { enumerable: true, get: function get() {
        return Sources_1.Sources;
    } });
var Subscriptions_1 = require("./resources/Subscriptions");
Object.defineProperty(exports, "Subscriptions", { enumerable: true, get: function get() {
        return Subscriptions_1.Subscriptions;
    } });
var SubscriptionItems_1 = require("./resources/SubscriptionItems");
Object.defineProperty(exports, "SubscriptionItems", { enumerable: true, get: function get() {
        return SubscriptionItems_1.SubscriptionItems;
    } });
var SubscriptionSchedules_1 = require("./resources/SubscriptionSchedules");
Object.defineProperty(exports, "SubscriptionSchedules", { enumerable: true, get: function get() {
        return SubscriptionSchedules_1.SubscriptionSchedules;
    } });
var TaxCodes_1 = require("./resources/TaxCodes");
Object.defineProperty(exports, "TaxCodes", { enumerable: true, get: function get() {
        return TaxCodes_1.TaxCodes;
    } });
var TaxRates_1 = require("./resources/TaxRates");
Object.defineProperty(exports, "TaxRates", { enumerable: true, get: function get() {
        return TaxRates_1.TaxRates;
    } });
var Tokens_1 = require("./resources/Tokens");
Object.defineProperty(exports, "Tokens", { enumerable: true, get: function get() {
        return Tokens_1.Tokens;
    } });
var Topups_1 = require("./resources/Topups");
Object.defineProperty(exports, "Topups", { enumerable: true, get: function get() {
        return Topups_1.Topups;
    } });
var Transfers_1 = require("./resources/Transfers");
Object.defineProperty(exports, "Transfers", { enumerable: true, get: function get() {
        return Transfers_1.Transfers;
    } });
var WebhookEndpoints_1 = require("./resources/WebhookEndpoints");
Object.defineProperty(exports, "WebhookEndpoints", { enumerable: true, get: function get() {
        return WebhookEndpoints_1.WebhookEndpoints;
    } });
exports.Apps = (0, ResourceNamespace_1.resourceNamespace)('apps', { Secrets: Secrets_1.Secrets });
exports.BillingPortal = (0, ResourceNamespace_1.resourceNamespace)('billingPortal', {
    Configurations: Configurations_1.Configurations,
    Sessions: Sessions_1.Sessions
});
exports.Checkout = (0, ResourceNamespace_1.resourceNamespace)('checkout', {
    Sessions: Sessions_2.Sessions
});
exports.FinancialConnections = (0, ResourceNamespace_1.resourceNamespace)('financialConnections', {
    Accounts: Accounts_1.Accounts,
    Sessions: Sessions_3.Sessions
});
exports.Identity = (0, ResourceNamespace_1.resourceNamespace)('identity', {
    VerificationReports: VerificationReports_1.VerificationReports,
    VerificationSessions: VerificationSessions_1.VerificationSessions
});
exports.Issuing = (0, ResourceNamespace_1.resourceNamespace)('issuing', {
    Authorizations: Authorizations_1.Authorizations,
    Cardholders: Cardholders_1.Cardholders,
    Cards: Cards_2.Cards,
    Disputes: Disputes_1.Disputes,
    Transactions: Transactions_1.Transactions
});
exports.Radar = (0, ResourceNamespace_1.resourceNamespace)('radar', {
    EarlyFraudWarnings: EarlyFraudWarnings_1.EarlyFraudWarnings,
    ValueListItems: ValueListItems_1.ValueListItems,
    ValueLists: ValueLists_1.ValueLists
});
exports.Reporting = (0, ResourceNamespace_1.resourceNamespace)('reporting', {
    ReportRuns: ReportRuns_1.ReportRuns,
    ReportTypes: ReportTypes_1.ReportTypes
});
exports.Sigma = (0, ResourceNamespace_1.resourceNamespace)('sigma', {
    ScheduledQueryRuns: ScheduledQueryRuns_1.ScheduledQueryRuns
});
exports.Terminal = (0, ResourceNamespace_1.resourceNamespace)('terminal', {
    Configurations: Configurations_2.Configurations,
    ConnectionTokens: ConnectionTokens_1.ConnectionTokens,
    Locations: Locations_1.Locations,
    Readers: Readers_2.Readers
});
exports.TestHelpers = (0, ResourceNamespace_1.resourceNamespace)('testHelpers', {
    Customers: Customers_1.Customers,
    Refunds: Refunds_1.Refunds,
    TestClocks: TestClocks_1.TestClocks,
    Issuing: (0, ResourceNamespace_1.resourceNamespace)('issuing', { Cards: Cards_1.Cards }),
    Terminal: (0, ResourceNamespace_1.resourceNamespace)('terminal', {
        Readers: Readers_1.Readers
    }),
    Treasury: (0, ResourceNamespace_1.resourceNamespace)('treasury', {
        InboundTransfers: InboundTransfers_1.InboundTransfers,
        OutboundPayments: OutboundPayments_1.OutboundPayments,
        OutboundTransfers: OutboundTransfers_1.OutboundTransfers,
        ReceivedCredits: ReceivedCredits_1.ReceivedCredits,
        ReceivedDebits: ReceivedDebits_1.ReceivedDebits
    })
});
exports.Treasury = (0, ResourceNamespace_1.resourceNamespace)('treasury', {
    CreditReversals: CreditReversals_1.CreditReversals,
    DebitReversals: DebitReversals_1.DebitReversals,
    FinancialAccounts: FinancialAccounts_1.FinancialAccounts,
    InboundTransfers: InboundTransfers_2.InboundTransfers,
    OutboundPayments: OutboundPayments_2.OutboundPayments,
    OutboundTransfers: OutboundTransfers_2.OutboundTransfers,
    ReceivedCredits: ReceivedCredits_2.ReceivedCredits,
    ReceivedDebits: ReceivedDebits_2.ReceivedDebits,
    TransactionEntries: TransactionEntries_1.TransactionEntries,
    Transactions: Transactions_2.Transactions
});
},{"./ResourceNamespace":231,"./resources/FinancialConnections/Accounts":277,"./resources/Issuing/Authorizations":278,"./resources/Issuing/Cardholders":280,"./resources/TestHelpers/Issuing/Cards":313,"./resources/Issuing/Cards":279,"./resources/BillingPortal/Configurations":282,"./resources/Terminal/Configurations":281,"./resources/Terminal/ConnectionTokens":283,"./resources/Treasury/CreditReversals":285,"./resources/TestHelpers/Customers":284,"./resources/Treasury/DebitReversals":286,"./resources/Issuing/Disputes":291,"./resources/Radar/EarlyFraudWarnings":289,"./resources/Treasury/FinancialAccounts":290,"./resources/TestHelpers/Treasury/InboundTransfers":314,"./resources/Treasury/InboundTransfers":287,"./resources/Terminal/Locations":288,"./resources/TestHelpers/Treasury/OutboundPayments":315,"./resources/Treasury/OutboundPayments":293,"./resources/TestHelpers/Treasury/OutboundTransfers":317,"./resources/Treasury/OutboundTransfers":294,"./resources/TestHelpers/Terminal/Readers":316,"./resources/Terminal/Readers":292,"./resources/TestHelpers/Treasury/ReceivedCredits":318,"./resources/Treasury/ReceivedCredits":295,"./resources/TestHelpers/Treasury/ReceivedDebits":319,"./resources/Treasury/ReceivedDebits":297,"./resources/TestHelpers/Refunds":296,"./resources/Reporting/ReportRuns":298,"./resources/Reporting/ReportTypes":299,"./resources/Sigma/ScheduledQueryRuns":300,"./resources/Apps/Secrets":312,"./resources/BillingPortal/Sessions":301,"./resources/Checkout/Sessions":302,"./resources/FinancialConnections/Sessions":303,"./resources/TestHelpers/TestClocks":304,"./resources/Treasury/TransactionEntries":305,"./resources/Issuing/Transactions":306,"./resources/Treasury/Transactions":307,"./resources/Radar/ValueListItems":308,"./resources/Radar/ValueLists":309,"./resources/Identity/VerificationReports":310,"./resources/Identity/VerificationSessions":311,"./resources/Accounts":232,"./resources/OAuth":233,"./resources/AccountLinks":234,"./resources/ApplePayDomains":236,"./resources/ApplicationFees":235,"./resources/Balance":237,"./resources/BalanceTransactions":238,"./resources/Charges":239,"./resources/CountrySpecs":240,"./resources/Coupons":243,"./resources/CreditNotes":241,"./resources/Customers":242,"./resources/Disputes":244,"./resources/EphemeralKeys":245,"./resources/Events":246,"./resources/ExchangeRates":247,"./resources/Files":249,"./resources/FileLinks":248,"./resources/Invoices":250,"./resources/InvoiceItems":251,"./resources/Mandates":252,"./resources/PaymentIntents":254,"./resources/PaymentLinks":253,"./resources/PaymentMethods":255,"./resources/Payouts":256,"./resources/Plans":257,"./resources/Prices":259,"./resources/Products":258,"./resources/PromotionCodes":260,"./resources/Quotes":261,"./resources/Refunds":262,"./resources/Reviews":263,"./resources/SetupAttempts":264,"./resources/SetupIntents":265,"./resources/ShippingRates":266,"./resources/Sources":267,"./resources/Subscriptions":268,"./resources/SubscriptionItems":269,"./resources/SubscriptionSchedules":270,"./resources/TaxCodes":271,"./resources/TaxRates":272,"./resources/Tokens":273,"./resources/Topups":274,"./resources/Transfers":275,"./resources/WebhookEndpoints":276}],60:[function(require,module,exports) {
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestSender = void 0;
var Error_1 = require("./Error");
var utils_1 = require("./utils");
var HttpClient_1 = require("./net/HttpClient");
var MAX_RETRY_AFTER_WAIT = 60;

var RequestSender = function () {
    function RequestSender(stripe, maxBufferedRequestMetric) {
        _classCallCheck(this, RequestSender);

        this._stripe = stripe;
        this._maxBufferedRequestMetric = maxBufferedRequestMetric;
    }

    _createClass(RequestSender, [{
        key: "_addHeadersDirectlyToObject",
        value: function _addHeadersDirectlyToObject(obj, headers) {
            // For convenience, make some headers easily accessible on
            // lastResponse.
            // NOTE: Stripe responds with lowercase header names/keys.
            obj.requestId = headers['request-id'];
            obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];
            obj.apiVersion = obj.apiVersion || headers['stripe-version'];
            obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];
        }
    }, {
        key: "_makeResponseEvent",
        value: function _makeResponseEvent(requestEvent, statusCode, headers) {
            var requestEndTime = Date.now();
            var requestDurationMs = requestEndTime - requestEvent.request_start_time;
            return (0, utils_1.removeNullish)({
                api_version: headers['stripe-version'],
                account: headers['stripe-account'],
                idempotency_key: headers['idempotency-key'],
                method: requestEvent.method,
                path: requestEvent.path,
                status: statusCode,
                request_id: this._getRequestId(headers),
                elapsed: requestDurationMs,
                request_start_time: requestEvent.request_start_time,
                request_end_time: requestEndTime
            });
        }
    }, {
        key: "_getRequestId",
        value: function _getRequestId(headers) {
            return headers['request-id'];
        }
        /**
         * Used by methods with spec.streaming === true. For these methods, we do not
         * buffer successful responses into memory or do parse them into stripe
         * objects, we delegate that all of that to the user and pass back the raw
         * http.Response object to the callback.
         *
         * (Unsuccessful responses shouldn't make it here, they should
         * still be buffered/parsed and handled by _jsonResponseHandler -- see
         * makeRequest)
         */

    }, {
        key: "_streamingResponseHandler",
        value: function _streamingResponseHandler(requestEvent, callback) {
            var _this = this;

            return function (res) {
                var headers = res.getHeaders();
                var streamCompleteCallback = function streamCompleteCallback() {
                    var responseEvent = _this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);
                    _this._stripe._emitter.emit('response', responseEvent);
                    _this._recordRequestMetrics(_this._getRequestId(headers), responseEvent.elapsed);
                };
                var stream = res.toStream(streamCompleteCallback);
                // This is here for backwards compatibility, as the stream is a raw
                // HTTP response in Node and the legacy behavior was to mutate this
                // response.
                _this._addHeadersDirectlyToObject(stream, headers);
                return callback(null, stream);
            };
        }
        /**
         * Default handler for Stripe responses. Buffers the response into memory,
         * parses the JSON and returns it (i.e. passes it to the callback) if there
         * is no "error" field. Otherwise constructs/passes an appropriate Error.
         */

    }, {
        key: "_jsonResponseHandler",
        value: function _jsonResponseHandler(requestEvent, callback) {
            var _this2 = this;

            return function (res) {
                var headers = res.getHeaders();
                var requestId = _this2._getRequestId(headers);
                var statusCode = res.getStatusCode();
                var responseEvent = _this2._makeResponseEvent(requestEvent, statusCode, headers);
                _this2._stripe._emitter.emit('response', responseEvent);
                res.toJSON().then(function (jsonResponse) {
                    if (jsonResponse.error) {
                        var err = void 0;
                        // Convert OAuth error responses into a standard format
                        // so that the rest of the error logic can be shared
                        if (typeof jsonResponse.error === 'string') {
                            jsonResponse.error = {
                                type: jsonResponse.error,
                                message: jsonResponse.error_description
                            };
                        }
                        jsonResponse.error.headers = headers;
                        jsonResponse.error.statusCode = statusCode;
                        jsonResponse.error.requestId = requestId;
                        if (statusCode === 401) {
                            err = new Error_1.StripeAuthenticationError(jsonResponse.error);
                        } else if (statusCode === 403) {
                            err = new Error_1.StripePermissionError(jsonResponse.error);
                        } else if (statusCode === 429) {
                            err = new Error_1.StripeRateLimitError(jsonResponse.error);
                        } else {
                            err = Error_1.StripeError.generate(jsonResponse.error);
                        }
                        throw err;
                    }
                    return jsonResponse;
                }, function (e) {
                    throw new Error_1.StripeAPIError({
                        message: 'Invalid JSON received from the Stripe API',
                        exception: e,
                        requestId: headers['request-id']
                    });
                }).then(function (jsonResponse) {
                    _this2._recordRequestMetrics(requestId, responseEvent.elapsed);
                    // Expose raw response object.
                    var rawResponse = res.getRawResponse();
                    _this2._addHeadersDirectlyToObject(rawResponse, headers);
                    Object.defineProperty(jsonResponse, 'lastResponse', {
                        enumerable: false,
                        writable: false,
                        value: rawResponse
                    });
                    callback(null, jsonResponse);
                }, function (e) {
                    return callback(e, null);
                });
            };
        }
    }, {
        key: "_getSleepTimeInMS",
        value: function _getSleepTimeInMS(numRetries) {
            var retryAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();
            var maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();
            // Apply exponential backoff with initialNetworkRetryDelay on the
            // number of numRetries so far as inputs. Do not allow the number to exceed
            // maxNetworkRetryDelay.
            var sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);
            // Apply some jitter by randomizing the value in the range of
            // (sleepSeconds / 2) to (sleepSeconds).
            sleepSeconds *= 0.5 * (1 + Math.random());
            // But never sleep less than the base sleep seconds.
            sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);
            // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.
            if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {
                sleepSeconds = Math.max(sleepSeconds, retryAfter);
            }
            return sleepSeconds * 1000;
        }
        // Max retries can be set on a per request basis. Favor those over the global setting

    }, {
        key: "_getMaxNetworkRetries",
        value: function _getMaxNetworkRetries() {
            var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            return settings.maxNetworkRetries && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();
        }
    }, {
        key: "_defaultIdempotencyKey",
        value: function _defaultIdempotencyKey(method, settings) {
            // If this is a POST and we allow multiple retries, ensure an idempotency key.
            var maxRetries = this._getMaxNetworkRetries(settings);
            if (method === 'POST' && maxRetries > 0) {
                return "stripe-node-retry-" + this._stripe._platformFunctions.uuid4();
            }
            return null;
        }
    }, {
        key: "_makeHeaders",
        value: function _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {
            var defaultHeaders = {
                // Use specified auth token or use default from this stripe instance:
                Authorization: auth ? "Bearer " + auth : this._stripe.getApiField('auth'),
                Accept: 'application/json',
                'Content-Type': 'application/x-www-form-urlencoded',
                'User-Agent': this._getUserAgentString(),
                'X-Stripe-Client-User-Agent': clientUserAgent,
                'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),
                'Stripe-Version': apiVersion,
                'Stripe-Account': this._stripe.getApiField('stripeAccount'),
                'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings)
            };
            // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:
            //   A user agent SHOULD send a Content-Length in a request message when
            //   no Transfer-Encoding is sent and the request method defines a meaning
            //   for an enclosed payload body.  For example, a Content-Length header
            //   field is normally sent in a POST request even when the value is 0
            //   (indicating an empty payload body).  A user agent SHOULD NOT send a
            //   Content-Length header field when the request message does not contain
            //   a payload body and the method semantics do not anticipate such a
            //   body.
            //
            // These method types are expected to have bodies and so we should always
            // include a Content-Length.
            var methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';
            // If a content length was specified, we always include it regardless of
            // whether the method semantics anticipate such a body. This keeps us
            // consistent with historical behavior. We do however want to warn on this
            // and fix these cases as they are semantically incorrect.
            if (methodHasPayload || contentLength) {
                if (!methodHasPayload) {
                    (0, utils_1.emitWarning)(method + " method had non-zero contentLength but no payload is expected for this verb");
                }
                defaultHeaders['Content-Length'] = contentLength;
            }
            return Object.assign((0, utils_1.removeNullish)(defaultHeaders),
            // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.
            (0, utils_1.normalizeHeaders)(userSuppliedHeaders));
        }
    }, {
        key: "_getUserAgentString",
        value: function _getUserAgentString() {
            var packageVersion = this._stripe.getConstant('PACKAGE_VERSION');
            var appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';
            return ("Stripe/v1 NodeBindings/" + packageVersion + " " + appInfo).trim();
        }
    }, {
        key: "_getTelemetryHeader",
        value: function _getTelemetryHeader() {
            if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {
                var metrics = this._stripe._prevRequestMetrics.shift();
                return JSON.stringify({
                    last_request_metrics: metrics
                });
            }
        }
    }, {
        key: "_recordRequestMetrics",
        value: function _recordRequestMetrics(requestId, requestDurationMs) {
            if (this._stripe.getTelemetryEnabled() && requestId) {
                if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {
                    (0, utils_1.emitWarning)('Request metrics buffer is full, dropping telemetry message.');
                } else {
                    this._stripe._prevRequestMetrics.push({
                        request_id: requestId,
                        request_duration_ms: requestDurationMs
                    });
                }
            }
        }
    }, {
        key: "_request",
        value: function _request(method, host, path, data, auth) {
            var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

            var _this3 = this;

            var callback = arguments[6];
            var requestDataProcessor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

            var requestData = void 0;
            var retryRequest = function retryRequest(requestFn, apiVersion, headers, requestRetries, retryAfter) {
                return setTimeout(requestFn, _this3._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);
            };
            var makeRequest = function makeRequest(apiVersion, headers, numRetries) {
                // timeout can be set on a per-request basis. Favor that over the global setting
                var timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : _this3._stripe.getApiField('timeout');
                var req = _this3._stripe.getApiField('httpClient').makeRequest(host || _this3._stripe.getApiField('host'), _this3._stripe.getApiField('port'), path, method, headers, requestData, _this3._stripe.getApiField('protocol'), timeout);
                var requestStartTime = Date.now();
                // @ts-ignore
                var requestEvent = (0, utils_1.removeNullish)({
                    api_version: apiVersion,
                    account: headers['Stripe-Account'],
                    idempotency_key: headers['Idempotency-Key'],
                    method: method,
                    path: path,
                    request_start_time: requestStartTime
                });
                var requestRetries = numRetries || 0;
                var maxRetries = _this3._getMaxNetworkRetries(options.settings || {});
                _this3._stripe._emitter.emit('request', requestEvent);
                req.then(function (res) {
                    if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {
                        return retryRequest(makeRequest, apiVersion, headers, requestRetries,
                        // @ts-ignore
                        res.getHeaders()['retry-after']);
                    } else if (options.streaming && res.getStatusCode() < 400) {
                        return _this3._streamingResponseHandler(requestEvent, callback)(res);
                    } else {
                        return _this3._jsonResponseHandler(requestEvent, callback)(res);
                    }
                }).catch(function (error) {
                    if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {
                        return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);
                    } else {
                        var isTimeoutError = error.code && error.code === HttpClient_1.HttpClient.TIMEOUT_ERROR_CODE;
                        return callback(new Error_1.StripeConnectionError({
                            message: isTimeoutError ? "Request aborted due to timeout being reached (" + timeout + "ms)" : RequestSender._generateConnectionErrorMessage(requestRetries),
                            // @ts-ignore
                            detail: error
                        }));
                    }
                });
            };
            var prepareAndMakeRequest = function prepareAndMakeRequest(error, data) {
                if (error) {
                    return callback(error);
                }
                requestData = data;
                _this3._stripe.getClientUserAgent(function (clientUserAgent) {
                    var _a, _b;
                    var apiVersion = _this3._stripe.getApiField('version');
                    var headers = _this3._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});
                    makeRequest(apiVersion, headers, 0);
                });
            };
            if (requestDataProcessor) {
                requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);
            } else {
                prepareAndMakeRequest(null, (0, utils_1.stringifyRequestData)(data || {}));
            }
        }
    }], [{
        key: "_generateConnectionErrorMessage",
        value: function _generateConnectionErrorMessage(requestRetries) {
            return "An error occurred with our connection to Stripe." + (requestRetries > 0 ? " Request was retried " + requestRetries + " times." : '');
        }
        // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency

    }, {
        key: "_shouldRetry",
        value: function _shouldRetry(res, numRetries, maxRetries, error) {
            if (error && numRetries === 0 && HttpClient_1.HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {
                return true;
            }
            // Do not retry if we are out of retries.
            if (numRetries >= maxRetries) {
                return false;
            }
            // Retry on connection error.
            if (!res) {
                return true;
            }
            // The API may ask us not to retry (e.g., if doing so would be a no-op)
            // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.
            if (res.getHeaders()['stripe-should-retry'] === 'false') {
                return false;
            }
            if (res.getHeaders()['stripe-should-retry'] === 'true') {
                return true;
            }
            // Retry on conflict errors.
            if (res.getStatusCode() === 409) {
                return true;
            }
            // Retry on 500, 503, and other internal errors.
            //
            // Note that we expect the stripe-should-retry header to be false
            // in most cases when a 500 is returned, since our idempotency framework
            // would typically replay it anyway.
            if (res.getStatusCode() >= 500) {
                return true;
            }
            return false;
        }
    }]);

    return RequestSender;
}();

exports.RequestSender = RequestSender;
},{"./Error":57,"./utils":59,"./net/HttpClient":63}],62:[function(require,module,exports) {
"use strict";

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.createWebhooks = void 0;
var Error_1 = require("./Error");
function createWebhooks(platformFunctions) {
    var Webhook = {
        DEFAULT_TOLERANCE: 300,
        // @ts-ignore
        signature: null,
        constructEvent: function constructEvent(payload, header, secret, tolerance, cryptoProvider) {
            this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);
            var jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);
            return jsonPayload;
        },
        constructEventAsync: function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(payload, header, secret, tolerance, cryptoProvider) {
                var jsonPayload;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);

                            case 2:
                                jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);
                                return _context.abrupt("return", jsonPayload);

                            case 4:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function constructEventAsync(_x, _x2, _x3, _x4, _x5) {
                return _ref.apply(this, arguments);
            }

            return constructEventAsync;
        }(),

        /**
         * Generates a header to be used for webhook mocking
         *
         * @typedef {object} opts
         * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()
         * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters
         * @property {string} secret - Stripe webhook secret 'whsec_...'
         * @property {string} scheme - Version of API to hit. Defaults to 'v1'.
         * @property {string} signature - Computed webhook signature
         * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.
         */
        generateTestHeaderString: function generateTestHeaderString(opts) {
            if (!opts) {
                throw new Error_1.StripeError({
                    message: 'Options are required'
                });
            }
            opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);
            opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;
            opts.cryptoProvider = opts.cryptoProvider || getCryptoProvider();
            opts.signature = opts.signature || opts.cryptoProvider.computeHMACSignature(opts.timestamp + '.' + opts.payload, opts.secret);
            var generatedHeader = ['t=' + opts.timestamp, opts.scheme + '=' + opts.signature].join(',');
            return generatedHeader;
        }
    };
    var signature = {
        EXPECTED_SCHEME: 'v1',
        verifyHeader: function verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {
            var _parseEventDetails = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME),
                header = _parseEventDetails.decodedHeader,
                payload = _parseEventDetails.decodedPayload,
                details = _parseEventDetails.details,
                suspectPayloadType = _parseEventDetails.suspectPayloadType;

            cryptoProvider = cryptoProvider || getCryptoProvider();
            var expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);
            validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType);
            return true;
        },
        verifyHeaderAsync: function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {
                var _parseEventDetails2, header, payload, details, suspectPayloadType, expectedSignature;

                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _parseEventDetails2 = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME), header = _parseEventDetails2.decodedHeader, payload = _parseEventDetails2.decodedPayload, details = _parseEventDetails2.details, suspectPayloadType = _parseEventDetails2.suspectPayloadType;

                                cryptoProvider = cryptoProvider || getCryptoProvider();
                                _context2.next = 4;
                                return cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);

                            case 4:
                                expectedSignature = _context2.sent;
                                return _context2.abrupt("return", validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType));

                            case 6:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function verifyHeaderAsync(_x6, _x7, _x8, _x9, _x10) {
                return _ref2.apply(this, arguments);
            }

            return verifyHeaderAsync;
        }()
    };
    function makeHMACContent(payload, details) {
        return details.timestamp + "." + payload;
    }
    function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {
        if (!encodedPayload) {
            throw new Error_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {
                message: 'No webhook payload was provided.'
            });
        }
        var suspectPayloadType = typeof encodedPayload != 'string' && !(encodedPayload instanceof Uint8Array);
        var textDecoder = new TextDecoder('utf8');
        var decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;
        // Express's type for `Request#headers` is `string | []string`
        // which is because the `set-cookie` header is an array,
        // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)
        // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)
        if (Array.isArray(encodedHeader)) {
            throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');
        }
        if (encodedHeader == null || encodedHeader == '') {
            throw new Error_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {
                message: 'No stripe-signature header value was provided.'
            });
        }
        var decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;
        var details = parseHeader(decodedHeader, expectedScheme);
        if (!details || details.timestamp === -1) {
            throw new Error_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {
                message: 'Unable to extract timestamp and signatures from header'
            });
        }
        if (!details.signatures.length) {
            throw new Error_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {
                message: 'No signatures found with expected scheme'
            });
        }
        return {
            decodedPayload: decodedPayload,
            decodedHeader: decodedHeader,
            details: details,
            suspectPayloadType: suspectPayloadType
        };
    }
    function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType) {
        var signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;
        if (!signatureFound) {
            if (suspectPayloadType) {
                throw new Error_1.StripeSignatureVerificationError(header, payload, {
                    message: 'Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.' + 'Payload was provided as a parsed JavaScript object instead. \n' + 'Signature verification is impossible without access to the original signed material. \n' + 'Learn more about webhook signing and explore webhook integration examples for various frameworks at ' + 'https://github.com/stripe/stripe-node#webhook-signing'
                });
            }
            throw new Error_1.StripeSignatureVerificationError(header, payload, {
                message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe? \n' + 'Learn more about webhook signing and explore webhook integration examples for various frameworks at ' + 'https://github.com/stripe/stripe-node#webhook-signing'
            });
        }
        var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;
        if (tolerance > 0 && timestampAge > tolerance) {
            // @ts-ignore
            throw new Error_1.StripeSignatureVerificationError(header, payload, {
                message: 'Timestamp outside the tolerance zone'
            });
        }
        return true;
    }
    function parseHeader(header, scheme) {
        if (typeof header !== 'string') {
            return null;
        }
        return header.split(',').reduce(function (accum, item) {
            var kv = item.split('=');
            if (kv[0] === 't') {
                accum.timestamp = parseInt(kv[1], 10);
            }
            if (kv[0] === scheme) {
                accum.signatures.push(kv[1]);
            }
            return accum;
        }, {
            timestamp: -1,
            signatures: []
        });
    }
    var webhooksCryptoProviderInstance = null;
    /**
     * Lazily instantiate a CryptoProvider instance. This is a stateless object
     * so a singleton can be used here.
     */
    function getCryptoProvider() {
        if (!webhooksCryptoProviderInstance) {
            webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();
        }
        return webhooksCryptoProviderInstance;
    }
    Webhook.signature = signature;
    return Webhook;
}
exports.createWebhooks = createWebhooks;
},{"./Error":57}],56:[function(require,module,exports) {
module.exports = {
  "name": "stripe",
  "version": "11.14.0",
  "description": "Stripe API wrapper",
  "keywords": [
    "stripe",
    "payment processing",
    "credit cards",
    "api"
  ],
  "homepage": "https://github.com/stripe/stripe-node",
  "author": "Stripe <support@stripe.com> (https://stripe.com/)",
  "contributors": [
    "Ask BjÃ¸rn Hansen <ask@develooper.com> (http://www.askask.com/)",
    "Michelle Bu <michelle@stripe.com>",
    "Alex Sexton <alex@stripe.com>",
    "James Padolsey"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/stripe/stripe-node.git"
  },
  "bugs": "https://github.com/stripe/stripe-node/issues",
  "engines": {
    "node": ">=12.*"
  },
  "main": "lib/stripe.node.js",
  "types": "types/index.d.ts",
  "devDependencies": {
    "@types/chai": "^4.3.4",
    "@types/chai-as-promised": "^7.1.5",
    "@types/mocha": "^10.0.1",
    "@types/qs": "^6.9.7",
    "@typescript-eslint/eslint-plugin": "^4.33.0",
    "@typescript-eslint/parser": "^4.33.0",
    "chai": "^4.3.6",
    "chai-as-promised": "~7.1.1",
    "coveralls": "^3.1.1",
    "eslint": "^7.32.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-chai-friendly": "^0.7.2",
    "eslint-plugin-prettier": "^3.4.1",
    "mocha": "^8.4.0",
    "mocha-junit-reporter": "^2.1.0",
    "nock": "^13.2.9",
    "node-fetch": "^2.6.7",
    "nyc": "^15.1.0",
    "prettier": "^1.16.4",
    "ts-node": "^10.9.1",
    "typescript": "^4.9.4"
  },
  "resolutions": {
    "minimist": "1.2.6",
    "nanoid": "^3.2.0"
  },
  "dependencies": {
    "@types/node": ">=8.1.0",
    "qs": "^6.11.0"
  },
  "license": "MIT",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "clean": "rm -rf ./.nyc_output ./node_modules/.cache ./coverage ./lib",
    "prepack": "yarn install && yarn build",
    "mocha": "nyc mocha",
    "mocha-only": "mocha",
    "test": "yarn build && yarn test-typescript && yarn mocha",
    "test-typescript": "tsc --build types/test",
    "lint": "eslint --ext .js,.jsx,.ts .",
    "fix": "yarn lint --fix && ./scripts/updateAPIVersion.js",
    "report": "nyc -r text -r lcov report",
    "coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js"
  },
  "exports": {
    "types": "./types/index.d.ts",
    "browser": "./lib/stripe.worker.js",
    "worker": "./lib/stripe.worker.js",
    "default": "./lib/stripe.node.js"
  }
}
;
},{}],23:[function(require,module,exports) {
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
exports.createStripe = void 0;
var _Error = require("./Error");
var resources = require("./resources");
var HttpClient_1 = require("./net/HttpClient");
var utils_1 = require("./utils");
var CryptoProvider_1 = require("./crypto/CryptoProvider");
var RequestSender_1 = require("./RequestSender");
var StripeResource_1 = require("./StripeResource");
var Webhooks_1 = require("./Webhooks");
var DEFAULT_HOST = 'api.stripe.com';
var DEFAULT_PORT = '443';
var DEFAULT_BASE_PATH = '/v1/';
var DEFAULT_API_VERSION = null;
var DEFAULT_TIMEOUT = 80000;
var MAX_NETWORK_RETRY_DELAY_SEC = 2;
var INITIAL_NETWORK_RETRY_DELAY_SEC = 0.5;
var APP_INFO_PROPERTIES = ['name', 'version', 'url', 'partner_id'];
var ALLOWED_CONFIG_PROPERTIES = ['apiVersion', 'typescript', 'maxNetworkRetries', 'httpAgent', 'httpClient', 'timeout', 'host', 'port', 'protocol', 'telemetry', 'appInfo', 'stripeAccount'];
var defaultRequestSenderFactory = function defaultRequestSenderFactory(stripe) {
    return new RequestSender_1.RequestSender(stripe, StripeResource_1.StripeResource.MAX_BUFFERED_REQUEST_METRICS);
};
function createStripe(platformFunctions) {
    var requestSender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRequestSenderFactory;

    Stripe.PACKAGE_VERSION = require('../package.json').version;
    Stripe.USER_AGENT = Object.assign({ bindings_version: Stripe.PACKAGE_VERSION, lang: 'node', publisher: 'stripe', uname: null, typescript: false }, (0, utils_1.determineProcessUserAgentProperties)());
    Stripe.StripeResource = StripeResource_1.StripeResource;
    Stripe.resources = resources;
    Stripe.HttpClient = HttpClient_1.HttpClient;
    Stripe.HttpClientResponse = HttpClient_1.HttpClientResponse;
    Stripe.CryptoProvider = CryptoProvider_1.CryptoProvider;
    function Stripe(key) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (!(this instanceof Stripe)) {
            return new Stripe(key, config);
        }
        var props = this._getPropsFromConfig(config);
        this._platformFunctions = platformFunctions;
        Object.defineProperty(this, '_emitter', {
            value: this._platformFunctions.createEmitter(),
            enumerable: false,
            configurable: false,
            writable: false
        });
        this.VERSION = Stripe.PACKAGE_VERSION;
        this.on = this._emitter.on.bind(this._emitter);
        this.once = this._emitter.once.bind(this._emitter);
        this.off = this._emitter.removeListener.bind(this._emitter);
        if (props.protocol && props.protocol !== 'https' && (!props.host || /\.stripe\.com$/.test(props.host))) {
            throw new Error('The `https` protocol must be used when sending requests to `*.stripe.com`');
        }
        var agent = props.httpAgent || null;
        this._api = {
            auth: null,
            host: props.host || DEFAULT_HOST,
            port: props.port || DEFAULT_PORT,
            protocol: props.protocol || 'https',
            basePath: DEFAULT_BASE_PATH,
            version: props.apiVersion || DEFAULT_API_VERSION,
            timeout: (0, utils_1.validateInteger)('timeout', props.timeout, DEFAULT_TIMEOUT),
            maxNetworkRetries: (0, utils_1.validateInteger)('maxNetworkRetries', props.maxNetworkRetries, 0),
            agent: agent,
            httpClient: props.httpClient || (agent ? this._platformFunctions.createNodeHttpClient(agent) : this._platformFunctions.createDefaultHttpClient()),
            dev: false,
            stripeAccount: props.stripeAccount || null
        };
        var typescript = props.typescript || false;
        if (typescript !== Stripe.USER_AGENT.typescript) {
            // The mutation here is uncomfortable, but likely fastest;
            // serializing the user agent involves shelling out to the system,
            // and given some users may instantiate the library many times without switching between TS and non-TS,
            // we only want to incur the performance hit when that actually happens.
            Stripe.USER_AGENT.typescript = typescript;
        }
        if (props.appInfo) {
            this._setAppInfo(props.appInfo);
        }
        this._prepResources();
        this._setApiKey(key);
        this.errors = _Error;
        this.webhooks = (0, Webhooks_1.createWebhooks)(platformFunctions);
        this._prevRequestMetrics = [];
        this._enableTelemetry = props.telemetry !== false;
        this._requestSender = requestSender(this);
        // Expose StripeResource on the instance too
        // @ts-ignore
        this.StripeResource = Stripe.StripeResource;
    }
    Stripe.errors = _Error;
    Stripe.webhooks = Webhooks_1.createWebhooks;
    Stripe.createNodeHttpClient = platformFunctions.createNodeHttpClient;
    /**
     * Creates an HTTP client for issuing Stripe API requests which uses the Web
     * Fetch API.
     *
     * A fetch function can optionally be passed in as a parameter. If none is
     * passed, will default to the default `fetch` function in the global scope.
     */
    Stripe.createFetchHttpClient = platformFunctions.createFetchHttpClient;
    /**
     * Create a CryptoProvider which uses the built-in Node crypto libraries for
     * its crypto operations.
     */
    Stripe.createNodeCryptoProvider = platformFunctions.createNodeCryptoProvider;
    /**
     * Creates a CryptoProvider which uses the Subtle Crypto API from the Web
     * Crypto API spec for its crypto operations.
     *
     * A SubtleCrypto interface can optionally be passed in as a parameter. If none
     * is passed, will default to the default `crypto.subtle` object in the global
     * scope.
     */
    Stripe.createSubtleCryptoProvider = platformFunctions.createSubtleCryptoProvider;
    Stripe.prototype = {
        // Properties are set in the constructor above
        _appInfo: undefined,
        on: null,
        off: null,
        once: null,
        VERSION: null,
        StripeResource: null,
        webhooks: null,
        errors: null,
        _api: null,
        _prevRequestMetrics: null,
        _emitter: null,
        _enableTelemetry: null,
        _requestSender: null,
        _platformFunctions: null,
        /**
         * @private
         */
        _setApiKey: function _setApiKey(key) {
            if (key) {
                this._setApiField('auth', "Bearer " + key);
            }
        },

        /**
         * @private
         * This may be removed in the future.
         */
        _setAppInfo: function _setAppInfo(info) {
            if (info && (typeof info === "undefined" ? "undefined" : _typeof(info)) !== 'object') {
                throw new Error('AppInfo must be an object.');
            }
            if (info && !info.name) {
                throw new Error('AppInfo.name is required');
            }
            info = info || {};
            this._appInfo = APP_INFO_PROPERTIES.reduce(function (accum, prop) {
                if (typeof info[prop] == 'string') {
                    accum = accum || {};
                    accum[prop] = info[prop];
                }
                return accum;
            },
            // @ts-ignore
            undefined);
        },

        /**
         * @private
         * This may be removed in the future.
         */
        _setApiField: function _setApiField(key, value) {
            this._api[key] = value;
        },

        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         */
        getApiField: function getApiField(key) {
            return this._api[key];
        },
        setClientId: function setClientId(clientId) {
            this._clientId = clientId;
        },
        getClientId: function getClientId() {
            return this._clientId;
        },

        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         */
        getConstant: function getConstant(c) {
            switch (c) {
                case 'DEFAULT_HOST':
                    return DEFAULT_HOST;
                case 'DEFAULT_PORT':
                    return DEFAULT_PORT;
                case 'DEFAULT_BASE_PATH':
                    return DEFAULT_BASE_PATH;
                case 'DEFAULT_API_VERSION':
                    return DEFAULT_API_VERSION;
                case 'DEFAULT_TIMEOUT':
                    return DEFAULT_TIMEOUT;
                case 'MAX_NETWORK_RETRY_DELAY_SEC':
                    return MAX_NETWORK_RETRY_DELAY_SEC;
                case 'INITIAL_NETWORK_RETRY_DELAY_SEC':
                    return INITIAL_NETWORK_RETRY_DELAY_SEC;
            }
            return Stripe[c];
        },
        getMaxNetworkRetries: function getMaxNetworkRetries() {
            return this.getApiField('maxNetworkRetries');
        },

        /**
         * @private
         * This may be removed in the future.
         */
        _setApiNumberField: function _setApiNumberField(prop, n, defaultVal) {
            var val = (0, utils_1.validateInteger)(prop, n, defaultVal);
            this._setApiField(prop, val);
        },
        getMaxNetworkRetryDelay: function getMaxNetworkRetryDelay() {
            return MAX_NETWORK_RETRY_DELAY_SEC;
        },
        getInitialNetworkRetryDelay: function getInitialNetworkRetryDelay() {
            return INITIAL_NETWORK_RETRY_DELAY_SEC;
        },

        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         *
         * Gets a JSON version of a User-Agent and uses a cached version for a slight
         * speed advantage.
         */
        getClientUserAgent: function getClientUserAgent(cb) {
            return this.getClientUserAgentSeeded(Stripe.USER_AGENT, cb);
        },

        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         *
         * Gets a JSON version of a User-Agent by encoding a seeded object and
         * fetching a uname from the system.
         */
        getClientUserAgentSeeded: function getClientUserAgentSeeded(seed, cb) {
            var _this = this;

            this._platformFunctions.getUname().then(function (uname) {
                var _a;
                var userAgent = {};
                for (var field in seed) {
                    userAgent[field] = encodeURIComponent((_a = seed[field]) !== null && _a !== void 0 ? _a : 'null');
                }
                // URI-encode in case there are unusual characters in the system's uname.
                userAgent.uname = encodeURIComponent(uname || 'UNKNOWN');
                var client = _this.getApiField('httpClient');
                if (client) {
                    userAgent.httplib = encodeURIComponent(client.getClientName());
                }
                if (_this._appInfo) {
                    userAgent.application = _this._appInfo;
                }
                cb(JSON.stringify(userAgent));
            });
        },

        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         */
        getAppInfoAsString: function getAppInfoAsString() {
            if (!this._appInfo) {
                return '';
            }
            var formatted = this._appInfo.name;
            if (this._appInfo.version) {
                formatted += "/" + this._appInfo.version;
            }
            if (this._appInfo.url) {
                formatted += " (" + this._appInfo.url + ")";
            }
            return formatted;
        },
        getTelemetryEnabled: function getTelemetryEnabled() {
            return this._enableTelemetry;
        },

        /**
         * @private
         * This may be removed in the future.
         */
        _prepResources: function _prepResources() {
            for (var name in resources) {
                // @ts-ignore
                this[(0, utils_1.pascalToCamelCase)(name)] = new resources[name](this);
            }
        },

        /**
         * @private
         * This may be removed in the future.
         */
        _getPropsFromConfig: function _getPropsFromConfig(config) {
            // If config is null or undefined, just bail early with no props
            if (!config) {
                return {};
            }
            // config can be an object or a string
            var isString = typeof config === 'string';
            var isObject = config === Object(config) && !Array.isArray(config);
            if (!isObject && !isString) {
                throw new Error('Config must either be an object or a string');
            }
            // If config is a string, we assume the old behavior of passing in a string representation of the api version
            if (isString) {
                return {
                    apiVersion: config
                };
            }
            // If config is an object, we assume the new behavior and make sure it doesn't contain any unexpected values
            var values = Object.keys(config).filter(function (value) {
                return !ALLOWED_CONFIG_PROPERTIES.includes(value);
            });
            if (values.length > 0) {
                throw new Error("Config object may only contain the following: " + ALLOWED_CONFIG_PROPERTIES.join(', '));
            }
            return config;
        }
    };
    return Stripe;
}
exports.createStripe = createStripe;
},{"./Error":57,"./resources":58,"./net/HttpClient":63,"./utils":59,"./crypto/CryptoProvider":64,"./RequestSender":60,"./StripeResource":61,"./Webhooks":62,"../package.json":56}],18:[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var NodePlatformFunctions_1 = require("./platform/NodePlatformFunctions");
var stripe_common_1 = require("./stripe.common");
var Stripe = (0, stripe_common_1.createStripe)(new NodePlatformFunctions_1.NodePlatformFunctions());
module.exports = Stripe;
// expose constructor as a named property to enable mocking with Sinon.JS
module.exports.Stripe = Stripe;
// Allow use with the TypeScript compiler without `esModuleInterop`.
// We may also want to add `Object.defineProperty(exports, "__esModule", {value: true});` in the future, so that Babel users will use the `default` version.
module.exports.default = Stripe;
},{"./platform/NodePlatformFunctions":39,"./stripe.common":23}],5:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bookTour = undefined;
var _this = undefined;

var _stripe = require('stripe');

var _stripe2 = _interopRequireDefault(_stripe);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _cuteAlert = require('./cute/cute-alert');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /*eslint-disable */


var stripe = new _stripe2.default('pk_test_51MlsyTDHCnKyZsj1opG7QfNnAgppZhevuyIdUn07wayuWfLMgf7gZYimQSueropdrwVNaigpiEEYeMt0rtAREQZY002aFju2pS');

var bookTour = exports.bookTour = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tourId) {
    var session;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _axios2.default.get('/api/v1/bookings/checkout-session/' + tourId);

          case 3:
            session = _context.sent;

            window.open(session.data.session.url, '_blank');
            _context.next = 10;
            break;

          case 7:
            _context.prev = 7;
            _context.t0 = _context['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context.t0.response.data.message,
              timer: 2500
            });

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this, [[0, 7]]);
  }));

  return function bookTour(_x) {
    return _ref.apply(this, arguments);
  };
}();
},{"stripe":18,"axios":16,"./cute/cute-alert":15}],8:[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSettings = undefined;
var _this = undefined;

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _cuteAlert = require('./cute/cute-alert');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /*eslint-disable */

var updateSettings = exports.updateSettings = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data, type) {
    var url, res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            url = type === 'data' ? '/api/v1/users/updateMe' : '/api/v1/users/updateMyPassword';
            _context.next = 4;
            return (0, _axios2.default)({
              method: 'PATCH',
              url: url,
              data: data
            });

          case 4:
            res = _context.sent;

            if (res.data.status === 'success') {
              (0, _cuteAlert.cuteToast)({
                type: 'success',
                title: 'Success',
                message: 'Your ' + type + ' has been updated',
                timer: 2000
              }).then(function () {
                location.reload(true);
              });
            }
            _context.next = 11;
            break;

          case 8:
            _context.prev = 8;
            _context.t0 = _context['catch'](0);

            (0, _cuteAlert.cuteToast)({
              type: 'error',
              title: 'Error',
              message: _context.t0.response.data.message,
              timer: 2500
            });

          case 11:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this, [[0, 8]]);
  }));

  return function updateSettings(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
},{"axios":16,"./cute/cute-alert":15}],1:[function(require,module,exports) {
'use strict';

var _this = undefined;

require('@babel/polyfill');

var _login = require('./login');

var _mapbox = require('./mapbox');

var _review = require('./review.js');

var _stripe = require('./stripe');

var _updateUser = require('./updateUser');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* eslint-disable */


//DOM Elements
var mapBox = document.getElementById('map');
var loginForm = document.querySelector('.form-login');
var signupForm = document.querySelector('.form-signup');
var logoutBtn = document.querySelector('.nav__el--logout');
var updateUserDataFrom = document.querySelector('.form-user-data');
var updateUserPasswordForm = document.querySelector('.form-user-settings');
var reviewForm = document.querySelector('.review-form');
var reviewsOption = document.querySelector('.reviews__options');
var reviewMore = document.querySelector('.reviews__more');
var reviewEdit = document.querySelector('.reviews__edit');
var reviewEditForm = document.querySelector('.reviews__edit__form');
var forgotPasswordForm = document.querySelector('.form-forget');
var resetPasswordForm = document.querySelector('.form-reset');
var bookBtn = document.getElementById('book-tour');
var reviewCard = '';
var reviewText = '';
var reviewStars = '';
var reviewId = '';

//Delegation
if (mapBox) {
  var locations = JSON.parse(mapBox.dataset.locations);
  (0, _mapbox.displayMap)(locations);
}

if (loginForm) {
  loginForm.addEventListener('submit', function (e) {
    e.preventDefault();
    var data = new FormData(e.currentTarget);
    var email = data.get('email');
    var password = data.get('password');
    (0, _login.login)({ email: email, password: password });
  });
}
if (logoutBtn) {
  logoutBtn.addEventListener('click', _login.logout);
}
if (signupForm) {
  signupForm.addEventListener('submit', function (e) {
    e.preventDefault();
    var data = new FormData(e.currentTarget);
    var name = data.get('name');
    var email = data.get('email');
    var password = data.get('password');
    var passwordConfirm = data.get('passwordConfirm');
    var photo = new FormData();
    (0, _login.signup)({ name: name, email: email, password: password, passwordConfirm: passwordConfirm });
  });
}

if (updateUserDataFrom) {
  updateUserDataFrom.addEventListener('submit', function (e) {
    e.preventDefault();
    var formData = new FormData(e.currentTarget);
    (0, _updateUser.updateSettings)(formData, 'data');
  });
}

if (updateUserPasswordForm) {
  updateUserPasswordForm.addEventListener('submit', function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
      var data, password, passwordConfirm, passwordCurrent;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              e.preventDefault();
              data = new FormData(e.currentTarget);
              password = data.get('password');
              passwordConfirm = data.get('passwordConfirm');
              passwordCurrent = data.get('passwordCurrent');
              _context.next = 7;
              return (0, _updateUser.updateSettings)({ password: password, passwordConfirm: passwordConfirm, passwordCurrent: passwordCurrent }, 'password');

            case 7:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
}

if (reviewForm) {
  var stars = reviewForm.querySelectorAll('.star');
  (0, _review.colorStars)(stars);
  reviewForm.addEventListener('submit', function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(e) {
      var save, review, tour, rating;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              e.preventDefault();
              save = reviewForm.querySelector('.save');
              review = reviewForm.querySelector('#review-input').value;
              tour = document.querySelector('.tour-id').getAttribute('data-id');
              rating = 0;

              stars.forEach(function (e) {
                if (e.classList.contains('star--active')) rating++;
              });
              save.textContent = 'Posting...';
              _context2.next = 9;
              return (0, _review.addReview)({ review: review, rating: rating, tour: tour });

            case 9:
              save.textContent = 'Add';

            case 10:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, _this);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }());
}

if (reviewMore) {
  reviewMore.addEventListener('click', function () {
    reviewsOption.classList.add('active');
  });
}
if (reviewsOption) {
  reviewCard = reviewsOption.parentElement;
  reviewText = reviewCard.querySelector('.reviews__text');
  reviewStars = reviewCard.querySelectorAll('.reviews_stars .reviews__star');
  document.addEventListener('click', function (e) {
    if (!e.target.classList.contains('reviews__options') && !e.target.classList.contains('reviews__more') && !e.target.classList.contains('reviews__edit--btn') && !e.target.classList.contains('reviews__delete--btn')) {
      reviewsOption.classList.remove('active');
    }
  });
  var deleteBtn = reviewsOption.querySelector('.reviews__delete--btn');
  var editBtn = reviewsOption.querySelector('.reviews__edit--btn');
  reviewId = reviewsOption.parentElement.getAttribute('data-id');
  deleteBtn.addEventListener('click', function () {
    (0, _review.deleteReview)(reviewId);
    reviewsOption.classList.remove('active');
    reviewCard.remove();
  });
  editBtn.addEventListener('click', function () {
    reviewEdit.classList.add('active');
    reviewsOption.classList.remove('active');
  });
}
if (reviewEditForm) {
  var cancel = reviewEditForm.querySelector('.cancel');
  var update = reviewEditForm.querySelector('.update');
  var _stars = reviewEditForm.querySelectorAll('.star');

  cancel.addEventListener('click', function () {
    return reviewEdit.classList.remove('active');
  });

  //make the form's stars enable
  (0, _review.colorStars)(_stars);
  reviewEditForm.addEventListener('submit', function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(e) {
      var review, rating, index, _index;

      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              e.preventDefault();
              review = reviewEditForm.querySelector('#review-input').value;
              rating = 0;

              _stars.forEach(function (e) {
                if (e.classList.contains('star--active')) rating++;
              });
              update.textContent = 'Updating...';
              _context3.next = 7;
              return (0, _review.updateReview)(review, rating, reviewId);

            case 7:
              reviewText.textContent = review;

              //color stars after update
              for (index = 0; index < rating; index++) {
                reviewStars[index].classList.remove('reviews__star--inactive');
                reviewStars[index].classList.add('reviews__star--active');
              }
              for (_index = rating; _index < 5; _index++) {
                reviewStars[_index].classList.remove('reviews__star--active');
                reviewStars[_index].classList.add('reviews__star--inactive');
              }
              //hide update form
              reviewEdit.classList.remove('active');
              update.textContent = 'Update';

            case 12:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function (_x3) {
      return _ref3.apply(this, arguments);
    };
  }());
}

if (forgotPasswordForm) {
  forgotPasswordForm.addEventListener('submit', function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(e) {
      var data, email;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              e.preventDefault();
              data = new FormData(e.currentTarget);
              email = data.get('email');
              _context4.next = 5;
              return (0, _login.forgotPassword)({ email: email });

            case 5:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, _this);
    }));

    return function (_x4) {
      return _ref4.apply(this, arguments);
    };
  }());
}

if (resetPasswordForm) {
  resetPasswordForm.addEventListener('submit', function (e) {
    e.preventDefault();
    var data = new FormData(e.currentTarget);
    var resetToken = data.get('resetToken');
    var password = data.get('password');
    var passwordConfirm = data.get('passwordConfirm');
    (0, _login.resetPassword)(password, passwordConfirm, resetToken);
  });
}

if (bookBtn) {
  bookBtn.addEventListener('click', function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(e) {
      var tourId;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              tourId = e.target.dataset.tourId;

              e.target.textContent = 'Processing...';
              _context5.next = 4;
              return (0, _stripe.bookTour)(tourId);

            case 4:
              e.target.textContent = 'Book tour now!';

            case 5:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, _this);
    }));

    return function (_x5) {
      return _ref5.apply(this, arguments);
    };
  }());
}
},{"@babel/polyfill":12,"./login":4,"./mapbox":6,"./review.js":3,"./stripe":5,"./updateUser":8}],694:[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';

var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };

  module.bundle.hotData = null;
}

module.bundle.Module = Module;

var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = '' || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + '42055' + '/');
  ws.onmessage = function (event) {
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      data.assets.forEach(function (asset) {
        hmrApply(global.parcelRequire, asset);
      });

      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          hmrAccept(global.parcelRequire, asset.id);
        }
      });
      // Clear the console after HMR
      console.clear();
    }

    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] â¨ Error resolved');

      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] ð¨  ' + data.error.message + '\n' + data.error.stack);

      removeErrorOverlay();

      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;

  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">ð¨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';

  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(+k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAccept(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAccept(bundle.parent, id);
  }

  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);

  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAccept(global.parcelRequire, id);
  });
}
},{}]},{},[694,1], null)
//# sourceMappingURL=/bundle.map